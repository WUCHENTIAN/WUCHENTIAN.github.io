<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>音名与表示</title>
    <link href="/2022/12/27/%E4%B9%90%E7%90%86%E5%85%A5%E9%97%A8/%E9%9F%B3%E5%90%8D%E4%B8%8E%E8%A1%A8%E7%A4%BA/"/>
    <url>/2022/12/27/%E4%B9%90%E7%90%86%E5%85%A5%E9%97%A8/%E9%9F%B3%E5%90%8D%E4%B8%8E%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgsimage-20221214223654457.png" /></p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimage-20221214223513892.png"alt="image-20221214223513892" /><figcaption aria-hidden="true">image-20221214223513892</figcaption></figure><p>{ % dplayer"url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4""addition=https://dplayer.daoapp.io/bilibili?aid=4157142""api=https://api.prprpr.me/dplayer/""pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg""id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false""token=tokendemo" %}</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.CPU是如何执行程序的</title>
    <link href="/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/Hardware/1.CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84/"/>
    <url>/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/Hardware/1.CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="turing-machine-的工作方式">1. Turing Machine 的工作方式</h2><h2 id="von-neumann-模型">2. Von Neumann 模型</h2><h2 id="section"></h2><h2 id="线路位宽与cpu位宽">3. 线路位宽与CPU位宽</h2><h2 id="程序执行的基本过程">4. 程序执行的基本过程</h2><h2 id="a-1-2-这条程序在计算机中如何被执行">5. a = 1 + 2这条程序在计算机中如何被执行</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Notes</category>
      
      <category>Hardware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/4.%E8%BF%9B%E7%A8%8B%20and%20Threads/"/>
    <url>/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/4.%E8%BF%9B%E7%A8%8B%20and%20Threads/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/3.Memory%20Management/"/>
    <url>/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/3.Memory%20Management/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/2.Operating%20System/"/>
    <url>/2022/12/18/Computer%20Organization%20and%20Architecture/Notes/2.Operating%20System/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>13.指令系统</title>
    <link href="/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/13.%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/13.%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/13.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.虚拟存储器</title>
    <link href="/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/12.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/12.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/12.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.冗余磁盘阵列</title>
    <link href="/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/11.%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/"/>
    <url>/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/11.%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/11.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.外部存储器</title>
    <link href="/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/10.%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/10.%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/10.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.高度缓存存储器</title>
    <link href="/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/9.%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2022/12/08/Computer%20Organization%20and%20Architecture/Slides/9.%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/9.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.内部存储器</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/8.%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/8.%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/8.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.二进制编码的十进制数运算</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/7.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/7.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/7.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.浮点数运算</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/6.%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/6.%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/6.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.整数运算</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/5.%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/5.%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/5.pdf" width="100%" height="550px" type="application/pdf"></div><h2 id="整数加法">1. 整数加法</h2><h3 id="section">1.1.</h3><h2 id="整数减法">2. 整数减法</h2><h2 id="整数乘法">3. 整数乘法</h2><h2 id="整数除法">4. 整数除法</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.数据校验码</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/4.%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/4.%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/4.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.数据的机器级表示</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/3.%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/3.%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/3.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.计算机的顶层视图</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/2.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.计算机系统概述</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/1.pdf" width="100%" height="550px" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.须知</title>
    <link href="/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/%E9%A1%BB%E7%9F%A5/"/>
    <url>/2022/11/10/Computer%20Organization%20and%20Architecture/Slides/%E9%A1%BB%E7%9F%A5/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/COA/0.pdf" width="100%" height="550px" type="application/pdf"></div><p></br></p><ul><li>任桐炜老师的 COA 讲得太好了，故直接无脑放PPT（（（</li><li>手机版似乎不能预览 PDF 文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Organization and Architecture</category>
      
      <category>Slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 常用函数</title>
    <link href="/2022/11/09/C++%20Basic/Notes/C++%20%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/09/C++%20Basic/Notes/C++%20%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串">1. 字符串</h3><h4 id="char-和-string-相互转化">1. char * 和 string 相互转化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str;<br><span class="hljs-type">char</span> *c_str;<br></code></pre></td></tr></table></figure><ul><li><p>string 转 char *：</p><ul><li>``` c_str = str.c_str(); <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><br>- <span class="hljs-built_in">char</span> * 转 <span class="hljs-built_in">string</span>:<br><br>  - <span class="hljs-string">``</span><span class="hljs-string">`c++</span><br><span class="hljs-string">    str = c_str;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="字符串字典序比较大小">2. 字符串字典序比较大小</h4><h4 id="字符串转数字">3. 字符串转数字</h4><p>可以使用 atoi() 或者是 stoi()</p><blockquote><p>int atoi(const char* ch);</p><p>int stoi(const string* str);</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">str2Int1</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(str);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">str2Int2</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Proficiency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Burt</title>
    <link href="/2022/11/09/Auto%20Testing/Burt/"/>
    <url>/2022/11/09/Auto%20Testing/Burt/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/Testing/Burt.pdf" width="100%" height="550px" type="application/pdf"></div><p>本来也有一些笔记，但是被垃圾mac吃掉了（（（</p>]]></content>
    
    
    <categories>
      
      <category>Auto Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Testing</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RecDroid</title>
    <link href="/2022/11/08/Auto%20Testing/RecDroid/"/>
    <url>/2022/11/08/Auto%20Testing/RecDroid/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/Testing/RecDroid.pdf" width="100%" height="550px" type="application/pdf"></div><h2id="recdroid从-android-应程序的错误报告中动进端到端崩溃复现">ReCDroid+：从Android 应⽤程序的错误报告中⾃动进⾏端到端崩溃复现</h2><p>⽤⾃然语⾔处理 (NLP)、深度学习和动态 GUI探索来合成事件序列，以重现报告的崩溃。</p><h3 id="主要背景">1. 主要背景</h3><h4 id="现状是怎样的">1.1. 现状是怎样的</h4><ul><li>移动应⽤程序（应⽤程序）变得⾮常流⾏</li><li>最近的⼀项研究发现，如果反复遇到功能问题，88%的应⽤程序用户会放弃应⽤</li></ul><h4 id="现有方法如何解决">1.2. 现有方法如何解决</h4><h5 id="通常使用-bug-tracking-systems">1.2.1. 通常使用 bug-trackingsystems</h5><ul><li>Bugzilla</li><li>Google Code Issue Tracker</li><li>Github Issue Tracker</li><li>etc</li></ul><h5 id="现有的分析-reproducibility-的方法">1.2.2. 现有的分析reproducibility 的方法</h5><p>为⼤多数现有技术都<strong>专注于提⾼ bug report的质量</strong>。（就像之前的BURT，将用户的自然语言转化为一个规范的软件报告）</p><ul><li>Yakusu将错误报告转换为与错误报告匹配步骤最多的测试⽤例。他们都没有考虑使⽤错误报告中的信息来⾃动指导错误再现</li><li>FUSION 可以⾃动完成 Android错误报告，以便为开发⼈员提供更多可操作的信息。</li></ul><p>相⽐之下，ReCDroid+将报告的crash描述作为输⼊，<strong>⽆论其质量如何，并提取重现崩溃所需的信息</strong>。ReCDroid+ 也不同于从错误报告合成信息的技术，因为它们专注于提取有⽤的信息，⽽不是<strong>直接针对重现崩溃</strong>。此外，ReCDroid+提供了⼀个准确的解决⽅案，通过使⽤ CNN 对句⼦特征进⾏建模和 LSTM来⾃动提取描述步骤再现 (S2R) 的句⼦</p><h4 id="现有方法的局限性">1.3. 现有方法的局限性</h4><p>​⼀旦开发⼈员收到崩溃/错误报告，调试问题的第⼀步就是在应⽤程序中<strong>重现问题</strong>。然⽽，这⼀步具有挑战性，因为提供的信息是⽤⾃然语⾔编写的。⾃然语⾔本质上是<strong>不精确和不完整</strong>的。即使假设开发⼈员可以完全理解错误报告，实际重现也可能具有挑战性，因为应⽤程序可能具有<strong>复杂的事件驱动和GUI 相关⾏为</strong>，并且可能需要许多基于 GUI 的操作来重现崩溃。</p><h4 id="现在还存在的主要挑战">1.4. 现在还存在的主要挑战</h4><p>​ bug report 不能保证十全十美——即使是优质的 bug report也可能不完整或不准确。</p><p>​ 提高bug report的质量是一种思路，但是也要提高复现 crash 的能力</p><h3 id="主要方法">2. 主要方法</h3><h4 id="方法框架是什么">2.1. 方法框架是什么</h4><p><strong>预处理、错误报告分析和动态探索</strong></p><p>接下来，ReCDroid+ 采⽤了⼀种新颖的动态探索，以从错误报告中提取的信息为指导，以完全重现崩溃。 ReCDroid+ 将错误报告和APK 作为输⼊，并输出包含导致崩溃的 GUI 事件序列的脚本，该脚本可以直接在执⾏引擎（Robotium和UI Automator）上重放。</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgsimage-20221108164012344.png" style="zoom:70%;" /></p><h4 id="实验步骤用了哪些现有的技术">2.2.实验步骤/用了哪些现有的技术</h4><p>给定原始的错误报告</p><ul><li><h5 id="第一步提取崩溃和s2r语句">第一步、提取崩溃和S2R语句</h5><ul><li>HTML解析器</li><li>卷积神经⽹络 (CNN)</li><li>LSTM（一种RNN，循环神经网络）</li></ul></li><li><h5id="第二步分析报告的-s2r-语句动识别复现-crash-所必需的-gui-组件和相关信息">第二步、分析报告的S2R 语句⾃动识别复现 crash 所必需的 GUI 组件和相关信息</h5><ul><li><p>预处理S2R</p><ul><li>使⽤ SpaCy来检测基于标点符号的句⼦分割</li><li>使⽤ Word2vec构建预训练的词向量，⽤作深度学习模型的输⼊</li><li>使⽤ mean-shift 这一⽆监督聚类算法来聚类 11 个向量，来使 S2R变得更加精简 &amp; 准确</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgsimage-20221108203210902.png" style="zoom:45%;" /></p></li><li><p>分析（预处理后的） S2R</p><ul><li>匹配语法模式（共三类：单击事件，编辑事件，手势事件）</li><li>这一方法的缺点也很明显，就是对于非结构化文本（模棱两可的表述/复杂的表述/etc）的正确率太低</li></ul></li></ul></li><li><p><strong>第三步、从错误报告中提取的信息为指导，以完全重现崩溃</strong></p><blockquote><p>采⽤了⼀种<strong>新颖的动态探索</strong>算法</p></blockquote><ul><li><p>根据动态有序事件树（DOET） $ T = (V , E)$ 来指导对应⽤程序 GUI的探索。节点集 <span class="math inline">\(V\)</span> 代表应⽤程序的 GUI组件， ⽽边 <span class="math inline">\(E\)</span>表示⽰在运⾏时观察到的事件转换</p></li><li><p>ReCDroid+的引导探索算法</p></li><li><p>动态匹配：匹配运⾏时观察到的 GUI 组件</p><ul><li>优化：避免探索不相关的 GUI 组件来提⾼算法的效率</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgsimage-20221109142234861.png" style="zoom:50%;" /></p></li></ul></li></ul><h4 id="在现有技术上如何改进而适配当前的问题">2.3.在现有技术上如何改进而适配当前的问题</h4><ul><li>挑战 1：<strong>识别 crash report 并提取 S2R和崩溃句⼦</strong>。错误报告通常包含混合类型的信息，例如注释、代码、问题状态以及与错误⽆关的信息。<ul><li>设计了⼀种<strong>新颖的深度学习模型</strong>，可以<strong>⾃动识别S2R 和crash语句</strong></li></ul></li><li>挑战2：<strong>将错误报告映射到事件的语义表⽰中</strong>。第⼆个设计挑战是从错误报告中提取再现步骤的语义表⽰，由元组{action, GUI component, input}定义。⼀个平凡的解决方案是使⽤简单的关键字搜索将错误报告中的每个句⼦与应⽤程序的GUI组件的名称（即显⽰的⽂本）<strong>直接</strong>进⾏匹配。但是，关键字搜索<strong>⽆法可靠地</strong>检测输⼊值或用户操作、GUI组件和输⼊之间可能存在的⼤量句法关系。同时reporter可能会使⽤与应⽤程序的GUI 组件名称不直接匹配的新词。<ul><li>提取过程可以表述为⾃然语⾔处理 (NLP) 中的槽填充问题</li><li>使用了Word2vec 模型计算的 word embedding</li></ul></li><li>挑战 3：<strong>为错误再现创建完整和正确的序列。</strong>RecDroid⾯临的⼀个关键挑战是，即使是优质的 bug report也可能不完整或不准确。例如，被认为是显⽽易⻅的步骤可能会被报告者省略或忘记。因此，我们的⽅法必须能够<strong>填补这些缺失的步骤</strong>。理想情况下，已从报告中提取的信息可⽤于提供“提⽰”以识别和填写缺失的操作。<ul><li>对于RecDroid的问题域，带有回溯的引导式 DFS 更合适</li></ul></li><li>挑战 4：<strong>提⾼复现效率</strong>。确定重现 crash所需的最⼩操作集的同时，也可能需要更多的分析时间。<ul><li>设计了⼀组优化策略和启发式方法：包括检查屏幕的等效性和检测循环以避免冗余回溯的策略，并根据它们引起错误的可能性优先考虑要探索的GUI</li></ul></li></ul><h5 id="section"></h5><h3 id="最终效果">3. 最终效果</h3><h4 id="实验如何设计">3.1. 实验如何设计</h4><h5 id="观察">3.1.1. 观察</h5><p>作为第⼀步，我们花了⼀个⽉的时间研究⼤量的 Android bug报告，了解它们的特点，以指导 ReCDroid+ 的设计和实现。</p><h5 id="recdroid方法">3.1.3. RecDroid+方法</h5><h4 id="实验如何开展">实验如何开展</h4><h4 id="用了哪些评估指标效果如何">用了哪些评估指标，效果如何</h4><ul><li><p>复现 crash 的成功率：42/54 = 77.7%</p></li><li><p>复现 crash 的耗时：16～7331，average=466.4</p></li><li><p>对S2R提取/crash语句提取的<strong>准确率、召回率和 <ahref="https://baike.baidu.com/item/F1分数/13864979">F1 分数</a></strong><span class="math display">\[F_{\beta}=(1+\beta^2)\frac{precision \cdot recall}{\beta^2\cdotprecision + recall}\]</span></p></li><li><p>RecDroid+/ RecDroid+N/ RecDroid+D横向比较</p></li></ul><p>整体上，在效率和准确度上有相当程度的提高</p><h4 id="实验中暴露出来的不足有哪些">实验中暴露出来的不足有哪些</h4><ul><li><p>分析（预处理后的） S2R</p><ul><li><p>匹配语法模式（共三类：单击事件，编辑事件，手势事件）</p></li><li><p>这一方法的缺点也很明显，就是对于非结构化文本（模棱两可的表述/复杂的表述/etc）的正确率太低</p></li></ul></li><li><p>不⽀持 item-list，swipe 或 scroll actions</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Auto Testing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Testing</tag>
      
      <tag>NLP</tag>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Encapsulation</title>
    <link href="/2022/11/08/C++%20Basic/C++%20Design/C++%20Encapsulation/"/>
    <url>/2022/11/08/C++%20Basic/C++%20Design/C++%20Encapsulation/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象">1. 面向对象</h2><p><strong>类</strong></p><ul><li><p><strong>类的定义和声明是分开的，类声明的头文件仅仅给出接口部分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TDate</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsLeapYear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> year,month,day;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tdate::SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>&#123;<br>    year = y;<br>    month = m;<br>    day = d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TDate::IsLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (year%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>构造函数</strong></p><ul><li><p>对象的<strong>初始化</strong>，构造函数可以被定义，也可以只声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>();  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br> <br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>(<span class="hljs-type">void</span>)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Line::setLength</span><span class="hljs-params">(<span class="hljs-type">double</span> len)</span></span>&#123;<br>    length = len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Line::getLength</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   Line line;<br>   <span class="hljs-comment">// 设置长度</span><br>   line.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">6.0</span>); <br>   cout &lt;&lt; <span class="hljs-string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="hljs-built_in">getLength</span>() &lt;&lt;endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">//Object is being create</span><br><span class="hljs-comment">//6.0</span><br></code></pre></td></tr></table></figure></li><li><p>描述</p><ul><li><p>与类同名，<strong>无返回类型</strong>，构造函数可以<strong>有参数</strong>，初始化要带参数，比如上面的Line类的构造函数可以改为Line(doublelen)，构造函数的定义改为将length初始化为len</p></li><li><p>自动调用，不可以直接调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i);<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">char</span> *p);<br>&#125;;<br>A a1 = <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//等价于A a1(a) //等价于A a1=1;自动调用A(int i);</span><br>A a2 = <span class="hljs-built_in">A</span>();<span class="hljs-comment">//调用A()</span><br>A a3 = <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<span class="hljs-comment">//等价于A a3(&quot;abcd&quot;) //等价于 A a3 = &quot;abcd&quot;//调用A (char *p)</span><br>A a[<span class="hljs-number">4</span>];<br>A b[<span class="hljs-number">5</span>] = &#123;<span class="hljs-built_in">A</span>(), <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">A</span>(<span class="hljs-string">&quot;abcd&quot;</span>), <span class="hljs-number">2</span>, <span class="hljs-string">&quot;xyz&quot;</span> &#125;;<br></code></pre></td></tr></table></figure></li><li><p>可重载</p></li><li><p>当类中没有提供构造函数时，编译系统自动提供</p></li><li><p>一般声明为public，但也可以定义为private</p></li></ul></li></ul></li><li><p><strong>成员初始化表</strong></p><ul><li><p>构造函数的补充</p></li><li><p>先于构造体函数执行，按类数据成员声明次序，减轻compiler的负担</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span>    x;<br>    <span class="hljs-type">const</span>  <span class="hljs-type">int</span>   y;<br>    <span class="hljs-type">int</span>&amp; z;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(): <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>)  &#123;  x = <span class="hljs-number">100</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>注意</p><ul><li>再构造函数中尽量使用成员初始化表代替赋值动作</li><li>数据成员太多时，不要使用，降低了可维护性</li></ul></li></ul></li><li><p><strong>析构函数</strong></p><ul><li>结构：~类名()</li><li>对象消亡时，系统自动调用，释放对象持有的非内存资源</li><li>一般声明在public中，也可以声明在private中</li><li>没有返回值，不接受参数（不能重载）</li></ul></li><li><p><strong>拷贝构造函数</strong></p><ul><li><p>默认拷贝构造函数执行的是浅拷贝，一旦对象存在了动态成员，浅拷贝会出问题。此时要使用深拷贝</p></li><li><p>参考网址：https://www.cnblogs.com/alantu2018/p/8459250.html</p></li><li><p>例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">string</span>(<span class="hljs-type">char</span> *str)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,str);<br>        &#125;<br>    ~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//浅拷贝：s2和s1这两个指针指向堆里的同一空间，再销毁对象时，两个对象的析构函数将同一个内存空间释放两次，这就是错误所在</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string &amp; c)&#123;<br>            p=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(c.p)+<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">strcpy</span>(p,c.p);<br>        &#125;<br>    ~<span class="hljs-built_in">string</span>()&#123;<br>            <span class="hljs-keyword">delete</span>[] p;<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>    string s2=s1;<br>    <span class="hljs-comment">//深拷贝：s1和s2各自指向一段内存空间，他们指向的空间具有相同的内容</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>移动构造函数</strong></p></li><li><p><strong>动态对象</strong></p><ul><li>在heap（堆）中创建</li><li>new/delete，使用new和delete可以自动调用constructor和destructor<ul><li>new 和 delete 即是关键字又是操作符</li></ul></li><li>malloc和free不调用析构函数</li></ul></li><li><p><strong>const 成员</strong></p><ul><li><p>初始化放在构造函数的成员初始化表中进行</p></li><li><p>```c++ class A{<br />const int x;</p><p>public: A(int c):x(c){} }</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>    <br><br>- **静态成员**<br><br>  - 静态成员变量：静态成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为静态成员变量分配一份内存，所有对象都是这份内存中的数据，参考网址： http:<span class="hljs-regexp">//</span>c.biancheng.net<span class="hljs-regexp">/view/</span><span class="hljs-number">2227</span>.html <br><br>    - 静态成员变量必须在类声明的**外部初始化**<br><br>      ```c++<br>      type class::name = value;<span class="hljs-regexp">//</span>具体实例见我的clion<br></code></pre></td></tr></table></figure></li><li><p>静态成员函数：静态成员函数只能访问静态成员（变量，函数）；静态成员函数与普通成员函数的根本区别在于：普通成员函数有 <strong>this指针</strong>，可以<strong>访问类中的任意成员</strong>；而静态成员函数没有this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p></li></ul></li></ul><h1 id="section"></h1><ul><li><p><strong>友元</strong></p><ul><li><p>分类</p><ul><li><p>友元函数</p></li><li><p>友元类</p></li><li><p>友元类成员函数</p></li><li><p>```c++ void func(); class B; class C{ void f(); } class A{ friendvoid func(); //友元函数 friend class B; //友元类 friend void C::f();//友元类成员函数 } <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><br>- 特性<br><br>  - 友元不具有传递性<br><br>    - ```c++<br><span class="hljs-class">      <span class="hljs-keyword">class</span> <span class="hljs-type">Matrix</span>&#123;</span><br><span class="hljs-class">          friend void multiply(<span class="hljs-type">Matrix</span> &amp;<span class="hljs-title">m</span>, <span class="hljs-type">Vector</span> &amp;<span class="hljs-title">v</span>, <span class="hljs-type">Vector</span> &amp;<span class="hljs-title">r</span>);</span><br><span class="hljs-class">      &#125;;</span><br><span class="hljs-class">      <span class="hljs-keyword">class</span> <span class="hljs-type">Vector</span>&#123;</span><br><span class="hljs-class">          friend void multiply(<span class="hljs-type">Matrix</span> &amp;<span class="hljs-title">m</span>, <span class="hljs-type">Vector</span> &amp;<span class="hljs-title">v</span>, <span class="hljs-type">Vector</span> &amp;<span class="hljs-title">r</span>);</span><br><span class="hljs-class">      &#125;;</span><br><span class="hljs-class">      //定义在两个类中的友元是单独针对<span class="hljs-type">Matrix</span>或者<span class="hljs-type">Vector</span>类的，两个不互通</span><br></code></pre></td></tr></table></figure></p></li><li><p>上述代码不能编译通过，需要进行<strong>前置声明</strong>，在最开头加上一句<strong>voidmultiply(Matrix &amp;m, Vector &amp;v, Vector&amp;r);</strong>即可</p></li><li><p>C++11之后可以访问private成员</p></li></ul></li><li><p>原则</p><ul><li><p>避免将数据成员放在公开接口中</p></li><li><p>努力将接口完满且最小化</p></li><li><p>```c++ class AccessLevels { public: int getReadOnly const {return readOnly; } void setReadWrite(int value) { readWrite = value; }int getReadWrite() { return readWrite; } void setWriteOnly(int value) {writeOnly = value; } private: int noAccess; int readOnly; int readWrite;int writeOnly; }; <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>  - 作用<br><br>    - 提高程序设计的灵活性<br>    - 数据保护和对数据的存取效率之间的一个折中方案<br><br>- **继承**<br><br>  - 单继承<br><br>    - 子类无法访问父类的<span class="hljs-keyword">protected</span>元素<br><br>    - 子类无法继承父类的构造函数，友元函数，析构函数<br><br>    - ```c++<br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;       <br>        <span class="hljs-type">int</span> id; <br>        <span class="hljs-keyword">public</span>:<br>          <span class="hljs-type">char</span> nickname[<span class="hljs-number">16</span>];<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ID</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  </span>&#123; id = x; &#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNickName</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123; <span class="hljs-built_in">strcpy</span>(nickname,s);&#125; <br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">          </span>&#123; cout &lt;&lt; nickname &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt;endl; &#125;<br>        <span class="hljs-comment">//virtual使得函数可以被动态重载</span><br>      &#125;;<br>      <span class="hljs-comment">//父类的变量子类同样拥有，可以通过sizeof验证</span><br>      <span class="hljs-comment">//子类中父类已经定义元素的访问权限与父类相同</span><br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduated_Student</span> : <span class="hljs-keyword">public</span> Student&#123;      <br>        <span class="hljs-type">int</span> dept_no; <br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDeptNo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; dept_np = x; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ID</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-comment">//函数重定义（静态的，并非动态）,但不是同一个名空间</span><br>          &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>&#123;<br>            cout &lt;&lt; dept_no &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt;endl; <br>          &#125;<br>        <span class="hljs-keyword">private</span>:<br>          <span class="hljs-keyword">using</span> Student::nickname; <span class="hljs-comment">//Undergraduated_Student的派生类不能再访问nickname，由于权限变成private</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNickName</span><span class="hljs-params">()</span></span>; <br>        <span class="hljs-comment">//编译器：1.找名字（可以调用则调用，否则不调用）；2.在子类中找到了SetNickName的名空间，就不会去父类找（名空间覆盖）；3.子类SetNickName名空间没有匹配char* s的函数，因此调用失败</span><br>      &#125;;<br></code></pre></td></tr></table></figure></p></li><li><p>重定义，重载和重写的区别</p><ul><li>重载overload：是函数名相同，参数列表不同，重载只是在类的内部存在，但是不能靠返回类型来判断，若基类的虚函数值给出声明没有给出实现，子类在使用该函数时为重载（函数名相同，参数类型不同）</li><li>重写override：子类重新定义父类中有相同名称和参数的虚函数；被重写的函数不能是static类型必须是virtual；重写函数必须有相同的类型、名称和参数列表；重写函数的访问修饰符可以改变，尽管virtual是private，但是派生类中重写可以改写为public，甚至protected也是可以的（protected的作用是保护变量和函数，类对象不能直接访问自己的保护变量，只能通过类函数来访问；保护变量可以被派生类的成员访问，但是不能被派生类的对象直接访问）</li><li>重定义redefining：是指派生类的函数屏蔽了与其同名的基类函数；如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏；如果派生类的函数名和参数都和基类相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Base display()&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Base say()&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exec</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">display</span>();<span class="hljs-built_in">say</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(string a)</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Base f1(string)&quot;</span> &lt;&lt; endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;Base f1(int)&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-comment">//重载，两个f1函数在Base类的内部被重载</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeriveA</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;DeriveA dispaly()&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-comment">//重写</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;DeriveA f1(int,int)&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-comment">//重定义</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;DeriveA say()&quot;</span> &lt;&lt; endl&#125;;<span class="hljs-comment">//重定义</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeriveB</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;DeriveB f1(int)&quot;</span> &lt;&lt; endl;&#125;<span class="hljs-comment">//重定义</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    DeriveA a;<br>    Base *b=&amp;a;<br>    b-&gt;<span class="hljs-built_in">exec</span>();<span class="hljs-comment">//调用DeriveA的display()方法以及Base的say()方法</span><br>    a.<span class="hljs-built_in">exec</span>();<span class="hljs-comment">//调用DeriveA的display()方法以及Base的say()方法</span><br>    a.<span class="hljs-built_in">say</span>();<span class="hljs-comment">//调用DeriveA的say()方法</span><br>    DeriveB c;<br>    c.<span class="hljs-built_in">f1</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//调用DeriveB的f1()方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关于static有几点要说</p><ul><li>静态数据成员和静态成员函数都可以被继承</li><li>父类的static变量和函数在派生类中依然可用，但是受访问控制（比如，父类的private域中的就不可访问 ），而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意</li><li>static函数没有虚函数一说，static函数实际上是加上了<strong>访问控制</strong>的<strong>全局函数</strong>，全局函数没有虚函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-type">int</span> A::num=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> m):<span class="hljs-built_in">i</span>(m)&#123;&#125;<br>&#125;;<br><span class="hljs-comment">//int B::num=200;</span><br></code></pre></td></tr></table></figure><p>A,B中num值相等，num的地址也相等，故父类子类指向是同一个全局数据区的static变量，此外，注释的那句话如果不添加注释会发生编译错误</p></li></ul></li><li><p>构造函数的执行次序</p><ul><li>基类构造函数</li><li>派生类对象成员类的构造函数</li><li>派生类构造函数</li></ul></li><li><p>析构函数的执行次序</p><ul><li>与构造函数相反</li></ul></li><li><p>基类构造函数的调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;    <br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; &#125;<br>     <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;   <br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">B</span>() &#123; y = <span class="hljs-number">0</span>; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123; y = i; &#125;<br>   <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j):<span class="hljs-built_in">A</span>(i) <br>   &#123;   y = j;  &#125;<br>&#125;;<br><br>B b1;     <span class="hljs-comment">//执行A::A()和B::B()</span><br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//执行A::A()和B::B(int)</span><br><span class="hljs-function">B <span class="hljs-title">b3</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//执行A::A(int)和B::B(int,int)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="section-1"></h1><h2 id="虚函数">3. 虚函数</h2><p>类型相容、赋值相容</p><p>Q: a、b是什么类型时，a = b合法？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a; B b;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;&#125;;<br>a = b;<br><span class="hljs-comment">// 对象切片，取出b的每个对象按位拷贝到a，拷贝之后b属于类A，去掉专属于类型B的属性</span><br></code></pre></td></tr></table></figure><ul><li>对象的身份发生变化</li><li>属于派生类的属性已经不存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">B pb;  <br>A* pa = &amp;pb;    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <br>  <br>B  b;   <br>A &amp;a=b; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <br></code></pre></td></tr></table></figure><ul><li><p>对象的身份没有发生变化</p></li><li><p>前期绑定--&gt;默认</p><ul><li>编译时刻</li><li>依据对象的静态类型</li><li>效率高但是灵活性差</li></ul></li><li><p>动态绑定--&gt; 显示指出 virtual</p><ul><li>运行时刻</li><li>依据对象的实际类型（动态）</li><li>灵活性高、效率低</li></ul></li><li><p>限制</p><ul><li>类的成员函数才可以是虚函数</li><li>静态成员函数不能是虚函数</li><li>内联成员函数不能是虚函数</li><li>构造函数不能是虚函数</li><li>析构函数可以（往往）是虚函数</li></ul></li><li><p>后期绑定的实现</p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-built_in">h</span>();<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">f</span>();<br>    <span class="hljs-built_in">h</span>();<br>&#125;<br>A a;<br>B b;<br>A *p;<br>p=&amp;a;<span class="hljs-comment">//情况1</span><br>p=&amp;b;<span class="hljs-comment">//情况2</span><br><span class="hljs-comment">//情况1的数据对象为x和y，虚函数表为A::f和A::g</span><br><span class="hljs-comment">//情况2的数据对象为x、y和z，虚函数表为B::f和A::g</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123; <span class="hljs-built_in">f</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span>  <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">f</span>(); <span class="hljs-built_in">g</span>(); &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>B b;<span class="hljs-comment">//A::A(),A::f,B::B()</span><br>A *p=&amp;b;<br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//B::f</span><br>p-&gt;<span class="hljs-built_in">g</span>(); <span class="hljs-comment">//A::g</span><br>p-&gt;<span class="hljs-built_in">h</span>();<span class="hljs-comment">//A::h,B::f,A::g</span><br></code></pre></td></tr></table></figure><p>直到构造函数返回之后，对象方可正常使用</p></li><li><p>纯虚函数和抽象类</p><ul><li>纯虚函数<ul><li>声明时在函数原型后面加上 = 0</li><li>往往只给出函数声明，不给出实现</li></ul></li><li>抽象类<ul><li>至少包含一个纯虚函数</li><li>不能用于创建对象</li><li>为派生类提供框架，派生类提供抽象基类的所有成员函数的实现</li></ul></li></ul></li><li><p>绝对不要重新定义继承而来的缺省参数值</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>C++ Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object Oriented</tag>
      
      <tag>Paradigm</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket 实现文件传输</title>
    <link href="/2022/11/03/Computer%20Networking/Socket/Socket%20%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <url>/2022/11/03/Computer%20Networking/Socket/Socket%20%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Network</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Search Tree</title>
    <link href="/2022/11/02/Data%20Structure/Search%20Tree/"/>
    <url>/2022/11/02/Data%20Structure/Search%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="binary-search-tree">1. Binary Search Tree</h3><blockquote><p>二叉搜索树具有很良好的 插入/删除/搜索 性质</p><p>这是传统的线性表做不到的</p></blockquote><h4 id="递归式定义">1.1. 递归式定义</h4><p>​ A binary search tree is a binary tree that may be empty. A nonemptybinary search tree satisfies the following properties:</p><ul><li><p>Every element has a <em>key</em> (是一个包含序关系的值，用于比较)and no two elements have the same key (因此所有的 key值都要是不重复的)</p></li><li><p>The keys(if any) in the left subtree of the root are smaller thanthe key in the root.</p></li><li><p>The keys(if any) in the right subtree of the root are larger thanthe key in the root.</p></li><li><p>The left and right subtrees of the root are also binary searchtrees.</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211020920683.png" alt="image-20221102092002652" style="zoom: 33%;" /></p><h4 id="带索引的二叉搜索树">1.2. 带索引的二叉搜索树</h4><ul><li><p>An indexed binary search tree is derived from an ordinary binarysearch tree by <strong>adding the field leftSize to each treenode</strong>. （添加一个左子树节点数的缓存）</p></li><li><p>Value in Leftsize field = number of the elements in the node’sleft subtree +1</p></li></ul><h4 id="代码实现">1.3. 代码实现</h4><h5 id="节点与树">1.3.1. 节点与树</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BinaryNode class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryNode</span>&#123; <br>  BinaryNode( Comparable theElement )&#123; <br>    <span class="hljs-built_in">this</span>(theElement, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <br>  &#125;<br>BinaryNode( Comparable theElement, BinaryNode lt, BinaryNode rt )&#123; <br>    element = theElement; left = lt; right = rt; <br>  &#125;<br>  Comparable element;<br>  BinaryNode left;<br>  BinaryNode right;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Binary search tree class skeleton</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span>&#123; <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinarySearchTree</span><span class="hljs-params">( )</span> &#123;root = <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">( )</span> &#123;root = <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">( )</span> &#123;<span class="hljs-type">return</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> = <span class="hljs-literal">null</span>;&#125;<br><span class="hljs-keyword">public</span> Comparable <span class="hljs-title function_">find</span><span class="hljs-params">(Comparable x)</span>&#123;<br>  <span class="hljs-keyword">return</span> elementAt(find( x, root));<br>&#125;<br><span class="hljs-keyword">public</span> Comparable <span class="hljs-title function_">findMin</span><span class="hljs-params">()</span>&#123; <br>  <span class="hljs-keyword">return</span> elementAt( findMin( root ) ); <br>&#125;<br><span class="hljs-keyword">public</span> Comparable <span class="hljs-title function_">findMax</span><span class="hljs-params">()</span>&#123; <br>  <span class="hljs-keyword">return</span> elementAt( findMax( root ) ); <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Comparable x)</span>&#123;<br>  root = insert( x, root ); <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Comparable x)</span>&#123;<br>  root = remove( x, root ); <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">()</span><br><span class="hljs-keyword">private</span> BinaryNode root;<br><span class="hljs-keyword">private</span> Comparable <span class="hljs-title function_">elementAt</span><span class="hljs-params">( BinaryNode t )</span>&#123; <br>  <span class="hljs-type">return</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> = <span class="hljs-literal">null</span> ? Null : t.element; <br>&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">find</span><span class="hljs-params">(Comparable x, BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">findMin</span><span class="hljs-params">(BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">findMax</span><span class="hljs-params">(BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">insert</span><span class="hljs-params">(Comparable x, BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">remove</span><span class="hljs-params">(Comparable x, BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">removeMin</span><span class="hljs-params">(BinaryNode t)</span>&#123;...&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(BinaryNode t)</span>&#123;...&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="搜索">1.3.2. 搜索</h5><p>我们发现搜索操作最多只需要进行一个树高的次数，可见二叉搜索树的<strong>搜索</strong>性能确实非常优越</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Find operation for binary search trees</span><br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">find</span><span class="hljs-params">(Comparable x, BinaryNode t)</span>&#123; <br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(x. compareTo( t.element ) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> find( x, t.left );<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.compareTo( t.element ) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> find( x, t.right );<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> t; <span class="hljs-comment">//Match</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="findmax-和-findmin">1.3.3. findMax 和 findMin</h5><p>可以递归也可以不递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Recursive implementation of findMin for binary search trees</span><br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">findMin</span><span class="hljs-params">( BinaryNode t )</span>&#123; <br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t.left == <span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">return</span> t;<br>  <span class="hljs-keyword">return</span> findMin(t.left);<br>&#125;<br><br><span class="hljs-comment">//Nonrecursive implementation of findMax for binary search trees</span><br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">findMax</span><span class="hljs-params">(BinaryNode t)</span>&#123; <br>  <span class="hljs-keyword">if</span>( t != <span class="hljs-literal">null</span> )&#123;<br>    <span class="hljs-keyword">while</span>( t.right != <span class="hljs-literal">null</span> )&#123;<br>      t = t.right;<br>    &#125;<br>  &#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入">1.3.4. 插入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">insert</span><span class="hljs-params">( Comparable x, BinaryNode t )</span> &#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>) t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryNode</span>( x, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span> );<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo(t.element) &lt; <span class="hljs-number">0</span> ) t.left = insert(x, t.left);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo(t.element) &gt; <span class="hljs-number">0</span>) t.right = insert(x, t.right);<br>  <span class="hljs-keyword">else</span>;<span class="hljs-comment">//duplicate; do nothing</span><br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除">1.3.5. 删除</h5><p>It is necessary to adjust the binary search tree after deleting anelement, so that the tree remained is still a binary search tree.Thereis three cases for deleting node p :</p><ul><li><p>P is a leaf</p></li><li><p>P has exactly one nonempty subtree</p></li><li><p>P has exactly two nonempty subtrees</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Deletion routine for binary search trees</span><br><span class="hljs-keyword">private</span> BinaryNode <span class="hljs-title function_">remove</span><span class="hljs-params">(Comparable x, BinaryNode t)</span>&#123; <br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> t;<br>  <span class="hljs-keyword">if</span>(x.compareTo(t.element) &lt; <span class="hljs-number">0</span>) t.left = remove(x, t.left);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo(t.element) &gt; <span class="hljs-number">0</span>) t.right = remove(x, t.right);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t.left != <span class="hljs-literal">null</span> &amp;&amp; t.right != <span class="hljs-literal">null</span>)&#123; <br>    t.element = findMin(t.right).element;<br>    t.right = remove(t.element, t.right);<br>  &#125;<br>  <span class="hljs-keyword">else</span> t = (t.left != <span class="hljs-literal">null</span>) ? t.left : t.right;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="binary-search-tree-的复杂度">1.4. Binary Search Tree的复杂度</h4><ol type="1"><li>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</li><li>Best Case: <span class="math inline">\(O(\log_2n)\)</span></li><li>Worst Case: <span class="math inline">\(O(n)\)</span></li></ol><h3 id="avl-tree">2. AVL Tree</h3><h4 id="定义">2.1. 定义</h4><ul><li>An AVL Tree is a <strong>Binary Search tree</strong></li><li>Every node satisfies <span class="math inline">\(|h_L -h_R |\leq1\)</span> where <span class="math inline">\(h_L\)</span> and <spanclass="math inline">\(h_R\)</span> are the heights of <spanclass="math inline">\(T_L\)</span> (left subtree) and <spanclass="math inline">\(T_R\)</span> (right subtree), respectively.</li></ul><h4 id="section">2.2.</h4><p>The height of an AVL tree with n elements is O(log2 n), so ann-element AVL search tree can be searched in O(log2 n) time.</p><h4 id="插入-1">2.3. 插入</h4>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Java</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket 入门</title>
    <link href="/2022/11/01/Computer%20Networking/Socket/Java%20Socket%20%E5%85%A5%E9%97%A8/"/>
    <url>/2022/11/01/Computer%20Networking/Socket/Java%20Socket%20%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="socket-入门">Socket 入门</h1><h2 id="什么是socket">1. 什么是Socket</h2><h3 id="socket-的引入">1.1. Socket 的引入</h3><p>​我们知道<strong>进程通信</strong>的方法有<strong>管道、命名管道、信号、消息队列、共享内存、信号量</strong>等等，这些方法都要求通信的两个进程位于同一个主机。如果通信双方不在同一个主机，使用TCP/IP协议族就能达到我们想要的效果。但是，当我们使用不同的协议进行通信时就得使用不同的接口，还得处理不同协议的各种细节，这就增加了开发的难度，软件也不易于扩展。于是<ahref="https://baike.baidu.com/item/BSD/3794498">UNIX BSD</a>就发明了<ahref="https://baike.baidu.com/item/套接字/9637606?fromModule=lemma_search-box&amp;fromtitle=socket&amp;fromid=281150">socket</a></p><h3 id="socket-的位置">1.2. Socket 的位置</h3><p>socket屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。这就好比操作系统给我们提供了使用底层硬件功能的系统调用，通过系统调用我们可以方便的使用磁盘（文件操作），使用内存，而无需自己去进行磁盘读写，内存管理。socket提供了 TCP/IP协议的抽象，对外提供了一套接口，同过这个接口就可以统一、方便的使用tcp/ip协议的功能了。简单来说，Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在<ahref="https://www.runoob.com/design-pattern/design-pattern-tutorial.html"><strong>设计模式</strong></a>中，Socket其实就是一个<ahref="https://zhuanlan.zhihu.com/p/200723695#:~:text=门面模式要求一个,的门面对象进行%E3%80%82"><strong>门面模式</strong></a>，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211011749905.png" alt="图片来源于《tcp/ip协议详解卷一》" style="zoom: 67%;" /></p><h3 id="socket-的定义">1.3. Socket 的定义</h3><p>​ <a href="https://zhuanlan.zhihu.com/p/260139078">socket</a>一词的起源在组网领域的首次使用是在1970年2月12日发布的文献 <strong><ahref="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a></strong>中发现的（第6页），撰写者为 <em>Stephen Carr</em>、<em>SteveCrocker</em> 和 <em>VintCerf</em>。根据美国计算机历史博物馆的记载，<em>Croker</em>写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。（Theelements of the name space are called sockets. A socket forms one end ofa connection, and a connection is fully specified by a pair ofsockets.）”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p><h3 id="socket-的分类">1.4. Socket 的分类</h3><p><strong><ahref="https://baike.baidu.com/item/流套接字/56064558">流套接字</a>(Stream Socket):</strong> 主要用于 <strong>TCP</strong> 协议;提供了<strong>双向的、有序的、无重复的、无记录边界</strong>的数据传输服务。</p><p><strong><ahref="https://blog.csdn.net/L19002S/article/details/103690152">数据报套接字</a>:</strong>主要用于 <strong>UDP</strong> 协议;它提供了<strong>双向的、无序的、有重复的、有记录边界</strong>的数据传输服务。</p><p><strong><ahref="https://blog.csdn.net/chengqiuming/article/details/89577351">原始套接字</a>:</strong>主要用于访问底层协议，如 <strong>IP、ICMP与IGMP</strong> 等协议;原始套接字可以保存 IP 包中的完整 IP 头部。</p><pre><code class=" mermaid">sequenceDiagramTitle: 面向连接的客户/服务器的时序图 Note left of Server: socket() Note left of Server: bind() Note left of Server: listen() Note left of Server: accept() Note right of Client: socket() Note right of Client: connect() Note left of Server: 阻塞：等待用户请求 Client -&gt;&gt; Server: 请求建立连接 Client -&gt;&gt; Server: 数据发送 Note left of Server: recv() Note left of Server: sendto() Server -&gt;&gt; Client: 数据发送 Note right of Client: recv() Note left of Server: close() Note right of Client: close() </code></pre><pre><code class=" mermaid">sequenceDiagramTitle: 面向无连接的客户/服务器的时序图 Note left of Server: socket() Note right of Client: socket() Note left of Server: bind() Note right of Client: bind() Note right of Client: sendto() Client -&gt;&gt; Server: 请求建立连接 Note left of Server: recvfrom() Note left of Server: 阻塞：等待用户请求 Note left of Server: sendto() Server -&gt;&gt; Client: 数据发送 Note right of Client: recvfrom() Note left of Server: close() Note right of Client: close()</code></pre><h2 id="socket-常用函数">2. Socket 常用函数</h2><p>注意这里的函数都是包含在 C 语言 &lt;socket.h&gt; 和 &lt;type.h&gt;头文件中的函数</p><h3 id="socket">2.1. <code>socket()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> protofamily, <span class="hljs-type">int</span> so_type, <span class="hljs-type">int</span> protocol)</span>;<br></code></pre></td></tr></table></figure><ul><li>点击<ahref="https://pubs.opengroup.org/onlinepubs/009619199/socket.htm">这里</a>或者查看<ahref="https://blog.csdn.net/linglongbayinhe/article/details/83214171">这篇文章</a>可以查看详情</li><li>protofamily 指协议族，常见的值有：<ul><li>AF_INET，指定 so_pcb 中的地址要采用 ipv4 地址类型</li><li>AF_INET6，指定 so_pcb 中的地址要采用 ipv6 的地址类型</li><li>AF_LOCAL/AF_UNIX，指定 so_pcb 中的地址要使用绝对路径名</li></ul></li><li>so_type 指定 socket 的类型，常见的值有：<ul><li>SOCK_STREAM（基于 TCP的，数据传输比较有保障）</li><li>SOCK_DGRAM (是基于 UDP 的，专门用于局域网)</li></ul></li><li>protocol 指定具体的协议，常见的值有：<ul><li>IPPROTO_TCP，TCP 协议</li><li>IPPROTO_UDP，UPD 协议</li><li>0，如果指定为0，表示由内核根据so_type指定默认的通信协议</li></ul></li></ul><p>​值得注意的是，socket函数对应于<strong>普通文件的打开操作</strong>。普通文件的打开操作返回一个文件描述字，而<strong>socket()</strong> 用于创建一个 socket 描述符（socketdescriptor），它唯一标识一个 socket。这个 socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind() 函数，否则就当调用 connect() 、listen()时系统会自动随机分配一个端口。</p><h3 id="bind">2.2. <code>bind()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure><ul><li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个 <code>const struct sockaddr *</code>指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。</li><li>addrlen：对应的是地址的长度。</li></ul><h3 id="listen-connect">2.3. <code>listen()</code> &amp;<code>connect()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>; <br></code></pre></td></tr></table></figure><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="accept">2.4. <code>accept()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>; <br></code></pre></td></tr></table></figure><p><code>accept()</code>函数的第一个参数为服务器的socket描述字，第二个参数为指向<code>struct sockaddr *</code>的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果 <code>accpet</code>成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP 连接。 TCP 服务器端依次调用 <code>socket()</code><code>bind()</code> <code>listen()</code> 之后，就会监听指定的 socket地址了。TCP 客户端依次调用 <code>socket()</code> <code>connect()</code>之后就想 TCP 服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用 <code>accept()</code>函数取接收请求，这样连接就建立好了。</p><p>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作.</p><h3 id="read-write">2.5. <code>read()</code> &amp;<code>write()</code></h3><p>网络I/O操作有下面几组： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">read();write();<br><br>recv();send();<br><br>readv();writev();<br><br>recvmsg();sendmsg();<br><br>recvfrom();sendto();<br></code></pre></td></tr></table></figure></p><p>负责相应的数据读写操作</p><h3 id="close">2.6. <code>close()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket 描述字，好比操作完打开的文件要调用 <code>fclose()</code>关闭打开的文件。</p><h2 id="java-socket-常用-api">3. Java Socket 常用 API</h2><h3 id="inetaddress-类-套接字地址域名解析">3.1. INetAddress 类 ——套接字地址/域名解析</h3><ul><li><p>Java使用InetAddress表示IP地址</p><ul><li><p>定义于 <code>java.net</code> 包下</p></li><li><p>既可以表示 IPv4 的地址，也可以表示 IPv6 的地址</p></li></ul></li><li><p>在 Java 的 Socket API 中，往往将一个 <code>InetAddress</code>对象和一个端口号一起使用作为套接字地址</p></li><li><p>通过 <code>InetAddress</code> 的静态方法 <code>getByName()</code>可以将一个IP地址或域名转换为 <code>InetAddress</code> 对象</p><ul><li>当对应域名不存在或无法解析时，会抛出<code>java.net.UnknownHostException</code> 异常，需要对其进行处理</li></ul></li><li><p>举例如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lookup</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123; <br>      <span class="hljs-type">InetAddress</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> InetAddress.getByName(args[<span class="hljs-number">0</span>]);<br>      System.out.println(args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;:&quot;</span> + a.getHostAddress()); <br><br>    &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>      System.out.println(<span class="hljs-string">&quot;No address found for &quot;</span> + args[<span class="hljs-number">0</span>]); <br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//有输出如下</span><br>----------------------------------------<br>&gt; java Lookup software.nju.edu.cn      <br>software.nju.edu.cn:<span class="hljs-number">219.219</span><span class="hljs-number">.120</span><span class="hljs-number">.45</span>     <br>&gt; java Lookup <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>-----------------------------------------<br></code></pre></td></tr></table></figure><h3 id="socketserversocket-类-tcp套接字">3.2. Socket/ServerSocket 类 ——TCP套接字</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211012229523.png" alt="" style="zoom:50%;" /></p><h4 id="socket-1">3.2.1. Socket</h4><p>Socket类表示一个<strong>建立好的TCP连接</strong>，它可以由服务端通过主动连接创建，也可以被ServerSocket 通过 accept 调用创建（称为<strong>主动套接字</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端主动连接</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(InetAddress addr, <span class="hljs-type">int</span> port)<br><span class="hljs-comment">//当目标机器不可达、连接被重置或拒绝等情况时，会抛出java.io.IOException异常</span><br><br>  <br><span class="hljs-comment">//与远程机器通信</span><br>InputStream <span class="hljs-title function_">getInputStream</span><span class="hljs-params">()</span><span class="hljs-comment">//从远程机器读数据</span><br>  <br>OutputStream <span class="hljs-title function_">getOutputStream</span><span class="hljs-params">()</span><span class="hljs-comment">//向远程机器写数据</span><br>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span><span class="hljs-comment">//关闭该套接字连接</span><br></code></pre></td></tr></table></figure><h4 id="serversocket">3.2.2. ServerSocket</h4><p>ServerSocket类表示服务端创建的<strong>等待客户端来连接</strong>的TCP套接字（称为<strong>被动套接字</strong>）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定ServerSocket到本地端口并监听</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-type">int</span> port) <span class="hljs-comment">//backlog=50</span><br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-type">int</span> port, <span class="hljs-type">int</span> backlog)<br>  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-type">int</span> port, <span class="hljs-type">int</span> backlog, InetAddress bindAddr)<br>  <br><span class="hljs-comment">//当绑定失败（譬如端口被占用时）均抛出java.io.IOException</span><br><br><span class="hljs-comment">//通过accept调用获取一个完成三次握手的TCP连接</span><br>Socket <span class="hljs-title function_">accept</span><span class="hljs-params">()</span><br><span class="hljs-comment">//创建时的backlog参数表示允许完成三次握手但没被accept调用获取到的TCP连接个数，超出backlog的连接将会被拒绝</span><br></code></pre></td></tr></table></figure></p><h3 id="inputstreamoutputstream-数据的读取和写出">3.3.InputStream/OutputStream —— 数据的读取和写出</h3><h4 id="inputstream">3.3.1. InputStream</h4><ul><li>InputStream类是 Java 提供的输入流抽象<ul><li>定义于 <code>java.io</code> 包下</li><li>输入流有流终止和传输错误两种情况，而一般而言前者不抛出异常，后者抛出<code>java.io.IOException</code></li><li>通过 <code>read()</code> 方法进行读取</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span><span class="hljs-comment">//从输入流读取单个字节，当读取成功时，返回0-255的整数，当流终止时，返回-1</span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b)</span><span class="hljs-comment">//从输入流读取最多b.length个字节，并返回读取到b的元素的个数，当流终止时，返回-1</span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><span class="hljs-comment">//从输入流读取最多len个字节到b中以b[off]开头的存储空间中，当流终止时，返回-1</span><br></code></pre></td></tr></table></figure><p>通过实现 InputStream 类，可以实现新的输入源，如FileInputStream，ByteBufferInputStream 等</p><p>通过包装 InputStream 类，可以扩充和简化 InputStream的API，如DataInputStream，BufferedInputStream 等</p><p>关于更多的Java IO，可以查看<ahref="https://blog.csdn.net/yczz/article/details/38761237">这篇文章</a></p><h4 id="outputstream">3.3.2 OutputStream</h4><p>OutputStream类为Java提供的输出流抽象</p><ul><li>定义于 <code>java.io</code> 包下</li><li>由于数据流的流终止由调用者决定，因此只存在传输错误一种情况，会抛出<code>java.io.IOException</code> 异常</li><li>通过 <code>write()</code> 方法进行写出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//写出单个字节到输出流，只有低8位有效</span><br>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b)</span><span class="hljs-comment">//将b中b.length个字节写出到输出流</span><br>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)</span><span class="hljs-comment">//将b中b[off]开头的len个字节写出到输出流</span><br><br><span class="hljs-comment">//通过close方法关闭/终止输出流</span><br><span class="hljs-comment">//子类通过重写close方法决定close时的行为</span><br></code></pre></td></tr></table></figure><p>通过实现 OutputStream类，可以实现新的输出源，如FileOutputStream，ByteBufferOutputStream等</p><p>通过包装 OutputStream 类，可以扩充和简化 OutputStream 的API，如DataOutputStream，BufferedOutputStream 等</p><h3 id="datagramsocketdatagrampacket-udp套接字">3.4.DatagramSocket/DatagramPacket —— UDP套接字</h3><h4 id="datagramsocket">3.4.1. DatagramSocket</h4><p>DatagramSocket 类表示一个 <strong>UDP 套接字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定UDP套接字到本地端口</span><br><span class="hljs-comment">//当绑定失败时，均会抛出java.net.SocketException异常</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>()<span class="hljs-comment">//绑定套接字到任意端口</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-type">int</span> port)<span class="hljs-comment">//绑定套接字到指定端口</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-type">int</span> port, InetAddress addr)<span class="hljs-comment">//绑定套接字到指定IP地址和端口</span><br><br><br>close()<span class="hljs-comment">//关闭当前UDP套接字，释放其占用的端口</span><br><br>  <br><span class="hljs-comment">//发送和接收数据报文</span><br>send(DatagramPacket p)<span class="hljs-comment">//发送UDP报文</span><br>receive(DatagramPacket p)<span class="hljs-comment">//接收UDP报文，会一直阻塞接收到报文，或者在设置了超时时间后，抛出java.net.SocketTimeoutException</span><br>setSoTimeout(<span class="hljs-type">int</span> timeout)<span class="hljs-comment">//设置接收UDP报文的超时时间</span><br></code></pre></td></tr></table></figure><h4 id="datagrampacket">3.4.2 DatagramPacket</h4><p>DatagramPacket类<strong>封装</strong>了一个由<strong>UDP套接字传输的数据包</strong>，其中包含：</p><ul><li>一个<strong>缓冲区</strong>：用于存放UDP报文数据</li><li>目标机器的<strong>IP地址</strong>和<strong>端口</strong>：当DatagramSocket的 connect 方法被调用后，DatagramPacket 中的目标 IP和端口将被忽略，直到DatagramSocket 的 disconnect 方法被调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建DatagramPacket的载荷</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-type">byte</span>[] buf, <span class="hljs-type">int</span> len)<span class="hljs-comment">//创建一个用于接收的DatagramPacket类，超出len的UDP数据将被截断</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-type">byte</span>[] buf, <span class="hljs-type">int</span> len)<span class="hljs-comment">//创建一个用于发送的DatagramPacket类</span><br></code></pre></td></tr></table></figure><h2 id="包含-tcpudp-的-socket-使用">4. 包含 TCP/UDP 的 Socket 使用</h2><h3 id="tcp-套接字编程实例">4.1. TCP 套接字编程实例</h3><ul><li>客户端从标准输入流读取一行字符串，并将其写出到服务端</li><li>服务端读取客户端的输入数据，将其转换为大写，并传回给客户端</li><li>客户端从服务端读取数据，并将转换后的字符串输出到标准输出流，回显给用户</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211012331462.png" alt="" style="zoom:50%;" /></p><ul><li>如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Client<br><span class="hljs-keyword">import</span> java.io.*; <br><span class="hljs-keyword">import</span> java.net.*; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClient</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String argv[])</span> <span class="hljs-keyword">throws</span> Exception&#123; <br>    String sentence;<br>    String modifiedSentence; <br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">inFromUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;hostname&quot;</span>, <span class="hljs-number">6789</span>); <br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">outToServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(clientSocket.getOutputStream());<br>   <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">inFromServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(clientSocket.getInputStream())); <br>sentence = inFromUser.readLine(); <br>outToServer.writeBytes(sentence + <span class="hljs-string">&#x27;\n&#x27;</span>); <br>    modifiedSentence = inFromServer.readLine();     <br>    System.out.println(<span class="hljs-string">&quot;FROM SERVER: &quot;</span> + modifiedSentence);   <br>  clientSocket.close();<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Server<br><span class="hljs-keyword">import</span> java.io.*; <br><span class="hljs-keyword">import</span> java.net.*; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServer</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String argv[])</span> <span class="hljs-keyword">throws</span> Exception&#123; <br>      String clientSentence; <br>      String capitalizedSentence; <br>      <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">welcomeSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">6789</span>);<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">connectionSocket</span> <span class="hljs-operator">=</span> welcomeSocket.accept(); <br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">inFromClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(connectionSocket.getInputStream())); <br>        <span class="hljs-type">DataOutputStream</span>  <span class="hljs-variable">outToClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(connectionSocket.getOutputStream()); <br>        clientSentence = inFromClient.readLine(); <br>        capitalizedSentence = clientSentence.toUpperCase() + <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        outToClient.writeBytes(capitalizedSentence);     <br>   &#125; <br>&#125; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="udp-套接字编程实例">4.2. UDP 套接字编程实例</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211012331209.png" alt="" style="zoom:50%;" /></p><ul><li>如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Client<br><span class="hljs-keyword">import</span> java.io.*; <br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPClient</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception&#123; <br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">inFromUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));   <br>    <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(); <br>    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">IPAddress</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;hostname&quot;</span>);  <br>    <span class="hljs-type">byte</span>[] sendData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <br>    <span class="hljs-type">byte</span>[] receiveData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <br>    <span class="hljs-type">String</span> <span class="hljs-variable">sentence</span> <span class="hljs-operator">=</span> inFromUser.readLine(); <br>    sendData = sentence.getBytes(); <br>    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">sendPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(sendData, sendData.length, IPAddress, <span class="hljs-number">9876</span>); <br>    clientSocket.send(sendPacket); <br>    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">receivePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(receiveData, receiveData.length); <br>    clientSocket.receive(receivePacket);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">modifiedSentence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(receivePacket.getData()); <br>    System.out.println(<span class="hljs-string">&quot;FROM SERVER:&quot;</span> + modifiedSentence); <br>    clientSocket.close();  <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Server<br><span class="hljs-keyword">import</span> java.io.*; <br><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception&#123; <br>    <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">9876</span>);<br>    <span class="hljs-type">byte</span>[] receiveData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">byte</span>[] sendData  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;     <br>      <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">receivePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(receiveData, receiveData.length);  <br>      serverSocket.receive(receivePacket);       <br>      <span class="hljs-type">String</span> <span class="hljs-variable">sentence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(receivePacket.getData()); <br>      <span class="hljs-type">InetAddress</span> <span class="hljs-variable">IPAddress</span> <span class="hljs-operator">=</span> receivePacket.getAddress(); <br>      <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> receivePacket.getPort(); <br>      <span class="hljs-type">String</span> <span class="hljs-variable">capitalizedSentence</span> <span class="hljs-operator">=</span> sentence.toUpperCase(); <br>      sendData = capitalizedSentence.getBytes(); <br>      <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">sendPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(sendData, sendData.length, IPAddress, port);<br>      serverSocket.send(sendPacket);   <br>    &#125; <br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="参考文章">5. 参考文章</h2><ol type="1"><li><ahref="https://www.jianshu.com/p/b607f8e302fc">深入理解Socket</a></li><li><ahref="https://blog.csdn.net/linglongbayinhe/article/details/83214171">AF_INET与套接字</a></li><li><a href="https://blog.csdn.net/yczz/article/details/38761237">JavaIO最详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>Socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Network</tag>
      
      <tag>Socket</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction To C++</title>
    <link href="/2022/11/01/C++%20Basic/C++%20Design/Introduction%20To%20C++/"/>
    <url>/2022/11/01/C++%20Basic/C++%20Design/Introduction%20To%20C++/</url>
    
    <content type="html"><![CDATA[<h2 id="编程范式">1. 编程范式</h2><h4 id="bnf巴科斯范式">1.1. BNF：巴科斯范式</h4><p>​描述编程语言的文法，自然语言存在不同程度的二义性。这种模糊、不确定的方式无法精确定义一门程序设计语言。必须设计一种准确无误地描述程序设计语言的语法结构，这种严谨、简洁、易读的形式规则描述的语言结构模型称为文法。该范式由他定义Algol60语言时提出</p><h4 id="常见的编程范式">1.2. 常见的编程范式</h4><ul><li><strong>面向过程</strong>：分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了（命令式思想：即程序员一步步告诉计算机应该做什么）</li><li><strong>面向对象</strong>：把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li><li><strong>函数式</strong><ul><li>函数副作用：当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数</li><li><ahref="https://blog.csdn.net/archimelan/article/details/81940858">函数式编程</a>：为了消除这种副作用的编程方式，告诉计算机要干什么，而不是怎么干</li></ul></li><li><strong>逻辑式</strong>：将人类的知识告诉给机器，然后让机器自己决定计算结果（AI的第二阶段）</li></ul><blockquote><p>进攻式编程：开发阶段主动暴露问题，从而在发布前尽可能多的解决问题</p><p>防御式编程：开发阶段预防可能出现的所有问题，避免错误数据对系统造成影响</p></blockquote><h4 id="创建oo的背景">1.3. 创建OO的背景</h4><p><strong>Simula 1时期</strong></p><p>simulation：仿真，用于模拟某些不能真实做的（炸毁三峡大坝产生的后果）、有较大随机性的实验</p><ul><li>仿真语言为仿真研究人员提供了专门用于建模、仿真实验和仿真结果统计、分析、显示的程序语句</li><li>不可测原理</li><li>仿真语言打破了严格的先进后出制度</li><li>采取的措施类似现在虚拟机的工作</li></ul><p>Simula 1：<strong>不是programlanguage</strong>，仅仅为了完成simulation引入的约束/语言</p><p><strong>Simula 67时期</strong></p><ul><li>考虑到Simula1的不可重用性，提出了class subclassinheriting的思想</li><li>抽象函数的概念</li><li>通用程序设计语言</li><li>有了OO思想</li></ul><h2 id="c-设计">2. C++ 设计</h2><h4 id="c-设计理念">2.1. C++ 设计理念</h4><p>​ 节选自 C++ 语言之父 <em>Bjarne Stroustrup</em> 撰写的 C++发展史三部曲之二 <strong><em>Evolving a language in and for the realworld: C++ 1991-2006</em></strong>。</p><p>During my early years at Bell Labs, these ideals grew into a set of“rules of thumb” for the design of C++.</p><ul><li>General rules:<ul><li><em>C++’s evolution must be driven by realproblems.</em>（C++的演化必须由实际问题驱动）</li><li><em>Don’t get involved in a sterile quest forperfection.</em>（不要受困于对完美的无趣追求）</li><li><em>C++ must be useful now. Every feature must have a reasonablyobviousimplementation.</em>（C++必须<strong>现在</strong>就是实用的，每个特性必须有一种合理程度下显而易见的实现方式）</li><li><em>Always provide a transition path.</em>（总是提供一种过渡路径）（注：这里主要是说从 C 到 C++ 的过渡，例如，<code>std::sort</code>就设计为既可以用在 C++ 的迭代器上，也可以用在 C 的指针上）</li><li><em>C++ is a language, not a completesystem.</em>（C++是一种语言，而不是一个完整的系统）</li><li><em>Provide comprehensive support for each supportedstyle.</em>（为每种风格提供全面的支持） （注：<strong><em>EffectiveC++</em></strong> 一书中 Item 1就有提到：C++可以视为四个子语言的联邦：过程性编程（类似C）、面向对象编程（OOP）、泛型编程（GP）和标准模板库 STL。C++不断推出的新特性也有其主要服务的目标。）</li><li><em>Don’t try to force people to use a specific programmingstyle.</em>（不要试图强迫人们使用某种特定的编程风格）</li></ul></li><li>总结下来，C++的设计理念可以概括为：<ul><li>追求效率</li><li>实用性优先于严谨性和艺术性</li><li>相信程序员</li></ul></li></ul><h4 id="c-历史">2.2. C++ 历史</h4><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs5.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><table><thead><tr class="header"><th>人</th><th>成就</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>Kristen Nygaard</td><td>Simula67</td><td>创建</td></tr><tr class="even"><td>Ole-Johan Dahl</td><td>OO 编程</td><td>创建</td></tr><tr class="odd"><td>Dennis Ritchie、Ken Thompson</td><td>C语言</td><td>创建</td></tr><tr class="even"><td>Bjarne Stroustrup</td><td>C with Classes</td><td>1980形成，并最终发明C++</td></tr><tr class="odd"><td>Rick Mascitti</td><td>C++</td><td>1983正式命名</td></tr><tr class="even"><td>Dijkstr</td><td>结构化编程</td><td>创建</td></tr></tbody></table><h4 id="c-诞生">2.3. C++ 诞生</h4><p>BS最开始为了完成博士论文需要一门语言做支撑</p><p>1.simula：性能差</p><p>最终被市场淘汰：用的人少，无法为复杂的系统提供支持</p><p>2.BCPL：debug难</p><p>此时他还是用原有语言完成了论文，但希望有一门语言能综合Simula编程体验好，BCPL性能高的特点</p><p><strong>贝尔实验室阶段</strong></p><p>C++思想逐步完善</p><ul><li>Cpre：预处理程序，C加上Simula的类的机制</li><li>此后逐渐诞生了创建一门语言的想法</li></ul><p><strong>1983年诞生</strong></p><p>此时C++源码先通过cpp预处理后再通过Cfront翻译成C语言，最后通过C编译器来使程序运行</p><ul><li>用Cfront不用Cpre的原因：Cpre不懂C语法，Cfront懂，发现语法错误会传回sourcecode，但Cpre将方言部分翻译成c后交给cc，此时若发现错误才传回sourcecode</li><li>正交性：矛盾体，有你没我，有我没你。但这些可以容忍，如果共存后效率能提高</li></ul><p><strong>初始化与赋值</strong></p><p>对于复合类型的初始化和赋值有区别，基本类型则没有区别：https://blog.csdn.net/qq_38211852/article/details/80629691</p><p><strong>异常</strong></p><ul><li>可以预见的</li><li>无法避免的（a/b，无法避免输入b=0；无法避免文件路径不存在）</li><li>处理异常不是让异常消失，而是让异常产生后能受到控制，不会让系统手足无措</li></ul><h4 id="c-与-c-的关系">2.4. C 与 C++ 的关系</h4><p>与 C 语言相比：</p><ul><li><p>(代码层面)C++完全包含了C语言成分，支持C支持的全部编程技巧，C是建立C++的基础，同时C++还添加了OOP的完全支持。</p></li><li><p>(运行层面)任何C程序都能被C++用基本相同的方法编写，并具有相同的运行效率和空间。</p></li><li><p>(功能层面)C++还引入了重载、内联函数、异常处理等功能，对C中过程化控制及其功能并扩充。</p></li></ul><h4 id="c-与-c-混合编程">2.5. C 与 C++ 混合编程</h4><ol type="1"><li>名变换: 如果调用C语言库中的函数，则需要附加"extern C",限制C++编译器进行名变换，便于可以连接。</li><li>静态初始化:C静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在main 被执行前就被调⽤，只要可能，⽤ C写 main()，即使要⽤ C 写 Main 也⽤C++写</li><li>内存动态分配: new/delete 调⽤ C++的函数库，malloc/free 调⽤ C 的函数库，⼆者要匹配，防⽌内存泄露;</li><li>数据结构兼容: 将在两种语⾔间传递的东西限制在⽤ C编译的数据结构的范围内; 这些结构的C++版本可以包含⾮虚成员函数，不能有虚函数。</li><li>因为C++ 是 C的超集，且C是结构化编程语⾔，⽽C⽀持⾯向对象编程语⾔，所以在混合编程时，不应当出现class等⾯向对象的关键字</li><li>C语⾔不支持函数重载。在 C++ 中 f(int, int) 与 f(int, double)是不同的函数，都重载了函数f()；但是在C语⾔中却被认为是相同的函数。因为在编译时，C语⾔给这⼏个函数的命名为f_；⽽ C++ 命名分别为 f_int_int, f_int_double,f_，以表⽰区别；所以混合编程时应注意重载函数的问题；</li><li>在 C++中也允许在结构和联合中定义函数，他们也具有类的基本功能，与CLASS所不同的是：结构和联合的成员的默认访问控制为PUBLIC.</li></ol><h2 id="参考文章">3. 参考文章</h2><ol type="1"><li><ahref="https://blog.csdn.net/Altair_alpha/article/details/122497933">C++语言的设计理念</a></li><li><ahref="https://spricoder.github.io/2020/07/01/2020-C-plus-plus-advanced-programming/2020-C-plus-plus-advanced-programming-exam-final/">exam-final</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>C++ Design</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>History</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LAN Switching &amp; VLAN</title>
    <link href="/2022/10/31/Computer%20Networking/OSI%20Model/LAN%20Switching%20&amp;%20VLAN/"/>
    <url>/2022/10/31/Computer%20Networking/OSI%20Model/LAN%20Switching%20&amp;%20VLAN/</url>
    
    <content type="html"><![CDATA[<h1 id="局域网交换和vlan">局域网交换和VLAN</h1><h2 id="交换-switching">1. 交换 (Switching)</h2><h3 id="交换操作">1.1. 交换操作</h3><ul><li>交换机有两个基础功能：<ul><li>基于MAC地址，建立和维持交换表 (与网桥表类似)</li><li>在接口交换帧，发往目的地址</li></ul></li><li>交换操作根据带宽分成两种：<ahref="https://blog.csdn.net/weixin_33922670/article/details/92616641">对称交换和非对称交换</a></li></ul><h3 id="对称交换symmetric-switching">1.2. 对称交换(SymmetricSwitching)</h3><ul><li><p>对称交换提供相同的带宽给端口间的交换连接 (10/10 Mbps或100/100Mbps)</p></li><li><p>当用户试图访问别的网段上的服务器时，可能导致瓶颈</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104764.png"alt="pic112" /><figcaption aria-hidden="true">pic112</figcaption></figure></li></ul><h3 id="非对称交换asymmetric-switching">1.3. 非对称交换(AsymmetricSwitching)</h3><ul><li><p>非对称交换通过用更高带宽(100Mbps)的端口连接服务器的网段，来减少了服务器上潜在的瓶颈</p></li><li><p>非对称交换需要交换机内有存储缓冲区 (which is trivial)</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104776.png"alt="pic113" /><figcaption aria-hidden="true">pic113</figcaption></figure></li></ul><h3 id="存储缓冲区">1.4. 存储缓冲区</h3><ul><li><ahref="https://blog.csdn.net/qq_24373811/article/details/53557728">存储缓冲区</a>是交换机中的存储区域，存有目的地址和传输数据，直到数据被交换的正确的输出端口。交换机常见的通信方式包括<ahref="https://blog.csdn.net/weixin_46291251/article/details/116301250">下面两种</a>：<ul><li><strong>基于端口</strong>存储缓冲（<strong>存储缓冲队列</strong>）<ul><li>每个端口的包被存成了一个队列</li><li>如果是一个繁忙的目标端口，可能会因为一个包拖延其它包的传输</li></ul></li><li>存储缓冲区<strong>共享</strong>（<strong>共享缓冲区</strong>）<ul><li>常见的存储缓冲区是所有端口共享的</li><li>允许包在一个端口是接收端RX，在另一个端口是发送端TX，不需要交换到另一个队列</li></ul></li></ul></li></ul><h3 id="交换方法">1.5. 交换方法</h3><p>交换机常见的交换方法包括<ahref="https://www.cnblogs.com/-D-R-Y-/p/13298879.html">存储转发和直通交换</a></p><ul><li><p><strong>存储转发</strong>(store-and-forward，又叫<strong>报文交换</strong>)</p><ul><li>交换机收到整个帧，在发送到目的地址前，计算末尾<ahref="https://blog.csdn.net/sayhello_world/article/details/72023370">CRC</a></li></ul></li><li><p><strong>直通交换</strong>（cut-through，又叫<strong>切入交换</strong>）</p><ul><li>存储转发会增加延迟，使用切入交换方法可以减少延迟</li><li>这一交换方式又包括两种：<ul><li><strong>快速转发交换</strong>（FastForward）——只检查目标MAC，接着立刻转发帧</li><li><strong>碎片隔离式</strong>（FragmentFree）——读取开头的64字节来减少转发的错误</li></ul></li><li>下图展示了这 2 + 1 种交换方式的大概区别</li></ul><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104784.png"alt="pic114" /><figcaption aria-hidden="true">pic114</figcaption></figure></li></ul><h3 id="交换机">1.6. 交换机</h3><p>在OSI协议中的数据链路层，网络层和传输层都有相应的交换机；同时，也存在集成的多层交换机</p><ul><li><strong>数据链路层</strong>交换机</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104793.png" alt="pic116" style="zoom:50%;" /></p><ul><li><strong>网络层</strong>交换机</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104808.png" alt="pic117" style="zoom:50%;" /></p><ul><li><strong>传输层</strong>交换机</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104909.png" alt="pic118" style="zoom:50%;" /></p><ul><li><strong>多层</strong>交换机</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104014.png" alt="pic119" style="zoom:50%;" /></p><h2 id="生成树协议-the-spanning-tree-protocal-stp">2. 生成树协议 (TheSpanning-Tree Protocal, STP)</h2><p><strong>以太网</strong>的<ahref="https://blog.csdn.net/wong_faye/article/details/106131988"><strong>生成树协议</strong></a>(IEEE802.1D)可以在提高网络<strong>可靠性</strong>的同时避免<ahref="https://blog.csdn.net/wong_faye/article/details/106131988"><strong>网络环路</strong></a>带来的各种问题（如：发送一个帧，全网都能收到）</p><h3 id="桥接环路-bridging-loops">2.1. 桥接环路 (Bridging Loops)</h3><p>环路在网络中产生的原因有很多。通常因为蓄意提供冗余，也可能是配置错误。由以下两个原因导致的网络环路是灾难性的：</p><ul><li>广播循环（Broadcast Loops）</li><li>过时的网桥表（Bridge-Table Corruption）</li></ul><h3 id="冗余线路产生的环路-redundancy-creates-loops">2.2.冗余线路产生的环路 (Redundancy Creates Loops)</h3><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104044.png"alt="pic115" /><figcaption aria-hidden="true">pic115</figcaption></figure><h3 id="泛洪机制与第2层桥接环路">2.3. 泛洪机制与第2层桥接环路</h3><p><a href="https://baike.baidu.com/item/泛洪/10001284">泛洪</a> (广播)和第2层桥接环路同时发生是可怕的事情，因为：</p><ul><li><p><ahref="https://baike.baidu.com/item/以太网帧格式/10290427">以太帧</a>没有<ahref="https://zhuanlan.zhihu.com/p/45449500">TTL域</a> (Time ToLive)</p></li><li><p>在一个以太帧开始循环后，它会一直持续下去，直到有人关掉了其中一个交换机或破坏一条连接线路</p></li><li><p>交换机会触发主机A的网桥表条目 (导致CPU持续高强度被占用)</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104140.png"alt="pic120" /><figcaption aria-hidden="true">pic120</figcaption></figure></li></ul><h3 id="stp-the-spanning-tree-protocal-概览">2.4. STP (The Spanning-TreeProtocal) 概览</h3><p><ahref="https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html">STP</a>的主要作用是，形成一棵无环路的树，解决<ahref="https://baike.baidu.com/item/广播风暴/3574878"><strong>广播风暴</strong></a>问题并实现<ahref="https://baike.baidu.com/item/冗余备份?fromModule=lemma_search-box"><strong>冗余备份</strong></a>。</p><ul><li><p><strong>STP——生成树协议</strong></p><ul><li>主要功能：允许交换机/网桥网络中存在冗余路径，却不会从循环效应中引发延迟</li><li>STP通过计算一个稳定的<strong>生成树网络拓扑</strong>来避免逻辑环路的产生</li><li><strong><ahref="https://blog.csdn.net/weixin_46966890/article/details/126256592">BPDU</a></strong>(<strong>桥接协议数据单元</strong>，Bridge Protocol DataUnit，又叫<strong>生成树帧</strong>)用于决定生成树拓扑（包括成生成树的选举以及重收敛）</li></ul></li><li><p><strong>STP决策序列</strong>——生成树通常使用的4步固定的决策序列来配置最优的BPDU：</p><ul><li><p>最小的 根<strong>BID</strong> (BridgeIdentification，网桥识别符)</p><ul><li>一个网桥ID (BID): 8字节<ul><li>BID高位子域(2字节，十进制表示)：网桥优先级<ul><li>216种可能的值：0-65535 (default：32768)</li></ul></li><li>低位子域(6字节，十六进制表示)：交换机被分配的MAC地址</li></ul></li></ul></li><li><p>最小的 <strong>RPC</strong>（Root Path Cost，根网桥<ahref="https://baike.baidu.com/item/路径开销/2931692">路径开销</a>）</p><ul><li><p>网桥使用<strong>开销</strong>的概念来评估他们与别的网桥之间的<strong>距离</strong></p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104302.png"alt="pic123" /><figcaption aria-hidden="true">pic123</figcaption></figure></li></ul></li><li><p>最小 <strong>BID</strong>（Bridge Identification）</p></li><li><p>最小<strong>PID</strong> （Port Identification）</p></li></ul></li><li><p><strong>BPDU</strong> 的工作原理</p><p>STP建立了一个根节点，叫根网桥，得到的树源自根网桥。在生成树的过程中，不属于最短路径树的冗余链接被阻塞，在阻塞链接上的接收的数据帧被抛弃。最终，符合无回路逻辑拓扑形式的交换机发送的消息即为BPDU</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104183.png"alt="pic121" /><figcaption aria-hidden="true">pic121</figcaption></figure></li><li><p><strong>BPDU</strong> 的物理形式</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311549639.png" alt="pic122" style="zoom:50%;" /></p><ul><li><p>5种<strong>STP</strong>状态</p><ul><li>通过根据规则配置每个端口，来建立状态</li><li>然后STP基于传输模式和潜在的循环，来修改状态</li><li>默认的STP状态命令有：<ul><li>阻塞Blocking——没有帧转发，接收BPDU</li><li>侦听Listening——没有帧转发，侦听数据帧</li><li>学习Learning——没有帧转发，学习地址</li><li>转发Forwarding——有帧转发，学习地址</li><li>禁用Disabled——没有帧转发，不接受BPDU</li></ul></li></ul></li><li><p>举例说明生成树协议的具体选举步骤</p><ul><li><p>最初的STP集合</p><ul><li>当网络刚开始，所有网桥向网络中发送 BPDU 信息</li><li>他们立刻在 BPDU 集合上应用决策队列，来得出整个网络的生成树</li></ul></li><li><p>首先<strong>选举根网桥</strong>来作为网络的中心</p><blockquote><p>通过寻找有着最低BID的交换机，来选择根交换机.</p><p>如果所有交换机使用默认网桥优先级32,768，那么选择MAC地址最低的</p></blockquote><ul><li><p>宣布它自己是根</p></li><li><p>检查端口收到的所有 BPDU 和即将在那个端口发送的 BPDU</p><ul><li><p>对于每一个收到的BPDU，如果比该端口保存的BPDU的值低：则旧的值被取代，同时BPDU的发送方成为新的根</p><p>​<img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104338.png" alt="pic124" style="zoom:67%;" /></p></li></ul></li></ul></li><li><p>接着选择根端口：所有剩余网桥计算根端口的集合</p><ul><li><p>每一个不是根的网桥必须选择一个<strong>根端口</strong>（离根网桥最近的端口，且根路径开销是到达根网桥的所有链接开销的累计）</p><p>​ <imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104373.png"alt="pic125" /></p></li></ul></li><li><p>最后选择指定端口：所有剩余网桥计算指定端口的集合</p><ul><li><p>选择指定端口(I)</p><ul><li>每个网段有一个指定端口<ul><li>用作一个网桥/交换机端口，在这里收发该网段上的通信</li></ul></li><li>包括给定网段的指定端口的网桥/交换机，认为是该网段的指定网桥</li><li>所有网桥/交换机会阻塞它们的非指定端口</li></ul></li><li><p>选择指定端口(II)</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104409.png"alt="pic126" /><figcaption aria-hidden="true">pic126</figcaption></figure></li></ul></li></ul></li><li><p>STP示例</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104450.png"alt="pic127" /><figcaption aria-hidden="true">pic127</figcaption></figure></li></ul><h2 id="vlan">3. VLAN</h2><h3 id="vlan介绍">3.1. VLAN介绍</h3><ul><li>现有的共享局域网配置<ul><li>在传统的局域网中...<ul><li>用户基于他们接入的集线器物理分组</li><li>路由器划分局域网，提供广播防火墙</li></ul></li><li>在 <a href="https://baike.baidu.com/item/VLAN技术/10648597">VLAN</a>中...<ul><li>你可以通过功能、部门或使用的应用来将用户逻辑分组</li><li>配置由专门软件完成</li></ul></li></ul></li></ul><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211011702842.png"alt="pic136" /><figcaption aria-hidden="true">pic136</figcaption></figure><ul><li>VLAN 相对于 LAN 的特点<ul><li>在第数据链路层 &amp; 网络层工作</li><li>能解决冲突域，广播域，带宽等问题</li><li>允许网络管理员分配用户</li><li>提供更安全的网络</li></ul></li><li>VLAN(IEEE 802.1Q)<ul><li>特征<ul><li>不被物理交换网段限制的，一个逻辑上的网络设备或用户的集合</li><li>VLAN中的设备和用户可以根据功能、部门、应用等分组，不论他们物理网段地址是什么</li><li>VLAN构造了一个单独的广播域，不受物理网段限制，就像一个子网</li><li>通过网络管理员使用供应商软件，在交换机中设置VLAN</li></ul></li><li>用户分组<ul><li>VLANs可以逻辑地将用户划分到不同的子网（广播域）</li><li>广播帧只在交换机的端口之间交换，或有着相同VLANID的交换机之间交换</li><li>用户可以基于<em>端口号，MAC地址，使用的协议，应用</em>等通过软件来进行 <strong>逻辑分组</strong></li></ul></li></ul></li></ul><h3 id="vlan体系结构">3.2. VLAN体系结构</h3><ul><li><p>骨干中的VLANs</p><ul><li>VLAN配置需要支持互联路由和交换机之间的数据骨干传输</li><li>骨干是用于内部VLAN通讯的区域</li><li>骨干需要有高速链接，100Mbps或更大</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104530.png"title="fig:" alt="pic137" /></li></ul></li><li><p>VLAN中路由器的角色</p><ul><li>一个路由器提供不同VLAN之间的连接</li><li>比如你有VLAN1和VLAN2.<ul><li>在交换机内，不同VLAN上的用户不能相互对话 (VLAN的好处!)</li><li>然而，如果有路由器，那么VLAN1上的用户可以给VLAN2上的用户发邮件</li></ul></li></ul></li><li><p>VLAN中帧是怎么用的</p><ul><li><p>交换机基于帧里的数据，做过滤和转发决策</p></li><li><p>这里要用两种技术</p><ul><li><p>帧过滤—检查关于每个帧中特定的信息 (MAC地址或第3层协议类型)</p><ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104721.png"title="fig:" alt="pic139" /></li></ul></li><li><p>帧标记—当帧通过网络骨干被转发的时候，在它开头放一个独特的VLAN标识符</p><ul><li><p>帧标记实现过程：</p><ul><li>当帧通过网络骨干被转发的时候，在它开头放一个独特的VLAN标识符</li><li>标识符由每个交换机解读和检查</li><li>当帧退出网络骨干的时候，交换机在帧被发送到目标站点前，移除开头的标识符</li></ul></li><li><p>帧标记在第2层起作用，需要很少提前过程或管理</p></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104753.png"alt="pic140" /><figcaption aria-hidden="true">pic140</figcaption></figure></li><li><p>IEEE802.1Q</p><ul><li>IEEE标准，插入一个VLAN的标签到头部，来标识属于的VLAN (帧标记)。</li></ul></li><li><p>ISL(交换机间链路)</p><ul><li>思科专属。ISL在数据帧前新增一个26字节的头部，在尾部增加4字节CRC</li></ul></li><li><table><thead><tr class="header"><th>名字</th><th>封装</th><th>标签</th><th>媒介</th></tr></thead><tbody><tr class="odd"><td>802.1Q</td><td>No</td><td>Yes</td><td>Ethernet</td></tr><tr class="even"><td>ISL</td><td>Yes</td><td>No</td><td>Ethernet</td></tr></tbody></table></li></ul></li></ul></li></ul><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104779.png"alt="pic138" /><figcaption aria-hidden="true">pic138</figcaption></figure></li></ul><h3 id="vlan实现">3.3. VLAN实现</h3><ul><li>端口，VLANs和广播<ul><li>实现 VLAN 的方法包括 <strong>静态</strong> 和 <strong>动态</strong>两种</li><li>每个交换端口都可以分配一个VLAN这个...<ul><li>保证没有共享同样VLAN的端口，不会共享广播</li><li>保证共享同样VLAN的端口，会共享广播</li></ul></li></ul></li><li>静态VLAN：管理员分配<ul><li>好处<ul><li>安全，容易配置和监控</li><li>因为控制移动，所以在网络中表现好</li></ul></li><li>图例<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104901.png"title="fig:" alt="pic141" /></li></ul></li></ul></li><li>动态VLAN：最初连接在一个没有分配的端口上，交换机检查表中的条目并分配<ul><li>好处<ul><li>当增加或移除用户的时候，管理更少（更提前）</li><li>集中没有被授权的用户的通知</li></ul></li><li>图例<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104011.png"title="fig:" alt="pic142" /></li></ul></li></ul></li><li>以端口为中心的VLAN<ul><li>好处<ul><li>所有在同一个VLAN中的节点都连接到同一个路由器接口</li><li>使得管理更容易，因为……<ul><li>用户由路由器接口分配</li><li>VLANs更容易管理</li><li>更加安全</li><li>包不会泄露到其它域</li></ul></li></ul></li><li>图例<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104042.png"title="fig:" alt="pic143" /></li></ul></li></ul></li><li>访问链路和主干链路<ul><li>图例<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104074.png"title="fig:" alt="pic144" /></li></ul></li><li>访问链路<ul><li>访问链路是交换机上的一个链路，它只是一个VLAN的成员</li><li>这个VLAN被认为是端口的本地native VLAN<ul><li>任何连接到这个端口的设备完全不知道存在这个VLAN</li></ul></li></ul></li><li>主干链路<ul><li>一个主干链路有能力支持多种VLANs.</li><li>主干链路用于连接交换机到其它交换机或者路由器上</li><li>交换机在高速以太网和Gigabit以太网端口上，支持主干链路</li><li>访问和主干链路也存在</li><li>主干是一个点对点链路，支持几种VLAN</li><li>当在两个实现VLAN的设备之间构造链路的时候，主干用于保存端口<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104137.png"title="fig:" alt="pic145" /></li></ul></li><li>主干链路不属于一个特定的VLAN.<ul><li>像路由器和交换机之间的VLANs导管</li></ul></li><li>主干链路可以配置为运输所有VLAN，或运输有限个VLAN</li><li>然而主干链路可能有一个本地native VLAN<ul><li>主干的本地VLAN是，如果主干链路因某些原因失效，这时主干使用的VLAN</li></ul></li></ul></li></ul></li><li>交换机29xx配置<ul><li>当在思科29xx交换机上配置的时候，必须根据下列指导：<ul><li>VLANs的最大个数取决于交换机</li><li>VLAN 1是工厂默认VLAN之一</li><li>VLAN 1 是默认的以太网VLAN.</li><li>思科发现协议(CDP)和虚拟局域网主干协议(VTP) 广告发在VLAN 1上.</li><li>默认Catalyst 29xx IP地址在VLAN 1广播域</li></ul></li></ul></li></ul><h3 id="vlans之间的路由">3.4. VLANs之间的路由</h3><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104178.png"alt="pic146" /><figcaption aria-hidden="true">pic146</figcaption></figure></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104210.png"alt="pic147" /><figcaption aria-hidden="true">pic147</figcaption></figure></li><li><p>子接口</p><ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311104274.png"title="fig:" alt="pic148" /></li></ul></li><li><p>VLAN实验报告见文件</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Application Layer</title>
    <link href="/2022/10/31/Computer%20Networking/OSI%20Model/OSI%20Application%20Layer/"/>
    <url>/2022/10/31/Computer%20Networking/OSI%20Model/OSI%20Application%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次应用层">OSI层次应用层</h1><blockquote><p>注意这里的应用层指的是 OSI 模型中的 Session Layer, Presentation Layerand Application Layer</p></blockquote><h2 id="会话层">1. 会话层</h2><blockquote><p><a href="https://baike.baidu.com/item/会话层/4329656">会话层</a>(SessionLayer)是建立在传输层之上，利用传输层提供的服务，使应用<strong>建立和维持会话，并能使会话获得同步</strong>。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于<strong>传送大的文件</strong>极为重要。</p></blockquote><h3 id="会话层功能">1.1. 会话层功能</h3><blockquote><p>控制应用程序之间会话的建立，管理和终止</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311029158.png" style="zoom:50%;" /></p><h3 id="检查点">1.2. 检查点</h3><blockquote><p>会话层包含了一种称为检查点 (Checkpoint)的机制来维持可靠会话。检查点定义了一个<strong>最接近成功通信</strong>的点，并且定义了当发生内容丢失或损坏时<strong>需要回滚以便恢复丢失或损坏数据的点</strong>，即<strong>断点下载</strong>的原理。</p></blockquote><ul><li><p>检查点用于分离部分会话，过去被称为对话</p></li><li><p>对话分离是有序地初始化、终止和通讯控制</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311029691.png" style="zoom:75%;" /></p><h3 id="会话层的应用">1.3. 会话层的应用</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311029620.png" style="zoom:60%;" /></p><h2 id="展示层">2. 展示层</h2><h3 id="基本功能">2.1. 基本功能</h3><p>负责以接收设备可以理解的方式呈现数据</p><h3 id="主要功能">2.2.主要功能</h3><h4 id="格式化数据">①格式化数据</h4><ul><li>文本文件格式化<ul><li>想象两个不同的系统<ul><li>一个用广义二进制编码的十进制交换码(EBCDIC)格式文本</li><li>另一个用ASCII格式文本</li></ul></li><li>第六层提供不同的两种编码间的翻译</li></ul></li><li>图片文件格式化<ul><li>因特网通常使用两种二进制文件格式来展示图像<ul><li>Graphic Interchange Format (GIF)</li><li>Joint Photographic Experts Group (JPEG)</li></ul></li><li>无论什么类型的电脑，只要有 GIF和JPEG阅读器，都可以查看这些文件格式</li></ul></li><li>多媒体文件格式<ul><li>多媒体文件格式是另一种二进制文件类型，用于存储声音、音乐和音频<ul><li>先将文件全部下载，然后播放；或是边下边放</li><li>后一种方式又被称为流式音频</li></ul></li></ul></li></ul><h4 id="压缩数据">②压缩数据</h4><ul><li>展示层也负责文件压缩</li></ul><h4 id="数据加密">③数据加密</h4><ul><li>数据加密在传输过程中保护信息</li></ul><h2 id="应用层">3. 应用层</h2><h3 id="概述">3.1. 概述</h3><ul><li>应用层(最接近用户) 支持应用的通讯部分</li><li>应用层：<ul><li>识别并建立有意通讯双方的可用性</li><li>同步化合作应用</li><li>建立错误修复流程的协议</li><li>控制数据完整</li></ul></li></ul><h3 id="使用方式">3.2. 使用方式</h3><ul><li>通过使用网络应用（如：www, e-mail, ftp,telnet远程登录），提供一个直接接口给 OSI 模型的剩余部分</li><li>§或者通过使用独立应用程序（如：word processors 文字处理软件,spreadsheets 电子表格, presentation managers 绘图, network redirector网络转发程序），提供一个不直接的接口</li></ul><h3 id="http">3.3. HTTP</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311030794.png" style="zoom:70%;" /></p><ul><li><p>HTTP 是面向事务的客户服务器协议。</p></li><li><p>HTTP 1.0 协议是无状态的(stateless)。</p></li><li><p>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP向上提供的服务。</p></li><li><p>万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP请求的进程常称为 HTTP daemon，有的文献将它缩写为 HTTPD。</p></li><li><p>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP客户。</p></li><li><p>HTTP的报文结构(请求报文)</p><ul><li><p>报文由三个部分组成，即开始行、首部行和实体主体；在请求报文中，开始行就是请求行</p></li><li><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311030908.png" style="zoom:80%;" /></p></li><li><table><thead><tr class="header"><th>方法（操作）</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>OPTION</td><td>请求一些选项的信息</td></tr><tr class="even"><td>GET</td><td>请求读取由URL所标志的信息</td></tr><tr class="odd"><td>HEAD</td><td>请求读取由URL所标志的信息的首部</td></tr><tr class="even"><td>POST</td><td>给服务器添加信息（例如，注释）</td></tr><tr class="odd"><td>PUT</td><td>在指明的URL下存储一个文档</td></tr><tr class="even"><td>DELETE</td><td>删除指明的URL所标志的资源</td></tr><tr class="odd"><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr class="even"><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><p>上表为HTTP请求报文的一些方法</p></li></ul></li></ul><h3 id="url">3.4. URL</h3><blockquote><p>统一资源定位符, Uniform Resource Locator</p></blockquote><ul><li><p><ahref="https://baike.baidu.com/item/统一资源定位系统?fromtitle=url&amp;fromid=110640&amp;fromModule=lemma_search-box">统一资源定位符URL</a>是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示</p></li><li><p>URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</p></li><li><p>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</p></li><li><p>URL 相当于一个文件名在网络范围的扩展。因此 URL是与因特网相连的机器上的任何可访问对象的一个指针。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">URL的访问方式</span>&gt;</span>://<span class="hljs-tag">&lt;<span class="hljs-name">主机</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">端口</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">路径</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="html">3.5. HTML</h3><ul><li>定义了许多用于排版的命令（标签）</li><li>HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。</li><li>仅当 HTML 文档是以.html 或 .htm为后缀时，浏览器才对此文档的各种标签进行解释。</li><li>当浏览器从服务器读取 HTML 文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li><li>HTML用一对标签（一个开始标签和一个结束标签）或几对标签来标识一个元素。</li></ul><h3 id="ftp和tftp">3.6. FTP和TFTP</h3><ul><li>FTP 是使用TCP来传输文件的，可靠的，面向连接的服务<ul><li>FTP 首先建立一个客户端和服务器之间的控制连接(端口 21)</li><li>然后建立第二个连接，连接数据传输要经过的电脑 (端口20)</li></ul></li><li>TFTP 是使用UDP的，不需要连接的服务<ul><li>小且容易实施</li><li>如，TFTP用于路由器来传输配置文件和思科IOS 镜像</li></ul></li></ul><h3 id="telnet远程登录">3.7. Telnet远程登录</h3><ul><li>Telnet客户端软件提供了登录正在运行Telnet服务器应用的远程网络主机的能力，然后执行命令行的命令</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311030166.png" style="zoom:75%;" /></p><h3 id="smtp和pop">3.8. SMTP和POP</h3><ul><li><p>E-mail服务器通过SMTP发送邮件，POP接收邮件，来交互</p><ul><li>SMTP (Simple Mail Transfer Protocol)简单邮件传输协议</li><li>POP3 (Post Office Protocol version 3)第三版电子邮局协议</li></ul></li><li><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311030269.png" style="zoom:80%;" /></p></li><li><p>SMTP只能传ASCII文件</p></li><li></li><li><p>MIME增加的5个新的邮件首部</p><ul><li>MIME-Version: 标志 MIME 的版本。现在的版本号是1.0。若无此行，则为英文文</li><li>Content-Description:这是可读字符串，说明此邮件主体是否是图像、音频或视</li><li>Content-Id: 邮件的惟一标识符</li><li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的</li><li>Content-Type:说明邮件主体的数据类型和子类型</li></ul></li></ul><h3 id="内容传送编码">3.9. 内容传送编码</h3><ul><li>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME对这种由 ASCII 码构成的邮件主体不进行任何转换</li><li>另一种编码称为quoted-printable，这种编码方法适用于当所传送的数据中只有少量的非 ASCII码</li><li>对于任意的二进制文件，可用 base64 编码</li></ul><h3 id="snmp">3.10. SNMP</h3><ul><li>简单网络管理协议(SNMP)是一个用于在网络设备之间管理信息交换的应用层协议</li><li><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311030728.png" style="zoom:80%;" /></li></ul><h3 id="dns域名系统">3.11. DNS域名系统</h3><ul><li>域名系统(DNS)是一个网络服务，负责管理域名，并对客户端的请求做出回应，将域名翻译成相联系的IP地址</li><li>域名<ul><li><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311031491.png" style="zoom:67%;" /></li><li>TLD顶级域名<ul><li>国家 TLD(nTLD)<ul><li>.cn(CHINA), .us (United States), .uk (United kingdom), etc.</li></ul></li><li>通用 TLD(gTLD)，最早的域名包括：<ul><li>.com 企业和公司</li><li>.net 网络服务供应商</li><li>.org 非营利性机构</li><li>.edu 教育设施</li><li>.gov 政府 (only for U.S.A)</li><li>.mil 军事设施(only for U.S.A)</li><li>.int 国际组织</li></ul></li><li>基础结构域名<ul><li>只有一个：arpa，用于解决域名问题</li></ul></li><li>最近，新的TLD域名增加：<ul><li>.aero （航空运输企业）</li><li>.biz （公司和企业）</li><li>.cat （加泰隆人的语言和文化团体）</li><li>.coop （合作团体）</li><li>.info （各种资讯）</li><li>.jobs （人力资源管理者）</li><li>.mobi （移动产品与服务的用户和提供者）</li><li>.museum （博物馆）</li><li>.name （个人）</li><li>.pro （经过认证的专业人员）</li><li>.travel （旅游业）</li></ul></li></ul></li></ul></li><li>域名服务器<ul><li><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311031118.png" style="zoom:80%;" /></li><li>域名服务器系统建立于一个分层结构，创建了不同等级的DNS服务器</li><li>每一层的DNS服务器判断它本身能否把域名翻译成相对应的IP地址：<ul><li>如果它可以这么做，它就翻译，并把结果返回给客户端</li><li>如果不可以，它就向更高层发送请求</li></ul></li><li><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311032222.png" style="zoom:80%;" /></li></ul></li></ul><h3 id="应用层通讯方式">3.12. 应用层：通讯方式</h3><ul><li>通讯处理发生的一种途径：<ul><li>当打开一个浏览器，它连接到了默认页面，这一页的文件被传送到了客户机<br /></li><li>当该流程结束后，连接断开</li></ul></li><li>第二种途径:<ul><li>像Telnet和FTP, 建立连接到服务器，并保持连接直到所有流程被执行</li><li>当用户觉得他已经结束了，客户端断开连接</li></ul></li><li>所有通讯活动都可以归纳到这两种分类之一</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>Application</tag>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Transport Layer</title>
    <link href="/2022/10/31/Computer%20Networking/OSI%20Model/OSI%20Transport%20Layer/"/>
    <url>/2022/10/31/Computer%20Networking/OSI%20Model/OSI%20Transport%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次传输层">OSI层次：传输层</h1><blockquote><p>关键词：可靠性、流控制、 错误校正。</p><p>刻画了终端对终端的连接</p></blockquote><h2 id="传输层概述">1. 传输层概述</h2><h3 id="传输层的功能">1.1. 传输层的功能</h3><ul><li><p><ahref="https://baike.baidu.com/item/传输层/4329536">传输层</a>将上面应用层的数据分段</p></li><li><p>建立终端到终端的操作</p></li><li><p>将<ahref="https://blog.csdn.net/Hongwei_1990/article/details/105942164">报文段</a>(segment) 从一台主机端发送到其它主机</p></li><li><p>流量控制和可靠性</p><ul><li>​可以比作与外国人对话，通常你让外国人重复他的话（可靠性），然后慢慢的说（流量控制）</li></ul></li></ul><h3 id="两个重要的协议">1.2. 两个重要的协议</h3><h4 id="tcp-transmission-control-protocol-传输控制协议">1.2.1. TCP(Transmission Control Protocol, 传输控制协议)</h4><p>​ <a href="https://baike.baidu.com/item/TCP/33012">TCP</a>是一种<strong>面向连接的、可靠的、基于字节流的</strong>传输层通信协议，由<ahref="https://www.bing.com/search?q=IETF&amp;form=APMCS1&amp;PC=APMC">IETF</a>(Internet Engineering Task Force, 因特网工程任务组) 的 <ahref="https://blog.csdn.net/m0_46500807/article/details/113899976">RFC793</a>定义。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。因此我们需要TCP 协议做下面几件事：</p><ul><li><p>提供软件的段检查</p></li><li><p>如果有丢失或者错误，重新发送</p></li><li><p>使用确认</p></li><li><p>提供流量控制</p></li></ul><h4 id="udp-user-datagram-protocal-用户数据包协议">1.2.2. UDP (UserDatagram Protocal, 用户数据包协议)</h4><p>​ <a href="https://baike.baidu.com/item/UDP/571511">UDP</a>是一种<strong>面向无连接、不可靠的、快速传输的</strong>传输层通信协议，由<ahref="https://blog.csdn.net/gtj0617/article/details/118345291?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166744454516782395383961%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166744454516782395383961&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118345291-null-null.142%5Ev62%5Epc_search_tree,201%5Ev3%5Econtrol_2,213%5Ev1%5Econtrol&amp;utm_term=RFC768&amp;spm=1018.2226.3001.4187">RFC768</a>定义。作为Internet传输层的另外一个重要协议，UDP除了<strong>给应用程序发送数据包</strong>并<strong>允许它们在所需的层次上架构自己的协议</strong>之外，几乎没有做什么特别的事情。</p><ul><li>不提供软件检查段</li><li>不使用确认</li><li>不提供流操作</li></ul><h3 id="服务模型">1.3. 服务模型</h3><p>​TCP和UDP都用<strong>端口</strong>来跟踪同一时间穿过网络的不同通讯。应用软件开发商已经同意使用众所周知的，在<ahref="https://blog.csdn.net/an_zhenwei/article/details/38038045">RFC1700</a>中定义的端口号：</p><ul><li>&lt; 255: TCP 和 UDP <strong>公共应用</strong></li><li>256～1023：公共端口</li><li>1024～49151：注册端口</li><li>49152～65535：客户端进程</li></ul><p>值得注意的是，<strong>IP地址 + 特定的端口号 = 制定的进程</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311033989.png" alt="" style="zoom: 67%;" /></p><h3 id="套接字-socket">1.4.套接字 (Socket)</h3><p>​ 关于 <strong>Socket</strong> 更详细的内容可以查看<ahref="https://naturalifica.top/2022/11/01/Computer%20Networking/Socket/Java%20Socket%20入门/">这篇文章</a></p><ul><li><p>套接字表示为（IP地址:端口号）</p></li><li><p>每一个连接表示为(套接字来源, 套接字目的),这是一个点对点的全双工信道</p></li><li><p>TCP 不支持 <ahref="https://blog.csdn.net/u011003120/article/details/103531818">组播(多播) 和广播</a></p></li></ul><h2 id="tcptransmission-control-protocol">2. TCP(Transmission ControlProtocol)</h2><h3 id="tcp中必须解决的问题">2.1. TCP中必须解决的问题</h3><ul><li><p>传输必须是可靠的</p></li><li><p>流量控制</p><ul><li><a href="https://baike.baidu.com/item/滑动窗口协议/10291557">SLP</a>(Sliding Window Protocal, 滑动窗口协议)</li><li><a href="https://baike.baidu.com/item/拥塞避免/20590357">CongestionAvoidance</a> (拥塞避免)</li></ul></li><li><p>连接管理</p><ul><li><p>建立连接：三次握手 (Three Handshakes)</p></li><li><p>结束连接：四次挥手 (Four Handshakes)</p></li></ul></li></ul><h3 id="tcp组成">2.2. TCP组成</h3><blockquote><p>下图是 TCP 报文段的图示</p><p>可以看见，TCP 报文段包括固定的 <strong>20字节长的首部</strong> 和<strong>任意长度的数据段</strong></p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311033890.png" alt="" style="zoom:50%;" /></p><h4 id="tcp-协议">2.2.1. TCP 协议</h4><ul><li><p>主机用段交换数据 (TPDU)</p></li><li><p>每个段有:</p><ul><li><p>20字节的首部 (不包括可选部分)</p></li><li><p>更多数据字节</p></li></ul></li><li><p>段的大小必须和IP 包匹配，也必须满足底层的需求</p><ul><li>如，以太网的MTU(Maximal Transfer Unit最大传输单元) 是1500字节每个字节有一个32位的序号</li></ul></li></ul><h4 id="tcp-报文段的首部">2.2.2. TCP 报文段的首部</h4><ul><li><p><strong>源端口和目的端口</strong>——各占2个字节</p><ul><li><ahref="https://baike.baidu.com/item/端口/103505">端口</a>是<strong>运输层与应用层</strong>的服务接口</li><li>运输层的<strong><ahref="https://baike.baidu.com/item/复用/9857249?fromModule=search-result_lemma">复用</a>和<ahref="https://baike.baidu.com/item/分用?fromModule=lemma_search-box">分用</a></strong>功能都要通过端口才能实现</li></ul></li><li><p><strong>序号</strong>——占4字节</p><ul><li><p>运输层以报文为标识单位，第四层以字节为标识单位</p></li><li><p>TCP传送的数据流中的每一个字节都编上一个序号</p></li><li><p>序号字段的值指本报文所发送的数据的每一个字节的序号</p></li></ul></li><li><p><strong>确认号</strong>——占4字节</p><ul><li>表示期望受到对方的下一个报文段的数据的第一个字节的序号</li></ul></li><li><p><strong>数据偏移</strong>——占4位</p><ul><li>即首部长度</li><li>指出 TCP 报文段的数据起始处距TCP 报文段的起始处的长度</li><li>单位是 32 位字（以 4 字节为计算单位）</li></ul></li><li><p><strong>保留</strong>——占6位</p><ul><li>保留为今后使用，目前置为0</li></ul></li><li><p><strong>URG</strong>——占1位</p><ul><li><p>紧急URG = 1时，表明紧急指针字段有效</p></li><li><p>告诉系统此报文字段中有紧急数据，应尽快传送(相当于高优先级的数据)</p></li></ul></li><li><p><strong>ACK</strong>——占1位</p><ul><li>ACK = 1时确认号字段有效</li><li>ACK = 0时确认号字段无效</li></ul></li><li><p><strong>PSH</strong>——占1位</p><ul><li>推送PSH(PuSH)—— 接收TCP收到PSH =1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</li></ul></li><li><p><strong>RST</strong>——占1位</p><ul><li>复位 RST(ReSeT) = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接</li></ul></li><li><p><strong>SYN</strong>——占1位</p><ul><li>同步 SYN = 1表示这是一个连接请求或连接接受报文</li></ul></li><li><p><strong>FIN</strong>——占1位</p><ul><li>终止 FIN(FINis)—— 用来释放一个连接。FIN = 1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</li></ul></li><li><p><strong>窗口</strong>——占2字节</p><ul><li>用来让对方设置发送窗口的依据，单位为字节</li></ul></li><li><p><strong>校验和</strong>——占2字节</p><ul><li>检验和字段检验的范围包括首部和数据这两部分</li></ul></li><li><p><strong>紧急指针</strong>——占2字节</p><ul><li>指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li></ul></li><li><p><strong>选项</strong></p><ul><li><p>TCP 最初只有一种选项，即最大报文段长度 MSS (Maximum SegmentSize)</p></li><li><p>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS个字节</p></li><li><p>数据字段加上 TCP 首部才等于整个的 TCP 报文段</p></li></ul></li><li><p><strong>填充字段</strong>：为了使整个首部长度是4字节的整数倍</p></li></ul><h3 id="tcp过程">2.4. TCP过程</h3><h4 id="建立连接">2.4.1. 建立连接</h4><blockquote><p>值得注意的是，无论确认多少次，在逻辑上都没办法确认对方已经和自己建立了可靠的连接（如下图的<a href="https://zhuanlan.zhihu.com/p/51936795">two-army-problem,两军悖论</a> ）</p><p>但是我们愿意相信网络的连接不至于糟糕到这样的程度()</p><p>因此三次握手被认为是已经足够了</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211031442601.png" alt="Two-Army-Problem" style="zoom: 33%;" /></p><h5 id="第一次握手">第一次握手</h5><p><strong>服务器</strong>: 执行最初的 LISTEN 和ACCEPT，被动地开始监听</p><p><strong>客户端</strong>: 执行最初的CONNECT, 产生一个 SYN = 1 和 ACK =0 的TCP段，代表连接请求</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034942.png" alt="" style="zoom:67%;" /></p><h5 id="第二次握手">第二次握手</h5><p><strong>服务器</strong>：检查是否存在服务进程在监听端口。</p><ul><li>如果没有进程，返回一个 RST = 1 的TCP段</li><li>如果存在进程，决定拒绝或接受请求<ul><li>如果接受连接请求，发送一个 SYN = 1、ACK = 1 的段</li></ul></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034569.png" alt="" style="zoom:67%;" /></p><h5 id="第三次握手">第三次握手</h5><p><strong>客户端</strong>：发送一个 SYN = 0 和 ACK = 1的段来确认连接</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034242.png" alt="" style="zoom:67%;" /></p><p><strong>当服务器收到确认，它通知上层应用</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034132.png" alt="" style="zoom:67%;" /></p><h4 id="数据传输">2.4.2. 数据传输</h4><h5 id="停止等待协议-stop-and-wait-protocal">停止等待协议 (Stop-and-WaitProtocal)</h5><p><ahref="https://baike.baidu.com/item/停止等待协议/10290586">停止等待协议</a>最简单但也是最基础的<ahref="https://baike.baidu.com/item/数据链路层/4329290?fromModule=lemma_inlink">数据链路层</a>协议。很多有关协议的基本概念都可以从这个协议中学习到</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034504.png" alt="" style="zoom: 67%;" /></p><ul><li><p>发送一个段之后，暂时地保留一个备份</p></li><li><p>每个段和ACK必须有ID</p></li><li><p>重发时间一定大于<strong>平均运输时间</strong>的两倍(否则将陷入永无止境的重新发送)</p></li><li><p>停止和等待协议是一个简单 (但很低效) 的协议</p></li></ul><h5 id="确认丢失和确认迟到">确认丢失和确认迟到</h5><blockquote><p>You are late！</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311034118.png" alt="" style="zoom:67%;" /></p><h4 id="可靠的通讯">2.4.3. 可靠的通讯</h4><h5 id="arq-automatic-repeat-request自动重新发送请求">ARQ (AutomaticRepeat reQuest，自动重新发送请求)</h5><p><ahref="https://baike.baidu.com/item/自动重传请求/2084571?fromModule=lemma_inlink">ARQ</a>是OSI模型中<ahref="https://baike.baidu.com/item/数据链路层/4329290?fromModule=lemma_inlink">数据链路层</a>的错误纠正协议之一。重新发送的请求是<strong>自动发送</strong>的，接受者不需要请求重新发送错误的信息。ARQ包括<strong>停止等待 (Stop-and-Wait) 式ARQ</strong>，<strong>回退n帧（go-back-n）ARQ</strong>，以及<strong>选择性重传（selectiverepeat）ARQ</strong>。后两种协议是<ahref="https://baike.baidu.com/item/滑动窗口?fromModule=lemma_inlink">滑动窗口</a>技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为<ahref="https://baike.baidu.com/item/连续ARQ协议?fromModule=lemma_inlink">连续ARQ协议</a>。</p><h5id="tcp使用可变大小的连续arq协议-可变大小的滑动窗口协议">TCP使用可变大小的连续ARQ协议(可变大小的滑动窗口协议)</h5><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035976.png" alt="" style="zoom:67%;" /></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035218.png" alt="" style="zoom:67%;" /></p><ul><li><p><strong>发送端</strong>要发送900字节长的数据，划分为9个100字节长的报文段，而<strong>发送窗口</strong>确定为500字节</p></li><li><p><strong>发送端</strong>只要收到了对方的确认，发送窗口就可前移</p></li><li><p>发送TCP要维护一个指针，每发送一个报文段，指针就向前移动一个报文段的距离</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035826.png" alt="" style="zoom:67%;" /></p><ul><li><p><strong>发送端</strong>已发送了400字节的数据，但只收到对前200字节数据的确认，同时<strong>窗口大小不变</strong></p></li><li><p>现在<strong>发送端</strong>还可以发送300字节</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035389.png" alt="" style="zoom:67%;" /></p><p>一个例子：利用<strong>可变窗口大小</strong>进行流量控制，双方确定的窗口值是400</p><table><thead><tr class="header"><th style="text-align: center;">主机A</th><th style="text-align: center;">主机B</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">SEQ = 1</td><td style="text-align: center;">A现在还能发送300字节</td></tr><tr class="even"><td style="text-align: center;">SEQ = 101</td><td style="text-align: center;">A现在还能发送200字节</td></tr><tr class="odd"><td style="text-align: center;">SEQ = 201</td><td style="text-align: center;">此时发生丢失</td></tr><tr class="even"><td style="text-align: center;">允许A再发送300字节 (序号201至500)</td><td style="text-align: center;">ACK = 201，WIN = 300</td></tr><tr class="odd"><td style="text-align: center;">SEQ = 301</td><td style="text-align: center;">A还能发送200字节(序号301至500)</td></tr><tr class="even"><td style="text-align: center;">SEQ = 401</td><td style="text-align: center;">A还能发送100字节(序号401至500)</td></tr><tr class="odd"><td style="text-align: center;">SEQ = 201</td><tdstyle="text-align: center;">A超时重发，但不能发送序号500以后的数据</td></tr><tr class="even"><td style="text-align: center;">允许A再发送100字节(序号501至600)</td><td style="text-align: center;">ACK = 501, WIN = 100</td></tr><tr class="odd"><td style="text-align: center;">SEQ = 501</td><td style="text-align: center;">A已把发送窗口用完(序号501至600)</td></tr><tr class="even"><tdstyle="text-align: center;">不允许A再发送(到序号600的数据都已收到)</td><td style="text-align: center;">ACK = 601, WIN = 0</td></tr></tbody></table><h4 id="tcp释放连接">2.4.4. TCP：释放连接</h4><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035466.png" alt="" style="zoom:67%;" /></p><blockquote><p><em>MSL</em> (Maximum Segment Lifetime) 报文最长存活时间</p></blockquote><p><strong>为什么一定要等2MSL？</strong></p><p>保证A发送的最后一条确认可以到达B</p><p>防止出现任何无效的连接请求段 (在等待2MSL之后，我们可以保证连接上的所有段都已经消失)</p><h3 id="tcp的有限状态机">2.5. TCP的<ahref="https://zhuanlan.zhihu.com/p/461094908">有限状态机</a></h3><p><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035310.png" /></p><h2 id="udpuser-datagram-protocol">3.UDP(User Datagram Protocol)</h2><h3 id="udp概述">3.1. UDP概述</h3><h4 id="为什么使用udp">3.1.1. 为什么使用UDP</h4><ul><li><p>不需要建立连接 (建立连接会增加时间延迟)</p></li><li><p>简单: 尽最大努力交付</p><ul><li><p>面向报文，首部开销小</p></li><li><p>没有拥塞控制: UDP 可以尽可能快的传输，无视拥堵</p></li></ul></li></ul><h4 id="udp的特点">3.1.2. UDP的特点</h4><ul><li><p>无连接:</p><ul><li><p>UDP的发送方和接收方不需要握手</p></li><li><p>每个UDP段独立处理</p></li></ul></li><li><p>通常被用于<strong><ahref="https://baike.baidu.com/item/流媒体应用/17608943">流多媒体应用</a>(Streaming Application)</strong></p><ul><li><p>容忍包丢失</p></li><li><p>对速率敏感</p></li></ul></li><li><p>UDP 使用于:</p><ul><li><strong>RIP</strong> (<ahref="https://baike.baidu.com/item/路由信息协议/2707187?fromModule=lemma_search-box&amp;fromtitle=RIP&amp;fromid=571852">RoutingInformation Protocal</a>, 路由信息协议) : 为了周期性发送路由信息</li><li><strong>DNS</strong> (<ahref="https://baike.baidu.com/item/域名系统/2251573?fromtitle=DNS&amp;fromid=427444&amp;fr=aladdin">DomainName System</a>, 域名管理系统) :避免开始TCP连接时的延迟（但实际上，DNS也有使用TCP的时候，更详细的内容可以查看<ahref="https://cloud.tencent.com/developer/article/1818152">这篇文章</a>）</li><li><strong>SNMP</strong> (<ahref="https://baike.baidu.com/item/简单网络管理协议/2986113">SimpleNetwork Manage Protocal</a>, 简单网络管理协议) :当堵塞时，SNMP必须仍然可运行。没有拥堵和可靠的控制机制时，UDP比TCP表现得更好</li><li>其它协议包括<strong>TFTP</strong> (<ahref="https://baike.baidu.com/item/TFTP/455170">Trivial File TransferProtocal</a>, 简单文件传输协议) , <strong>DHCP</strong> (<ahref="https://baike.baidu.com/item/DHCP?fromModule=lemma_search-box">DynamicHost Configuration Protocol</a>, 动态主机配置协议)</li></ul></li><li><p>如果必要，在应用层再增加可靠性</p></li></ul><h4 id="udp格式">3.1.3. UDP格式</h4><blockquote><p>UDP 报文包括 8个字节的header 和 可变长度的数据部分</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311035929.png" alt="" style="zoom:50%;" /></p><h2 id="应用nat和pat">4. 应用：NAT和PAT</h2><h3 id="nat">4.1. NAT</h3><h4 id="概念">4.1.1. 概念</h4><p><ahref="https://baike.baidu.com/item/nat/320024"><strong>NAT</strong></a>(Network Address Translation, 网络地址转换) 由<ahref="https://www.rfc-editor.org/info/rfc1631">RFC1631</a>定义，指的是在IP包首部，用一个地址换另一个地址的过程</p><p>实际上，NAT用来允许<strong>被分配私有地址</strong>的主机访问因特网</p><blockquote><p>不得不再提到 IP地址分配的问题，如何解决？</p><ul><li><p>保留注册地址</p></li><li><p>当连接因特网时，增加灵活性</p></li></ul></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036418.png" alt="" style="zoom:67%;" /></p><h4 id="nat类型">4.1.2. NAT类型</h4><ul><li><strong>static NAT</strong> (<ahref="https://blog.csdn.net/weixin_42442713/article/details/80909546">静态NAT</a>):将内部网络的私有IP地址转换为公有IP地址，IP地址对是<strong>双射</strong>，且是一成不变的</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036795.png" alt="" style="zoom:67%;" /></p><ul><li><strong>pooled NAT</strong> (<ahref="https://baike.baidu.com/item/动态NAT/963527">NAT池</a>):映射基于<strong>先到先服务</strong>动态完成</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036870.png" alt="" style="zoom: 67%;" /></p><ul><li><strong>NAPT</strong> (Network Address Port Translation,网络地址端口转换) 或者叫<strong>PAT</strong> (<ahref="https://baike.baidu.com/item/pat/3726803">Port AddressTranslation</a>, 端口多路复用):用于允许多个因特网用户分享一个单独的内部全局地址（是这三种中最普遍使用的）</li></ul><h4 id="nat地址类型">4.1.3. NAT地址类型</h4><blockquote><p><ahref="https://blog.csdn.net/fjt19900921/article/details/8175996">这篇文章</a>讲得非常生动，<ahref="https://zhuanlan.zhihu.com/p/477147801">另外一篇文章</a>讲得非常具体</p><p>“local 、global是相对于端口状态说的，local是inside部分可以被路由的，global是outside部分可以被路由的。”</p></blockquote><p><strong>Inside Local address (内部本地地址)</strong>: 内网IP地址</p><p><strong>Inside Global address (内部全局地址)</strong>: 注册IP地址,对外部展示的内部地址</p><p><strong>Outside Global address (外部全局地址)</strong>:由主机所有者分配的IP地址。通常是注册地址</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036263.png" alt="" style="zoom:67%;" /></p><h4 id="nat的优点和缺点">4.1.4. NAT的优点和缺点</h4><p>优点：因为不是每一个内部主机都需要同一时间访问外部，你可以用<strong>一小部分全局独一无二的地址</strong>来服务<strong>相对大量的私有地址的主机</strong></p><p>缺点：一对一映射（如果私有地址空间是a/8，但是公共地址是a/24，同时只能有254台主机访问因特网）</p><h3 id="pat">4.2. PAT</h3><h4 id="pat如何工作">4.2.1. PAT如何工作</h4><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036592.png" alt="" style="zoom:67%;" /></p><h4 id="pat操作">4.2.2. PAT操作</h4><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311036265.png" alt="" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标检测问题概述</title>
    <link href="/2022/10/29/Computer%20Vision/Object%20Detection/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/10/29/Computer%20Vision/Object%20Detection/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="目标检测问题">1. 目标检测问题</h4><ol type="1"><li>目标检测 (Object Deteciton)问题是计算机视觉的一个子方向，是在图片中对<strong>可变数量</strong>的目标进行查找和分类，主要包括三个难点</li></ol><ul><li>目标种类和数量问题</li><li>目标尺度问题</li><li>外在环境干扰问题</li></ul><ol start="2" type="1"><li>一些类似的子方向</li></ol><ul><li>Image Classification：将图像中的元素分类</li><li>Semantic Segmentation：将图像中同一类的元素归类</li><li>Instance Segmentation：将图像中每一个元素分类</li><li>Object Detection（Object Localization）：将图像中的元素确定位置</li></ul><h4 id="目标检测方法">2. 目标检测方法</h4><h5 id="目标检测方法的演变">2.1. 目标检测方法的演变</h5><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210292300935.png" alt="image-20221029213051893" style="zoom:67%;" /></p><h5 id="目标提取方法算法的基本流程">2.2. 目标提取方法算法的基本流程</h5><pre><code class=" mermaid">graph LR输入--&gt;候选框--&gt;特征提取--&gt;分类器判定目标&amp;背景--&gt;NMS--&gt;输出输入----&gt;特征提取+直接回归---&gt;NMS</code></pre><p>其中，<ahref="https://blog.csdn.net/shuzfan/article/details/52711706"><strong>NMS</strong></a>(<strong>non maximum suppression, 非极大值抑制</strong>)是一种抑制非极大值元素而搜索产生极大值的算法</p><h5 id="传统的主流目标检测方法">2.3. 传统的主流目标检测方法</h5><ul><li>Viola-Jones</li><li>HOG + SVM</li><li>DPM（目前非深度学习方法中性能最优的方法，但相对于深度学习还是有较大差距）</li></ul><h5 id="基于深度学习的主流目标检测方法">2.4.基于深度学习的主流目标检测方法</h5><ul><li>One-Stage (YOLO &amp; SSD series)</li><li>Two-Stage (Faster RCNN series)</li></ul><h4 id="深度神经网络">3. 深度神经网络</h4><h5 id="rnn-网络">3.1. RNN 网络</h5><h5 id="cnn-网络">3.2. CNN 网络</h5><h5 id="回归网络">3.3. 回归网络</h5>]]></content>
    
    
    <categories>
      
      <category>Computer Vision</category>
      
      <category>Object Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Object Deteciton</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/29/Computer%20Vision/YOLO/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
    <url>/2022/10/29/Computer%20Vision/YOLO/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/29/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <url>/2022/10/29/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第十一章 信息与熵</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%86%B5/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%86%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="第十一章-信息与熵">第十一章 信息与熵</h2><h3 id="信息熵">11.1 信息熵</h3><h4 id="信息与熵">11.1.1信息与熵</h4><p>奈奎斯特，哈特利和香农研究了一类特殊的通信，即技术系统里的通信，他们假设通信的唯一目的是在接受后重新产生输出数据样式——即，信息是为了消除不确定性。香农给出的定义是，当我破门收到一条消息<span class="math inline">\(m\)</span> 时，假设最初有 <spanclass="math inline">\(n\)</span> 个事件 <spanclass="math inline">\(E_1,E_2,…,E_n\)</span> 是等可能的，<spanclass="math inline">\(E\)</span>表示他们当中的一个，这些事件有对应的概率 <spanclass="math inline">\(p_1,p_2,…,p_n\)</span>，那么消息 <spanclass="math inline">\(m\)</span> 的熵为 <span class="math display">\[H(m) = H(p_1,p_2,…,p_n)=-\sum_{i=1}^np_i\log_2p_i\]</span> 其中，对数的底是随机的，如果以 <spanclass="math inline">\(2\)</span> 为底，则单位为 <spanclass="math inline">\(bit\)</span>，如果以自然对数的底数 <spanclass="math inline">\(e\)</span> 为底，则单位为 <spanclass="math inline">\(nat\)</span></p><h4 id="信息熵性质">11.1.2 信息熵性质</h4><p>香农描述了信息度量的三个性质：单调性，非负性和可加性</p><p>​ &lt;1&gt; 单调性：非确定性越高的事件，其信息量越高</p><p>​ &lt;2&gt; 非负性：信息是非负的，可以看作是概率延伸的必然</p><p>​ &lt;3&gt;可加性：总信息量可拆解为各部分的信息量累加，这是广度量的一种表现</p><p>​香农从数学上证明了满足上述三个条件的随机变量不确定性度量函数具有唯一形式：<span class="math display">\[H(X)=-C\sum_{x\in X}p(x)\log x\]</span> 其中 <span class="math inline">\(C\)</span>为常数，我们不妨归一化，令 <span class="math inline">\(C = 1\)</span>就得到了信息熵公式</p><h3 id="信息熵计算">11.2 信息熵计算</h3><h4 id="联合熵">11.2.1 联合熵</h4><p>联合熵是一个集合中变量之间不确定性的衡量手段</p><h5 id="定义-11.1联合熵">定义 11.1：联合熵</h5><p>对于俩个和离散的随机变量 <spanclass="math inline">\(X,Y\)</span>，联合熵的定义为： <spanclass="math display">\[H(X,Y)=-\sum_x\sum_yp(x,y)\log_2P(x,y)\]</span> 其中 <span class="math inline">\(x,y\)</span> 是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的特定值，相应地，<spanclass="math inline">\(P(x,y)\)</span> 是这些值一起出现的联合概率。如果<span class="math inline">\(P(x,y) = 0\)</span>，则定义 <spanclass="math display">\[P(x,y)\log_2p(x,y)\]</span> 对于两个以上的随机变量 <spanclass="math inline">\(X_1,X_2,…,X_n\)</span>，联合熵的定义为： <spanclass="math display">\[H(X_1,X_2,…,X_n)=-\sum_{x_1}\sum_{x_2}…\sum_{x_n}p(x_1,x_2,…,x_n)\log_2p(x_1,x_2…,x_n)\]</span></p><h5 id="section"></h5><h5 id="联合熵的常用性质">联合熵的常用性质</h5><p><span class="math display">\[\max_{X_i\in X}\{H(X_i)\}\leq H(X)\leq \sum_{i=1}^nH(X_i)\\X=\{X_1,X_2,…,X_n\}\]</span></p><h4 id="条件熵">11.2.2 条件熵</h4><p>条件熵量化了在一直一个随机变量 <span class="math inline">\(X\)</span>的条件下，描述为值得随机变量 <span class="math inline">\(Y\)</span>所需的信息量。基于 <span class="math inline">\(X\)</span> 条件下 <spanclass="math inline">\(Y\)</span> 的信息熵，用 <spanclass="math inline">\(H(Y|X)\)</span> 表示，也就是 <spanclass="math inline">\(H(Y|X=x)\)</span> 在 <spanclass="math inline">\(X\)</span> 取遍所有可能的 <spanclass="math inline">\(x\)</span> 之后平均的结果。</p><p>设给定随机变量 <span class="math inline">\(X,Y\)</span>，我们有：<span class="math display">\[\begin{equation*}\begin{split}H(Y|X)&amp;=-\sum_xp(x)H(Y|X=x)\\&amp;=\sum_x-p(x)\sum_yp(y|x)\log p(y|x)\\&amp;=-\sum_{x,y}p(x,y)\log\frac{p(x,y)}{p(x)}\end{split}\end{equation*}\]</span></p><h5 id="条件熵的常用性质">条件熵的常用性质</h5><p>​ &lt;1&gt; 条件熵 <span class="math inline">\(H(Y|X)\)</span>完全等于 <span class="math inline">\(0\)</span> 当且仅当 <spanclass="math inline">\(Y\)</span> 的值完全取决于 <spanclass="math inline">\(X\)</span></p><p>​ &lt;2&gt; 条件熵 <span class="math inline">\(H(Y|X)=H(X)\)</span>当且仅当 <span class="math inline">\(Y\)</span> 和 <spanclass="math inline">\(X\)</span> 相互独立</p><p>​ &lt;3&gt; 条件熵链式法则： <span class="math display">\[H(Y|X)=H(XY)-H(X)\]</span> ​ &lt;4&gt; 条件熵的 <span class="math inline">\(Bayes\)</span>规则 <span class="math display">\[H(Y|X)+H(X)=H(X|Y)+H(Y)\]</span></p><h4 id="相对熵">11.2.3 相对熵</h4><h5 id="定义-11.2相对熵">定义 11.2：相对熵</h5><p>相对熵（Relative Entropy）又称为 <spanclass="math inline">\(KL\)</span> 散度（<spanclass="math inline">\(Kullback-Leibler\ Divergence\)</span>），简称为<span class="math inline">\(KLD\)</span> 或 信息散度，信息增益。设 <spanclass="math inline">\(P(x),Q(X)\)</span> 为随机变量 <spanclass="math inline">\(X\)</span>上的两个概率分布，相对熵的定义为如下</p><p>对于离散型随机变量： <span class="math display">\[D_{KL}(P||Q)=-\sum_{i}P(i)\ln\frac{Q(i)}{P(i)}\]</span></p><p>对于连续型随机变量： <span class="math display">\[D_{KL}(P||Q)=\int_{-\infty}^{+\infty}p(x)\ln\frac{p(x)}{q(x)}\]</span> <span class="math inline">\(KL\)</span> 散度是两个概率分布<span class="math inline">\(P\)</span> 和 <spanclass="math inline">\(Q\)</span> 的非对称性的度量，可以用来度量基于<span class="math inline">\(Q\)</span> 的编码来编码来自 <spanclass="math inline">\(P\)</span> 的样本所需要的额外的位元数。</p><h5 id="相对熵的基本性质">相对熵的基本性质</h5><p>​ &lt;1&gt; 非负性：由于对数函数是上凸函数，所以根据相对熵的定义，有(吉布斯不等式) <span class="math display">\[\begin{equation*}\begin{split}D_{KL}(P||Q)&amp;=\sum_{x\in X}\log\frac{P(x)}{Q(x)}\\&amp;=-E\bigg[\log\frac{Q(x)}{P(x)}\bigg]\\&amp;\geq -\log E(\frac{Q(x)}{P(x)})\\&amp;=-\log\sum_{x\in X}P(x)\frac{Q(x)}{P(x)}\\&amp;=-\log \bigg[\sum_{x\in X}Q(x)\bigg]\\&amp;=0\end{split}\end{equation*}\]</span> ​ &lt;2&gt;不对称性：相对熵是两个概率分布的不对称性的度量，即： <spanclass="math display">\[D_{KL}(P||Q)\not =D_{KL}(Q||P)\]</span> ​ 我们常使用熵的均值来进行规约: <span class="math display">\[let\ D(P,Q)=\frac{[D_{KL}(P||Q)+D_{KL}(Q||P)]}{2}\]</span></p><h4 id="交叉熵">11.2.4 交叉熵</h4><h5 id="交叉熵的定义">交叉熵的定义</h5><p>在信息论中，基于相同事件测度的两个概率分布 <spanclass="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span>的交叉熵指的是，当基于一个“非自然”（相对于“真实的”分布 <spanclass="math inline">\(p\)</span> 而言）的概率分布 <spanclass="math inline">\(q\)</span>进行编码时，在事件集合中唯一地标识一个事件所需的平均 <spanclass="math inline">\(bit\)</span> 数，基于概率分布 <spanclass="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span> 的交叉熵定义为： <spanclass="math display">\[H(p,q)=-\int_{X}p(x)\log q(x)dr(x)=E_P(-\log q)=H(p)+D_{KL}(p||q)\]</span></p><h5 id="交叉熵的基本性质">交叉熵的基本性质</h5><p>​ &lt;1&gt; 不对称性： <span class="math display">\[H(A,B)\not =H(B,A)\]</span></p><h3 id="信息变化">11.3 信息变化</h3><h4 id="互信息">11.3.1 互信息</h4><h5 id="定义-11.3互信息mutual-information">定义 11.3：互信息（MutualInformation）</h5><p>对两个离散随机事件集 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>，事件 <spanclass="math inline">\(y_i\)</span> 的出现给出关于 <spanclass="math inline">\(x_i\)</span> 的信息量，即为互信息量。</p><p>两个离散随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的互信息定义为： <spanclass="math display">\[I(X;Y):=\sum_{x\in X}\sum_{y\inY}p(x,y)\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)\]</span> 两个连续随机变量 <span class="math inline">\(X\)</span> 和<span class="math inline">\(Y\)</span> 的互信息定义为： <spanclass="math display">\[I(X;Y):=\int_X\int_Yp(x,y)\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)dxdy\]</span> 其中 <span class="math inline">\(p(x,y)\)</span> 是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的联合密度函数，<spanclass="math inline">\(p(x),p(y)\)</span> 分别是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的边缘概率密度函数</p><h5 id="互信息的基本性质">互信息的基本性质</h5><p>​ &lt;1&gt; 如果 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 互相独立，则显然地： <spanclass="math display">\[\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)=0\]</span> ​ 也即他们的互信息为 <span class="math inline">\(0\)</span></p><p>​ &lt;2&gt; 互信息是非负的</p><p>​ &lt;3&gt; 互信息是对称的： <span class="math display">\[I(X;Y)=I(Y;X)\]</span> ​ &lt;4&gt; 互信息的等价表示： <span class="math display">\[\begin{equation*}\begin{split}I(X;Y)&amp;=H(X)-H(X|Y)\\&amp;=H(Y)-H(Y|X)\\&amp;=H(X)+H(Y)-H(X,Y)\\&amp;=H(X,Y)-H(X|Y)-H(Y|X)\end{split}\end{equation*}\]</span> ​ 其中 <span class="math inline">\(H(X)\)</span> 和 <spanclass="math inline">\(H(Y)\)</span> 是边缘熵，<spanclass="math inline">\(H(X|Y)\)</span> 和 <spanclass="math inline">\(H(Y|X)\)</span> 是条件熵，<spanclass="math inline">\(H(X,Y)\)</span> 是联合熵</p><h4 id="信息增量">11.3.2 信息增量</h4><p>如果 <span class="math inline">\(P\)</span> 为数据的真实分布，<spanclass="math inline">\(Q\)</span>为数据的理论分布，根据相对熵的性质，对于离散型随机变量，我们有： <spanclass="math display">\[Gain(P,Q)=-\sum P(i)\ln \frac{Q(i)}{P(i)}\]</span> 对于连续型随机变量，我们有： <span class="math display">\[Gain(P,Q)=\int_{-\infty}^{+\infty}p(x)\ln\frac{p(x)}{q(x)}dx\]</span> 更一般地，如果 <span class="math inline">\(P\)</span> 和 <spanclass="math inline">\(Q\)</span> 是集合 <spanclass="math inline">\(X\)</span> 上的测度函数，<spanclass="math inline">\(Q\)</span> 关于 <spanclass="math inline">\(P\)</span> 绝对连续，从 <spanclass="math inline">\(P\)</span> 到 <spanclass="math inline">\(Q\)</span> 的信息增益定义为 <spanclass="math display">\[Gain(P,Q)=-\int_X\ln\frac{dQ}{dP}dP\]</span></p><h4 id="信息增益率">11.3.3 信息增益率</h4><p>信息增益率指的是属性的信息增益两相对于该属性熵值的比值 <spanclass="math display">\[GainRatio(T,P)=\frac{Gain(T,P)}{Entropy(T,P)}\]</span></p><h4 id="gini-系数">11.3.4 Gini 系数</h4><p><span class="math inline">\(Gini\)</span>系数指的是另外一种数据不纯度的测量方法，其定义如下 <spanclass="math display">\[Gini(D):=1-\sum_{i=1}^mp_i^2\]</span> 其中的 <span class="math inline">\(m\)</span> 表示数据集 <spanclass="math inline">\(D\)</span> 中类别 <spanclass="math inline">\(C\)</span> 的个数，<spanclass="math inline">\(p_i\)</span> 表示 <spanclass="math inline">\(D\)</span> 中任意一个记录属于 <spanclass="math inline">\(C_i\)</span> 的概率</p><h3 id="最大熵">11.4 最大熵</h3><h4 id="最大熵模型的定义">11.4.1 最大熵模型的定义</h4><h5 id="定义-11.6最大熵原理">定义 11.6：最大熵原理</h5><p>一个正确的概率分布该满足下面的两个条件：</p><p>​ &lt;1&gt; 服从样本数据中的一直统计证据</p><p>​ &lt;2&gt; 使熵最大化 <span class="math display">\[p^*=arg\max_{p\in P} H(p)\]</span> 其中，<span class="math inline">\(P\)</span>表示所有可能的概率分布</p><h5 id="定义-11.7最大熵模型的学习">定义 11.7：最大熵模型的学习</h5><p>设特征函数 <span class="math inline">\(f(x,y)\)</span> 满足 <spanclass="math display">\[f(x,y)=\left\{\begin{array}{**lr**}1,\ iff …\\0,\ else\end{array}\right.\]</span></p><p>特征函数 <span class="math inline">\(f(x,y)\)</span> 关于经验分布<span class="math inline">\(\overline P(X,Y)\)</span> 的期望值，用 <spanclass="math inline">\(E_{\overline P}(f)\)</span> 表示为 <spanclass="math display">\[E_{\overline P}(f)=\sum_{x,y}\overline P(x,y)f(x,y)\]</span></p><p>特征函数 <span class="math inline">\(f(x,y)\)</span> 关于条件分布<span class="math inline">\(P(X|Y)\)</span> 和经验分布 <spanclass="math inline">\(\overline P(X)\)</span> 的期望值，用 <spanclass="math inline">\(EP(f)\)</span> 表示为 <spanclass="math display">\[E_{\overline P}(f)=\sum_{x,y}\overline P(x)\overline P(y|x)f(x,y)\]</span></p><p>如果模型可以从训练集中学习，我呢吧就可以假设这两个期望相等，即：<span class="math display">\[E_{\overline P}(f)=EP(f)\]</span></p><h5 id="定义-11.7最大熵模型">定义 11.7：最大熵模型</h5><p>设满足所有约束条件的模型集合为 <span class="math display">\[E_{\overline P}(f_i)=EP(f_i)\\\]</span> 定义在条件概率分布 <span class="math inline">\(P(X|Y)\)</span>上的条件熵为 <span class="math display">\[H(P)=\sum_{x,y}\overline P(x)\overline P(y|x)f(x,y)\]</span></p><h5 id="定义-11.4.2-最大熵模型的学习">定义 11.4.2 最大熵模型的学习</h5>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information Entropy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十章 回归分析</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="第十章-回归分析">第十章 回归分析</h2><h3 id="一元线性回归分析">10.1 一元线性回归分析</h3><h4 id="基本步骤">10.1.1 基本步骤</h4><p>​ &lt;1&gt; 采集样本</p><p>​ &lt;2&gt; 回归分析</p><p>​ &lt;3&gt; 对回归方程显著性检验</p><p>​ &lt;4&gt; 预测与控制</p><h4 id="最小二乘估计">10.1.2 最小二乘估计</h4><p>称 <span class="math inline">\(y = a+bx+e\)</span>为一元线性回归方程，其中 <span class="math inline">\(a+bx\)</span> 表示<span class="math inline">\(y\)</span> 随 <spanclass="math inline">\(x\)</span> 线性变化的部分，<spanclass="math inline">\(e\)</span>是一切随机因素的总和，要使得这一误差最小，考察 <spanclass="math display">\[y_i=a+bx_i+e_i\]</span></p><p>令 <span class="math display">\[Q(a,b)=\sum_{i=1}^ne_i^2=\sum_{i=1}^n(a+bx_i-y_i)^2\]</span></p><p>根据微分方程极值原理，令 <span class="math display">\[\left\{\begin{array}{**lr}\frac{\partial Q}{\partial a}=-2\sum_{i=1}^n(y_i-a-bx_i)=0\\\frac{\partial Q}{\partial b}=-2\sum_{i=1}^nx_i(y_i-a-bx_i)=0\\\end{array}\right.\]</span></p><p>解得</p><p><span class="math display">\[\left\{\begin{array}{**lr}\hat a=\overline y-\hat b\\\hat b=\frac{l_{xy}}{l_{xx}}\end{array}\right.\]</span></p><p>其中 <span class="math display">\[\left\{\begin{array}{**lr}l_{xy}=\displaystyle \sum_{i=1}^n(x_i-\overline x)(y_i-\overliney)=\sum_{i=1}^nx_iy_i-\frac{1}{n}(\sum_{i=1}^ny_i)(\sum_{i=1}^nx_i)\\l_{xx}=\displaystyle \sum_{i=1}^n(x_i-\overlinex)^2=\sum_{i=1}^nx_i^2-\frac{1}{n}(\sum_{i=1}^nx_i)^2\end{array}\right.\]</span></p><p>同时，我们用 <span class="math display">\[r^2=\frac{S_R}{S_T}\]</span></p><p>表示回归直线对样本的拟合程度（<spanclass="math inline">\(|r|\)</span> 越接近1，拟合程度越高），或者可以用残差（开根号后为标准残差）来表示偏差累计<span class="math display">\[S_y^2=\frac{S_e}{n-2}=\frac{\displaystyle \sum_i(y_i-\hat y_i)^2}{n-2}\]</span></p><h4 id="显著性检验">10.1.3 显著性检验</h4><h5 id="定义">定义：</h5><p>​ &lt;1&gt; 总偏差平方和 <span class="math inline">\(S_T\)</span>:<span class="math display">\[S_T:=\sum_{i=1}^n(y_i-\overline y)^2\]</span> ​ &lt;2&gt; 回归偏差平方和 <spanclass="math inline">\(S_R\)</span> <span class="math display">\[S_R:=\sum_{i=1}^n(\hat y_i-\overline y)^2\]</span> ​ &lt;3&gt; 随机误差 <span class="math inline">\(S_e\)</span>:<span class="math display">\[S_e:=\sum_{i=1}^n(y_i-\hat y_i)^2\]</span></p><h5 id="定理-10.1">定理 10.1：</h5><p>一元线性回归分析中，总偏差平方和等于回归偏差平方和与随机误差之和，即：<span class="math display">\[S_T=S_R+S_e\]</span></p><h3 id="多元线性回归分析">10.2 多元线性回归分析</h3><h4 id="基本步骤-1">10.2.1 基本步骤</h4><p>​ 考察因变量 <span class="math inline">\(y\)</span> 与 <spanclass="math inline">\(m-1\)</span> 个自变量 <spanclass="math inline">\(x_1,x_2,…,x_{m-1}\)</span>的关系，分析如下的多元线性回归模型，即 <span class="math display">\[y=\beta_0 + \sum_{i=1}^{m-1}\beta_ix_i + e\]</span> ​ 为了方便，采用以下记号： <span class="math display">\[Y=\left[\begin{array}{}y_1\\y_2\\\ \vdots\\y_n\end{array}\right],\beta=\left[\begin{array}{}\beta_0\\\beta_1\\\ \vdots\\\beta_{m-1}\end{array}\right],e=\left[\begin{array}{}e_1\\e_2\\\ \vdots\\e_n\end{array}\right],X=\left[\begin{array}{}1 &amp; x_{11} &amp; \cdots &amp; x_{1(m-1)}\\1 &amp; x_{21} &amp; \cdots &amp; x_{2(m-1)}\\\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\\1 &amp; x_{n1} &amp; \cdots &amp; x_{n(m-1)}\end{array}\right]\]</span> 则多元线性模型可简化为 <span class="math display">\[\left\{\begin{array}{**lr}Y= X\beta + e\\e\sim\mathbb{N}(0,\sigma^2I_n)\end{array}\right.\]</span> 则相应地， <span class="math display">\[\begin{align}\hat\beta &amp;=(X^TX)^{-1}X^TY\\e &amp;=Y-\hat Y=(I-H)Y\\S_T &amp;=Y^TY-\frac{1}{n}Y^TJY\\S_e &amp;=Y^TY-\hat\beta X^TY\\S_R &amp;=S_T-S_e\\r^2 &amp;=\frac{S_R}{S_T}\end{align}\]</span></p><h4 id="偏回归系数分析">10.2.2 偏回归系数分析</h4><p>​ 回归关系显著并不意味着每个自变量 <spanclass="math inline">\(x_j\)</span> 对 <spanclass="math inline">\(y\)</span> 的影响都显著。若 <spanclass="math inline">\(x_j\)</span> 对 <spanclass="math inline">\(y\)</span> 无影响，那么线性方程中对应的 <spanclass="math inline">\(\beta_j=0\)</span>。我们对每个自变量进行以下假设检验：<span class="math display">\[H_0: \beta_j=0\\H_1:\beta_j\not =0\]</span> 我们需要计算检验统计量： <span class="math display">\[\frac{\hat\beta_j-\beta_j}{S(\hat\beta_j)}\sim t(n-m)\]</span> 所以，<span class="math inline">\(\beta_j\)</span> 的 <spanclass="math inline">\(1-\alpha\)</span> 置信区间为 <spanclass="math display">\[\hat\beta_j\pm t_{\alpha\over 2}(n-m)S(\hat\beta_j)\]</span></p><h3 id="非线性回归分析">10.3 非线性回归分析</h3><h4 id="基本步骤-2">10.3.1 基本步骤</h4><p>​ &lt;1&gt; 进行变量变换实现线性化</p><p>​ &lt;2&gt; 进行线性回归预测</p><p>​ &lt;3&gt; 进行反变换实现数据还原</p><h4 id="非线性函数">10.3.2 非线性函数</h4><h5 id="双曲线模型">双曲线模型</h5><p><span class="math display">\[\frac{1}{y}=a+\frac{b}{x}\]</span></p><h5 id="指数模型">指数模型</h5><p><span class="math display">\[y=ae^{bx}\]</span></p><h5 id="对数模型">对数模型</h5><p><span class="math display">\[y=a+blnx\]</span></p><h5 id="幂函数模型">幂函数模型</h5><p><span class="math display">\[y=ax^b\]</span></p><h4 id="线性化变换">10.3.3 线性化变换</h4><p>​ &lt;1&gt; 转化</p><p>​ &lt;2&gt; 分割</p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Regression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九章 高维数据处理</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="第九章-高维数据处理">第九章 高维数据处理</h2><h3 id="数据几何学维度">9.1数据几何学——维度</h3><h4 id="维度灾难">9.1.1 维度灾难</h4><h4 id="gauss-环定理">9.1.2 Gauss 环定理</h4><p>​ 一个均值为 <span class="math inline">\(0\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span> 的 <spanclass="math inline">\(d\)</span> 维 <spanclass="math inline">\(Gauss\)</span> 分布的密度函数为： <spanclass="math display">\[p(x) = \frac{1}{(2\pi)^{\frac{d}{2}}\sigma^d}exp(-\frac{||x||^2}{2\sigma^2})\]</span></p><h5 id="定理-9.1gauss环定理">定理 9.1：Gauss环定理</h5><p>​ 在任意方向上都有单位方差的 <span class="math inline">\(d\)</span>维球面 <span class="math inline">\(Gauss\)</span> 分布，<spanclass="math inline">\(\forall\beta\leq\sqrt d\)</span>，除了最多 <spanclass="math inline">\(3e^{-c\beta^2}\)</span> 的概率质量外，其余质量都在<span class="math display">\[\sqrt d -\beta \leq||x||\leq \sqrt d + \beta\]</span> 的环里，其中 <span class="math inline">\(c\)</span>为正常数</p><h4 id="j-l-引理">9.1.3 <span class="math inline">\(J-L\)</span>引理</h4><p><span class="math inline">\(Johnson-Lindenstrauss \ Lemma\)</span>与1984年由 <span class="math inline">\(William\ Johnson\)</span> 和<span class="math inline">\(Joram\ Lindenstrauss\)</span> 提出</p><h5 id="引理-9.1j-l-引理">引理 9.1：<spanclass="math inline">\(J-L\)</span> 引理</h5><p>​ 对给定的 <span class="math inline">\(\varepsilon \in (0,1)\)</span>以及 <span class="math inline">\(N\)</span> 维 <spanclass="math inline">\(Euclid\)</span> 空间的 <spanclass="math inline">\(m\)</span> 个点 <span class="math inline">\(\{x_1,x_2, …,x_n\}\)</span>，对于任意满足条件的 <spanclass="math inline">\(n\in \mathbb N\)</span> 且 <spanclass="math inline">\(n &gt; \frac{lnm}{ {\varepsilon^2\over 2} -{\varepsilon^3\over 3} }\)</span>，存在一个线性映射 <spanclass="math inline">\(f:\mathbb{R}^N\to\mathbb{R}^n\)</span>，将这 <spanclass="math inline">\(m\)</span> 个点，从 <spanclass="math inline">\(\mathbb{R}^N\)</span> 中映射到 <spanclass="math inline">\(\mathbb{R}^n\)</span>，同时“基本上”保持了点集成员两两之间的距离，即：<span class="math display">\[\forall x_i,x_j:(1-\varepsilon)||x_i-x_j||^2_2\leq||f(x_i)-f(x_j)||^2_2\leq (1+\varepsilon)||x_i-x_j||^2_2\\(1\leqi&lt;j\leq m)\]</span> ​ 更进一步地，这个线性映射 <spanclass="math inline">\(f\)</span> 还可以在多项式时间内给出</p><h3 id="相关性分析">9.2 相关性分析</h3><h4 id="pearson-相关系数">9.2.1 Pearson 相关系数</h4><h5 id="定义-9.1pearson相关系数pearson-r">定义9.1：Pearson相关系数（Pearson-<spanclass="math inline">\(r\)</span>）</h5><p>​ 两个样本 <span class="math inline">\(X,Y\)</span> 的 <spanclass="math inline">\(Pearson\)</span>相关系数可以用来描述两个统计样本之间的线性关系（当然也可能存在良好的非线性关系使得该系数为0），是两个容量为 <span class="math inline">\(n\)</span>的样本值的标准偏差之积的累加和除以自由度 <spanclass="math inline">\(n-1\)</span>，即 <span class="math display">\[r_{XY}:=\frac{1}{n-1}\sum_{i=1}^n(\frac{X_i-\overlineX}{s_X})(\frac{Y_i-\overline Y}{s_Y})\]</span></p><h5 id="定理-9.2pearson-r-计算公式">定理 9.2：Pearson-<spanclass="math inline">\(r\)</span> 计算公式</h5><p><span class="math display">\[r_{XY}=\frac{n\displaystyle\sum_iX_iY_i-\displaystyle\sum_iX_i\displaystyle\sum_iY_i}{\sqrt{n\displaystyle\sum_iX_i^2-(\displaystyle\sum_iX_i)^2}\sqrt {{n\displaystyle\sum_iY_i}-(\displaystyle\sum_iY_i)^2} }\]</span></p><h3 id="数据降维">9.3 数据降维</h3><h4 id="数据降维概述">9.3.1 数据降维概述</h4><p>​研究表明，当维数越来越多时，分析和处理多维数据的复杂度和成本成指数级增长；与此同时，在分析高维数据时，所需的空间样本数会随维数的增加成指数增长</p><h4 id="主成分分析-pca">9.3.2 主成分分析 PCA</h4><h5 id="定义-9.2主成分分析">定义 9.2：主成分分析</h5><p>​ 主成分分析(Principal components analysis, PCA)是线代数据分析中的标准工具，它是一种简单的非参数方法，用于从混乱的数据集中提取相关信息</p><p>​ 设有随机变量 <spanclass="math inline">\(X_1,X_2,…,X_p\)</span>，样本标准差记为 <spanclass="math inline">\(S_1,S_2,…,S_p\)</span>。首先做标准化变换： <spanclass="math display">\[C_j = \sum_{i = 1}^pa_{ji}x_i\ (j = 1,2,…,p)\]</span></p><h5 id="定义-9.3第一主成分">定义 9.3：第一主成分</h5><p>​ 若 <span class="math inline">\(C_1 = \displaystyle\sum_{i =1}^pa_{1j}x_j\)</span>，且使 <spanclass="math inline">\(Var(C_1)\)</span> 最大，则称 <spanclass="math inline">\(C_1\)</span> 为第一主成分</p><h5 id="定义-9.4第二主成分">定义 9.4：第二主成分</h5><p>​ 若 <span class="math inline">\(C_2 = \displaystyle\sum_{i =1}^pa_{2j}x_j\)</span>，<spanclass="math inline">\((a_{21},a_{22},…,a_{2p})\)</span> 与 <spanclass="math inline">\((a_{11},a_{12},…,a_{1p})\)</span> 垂直且使 <spanclass="math inline">\(Var(C_2)\)</span> 次大，则称 <spanclass="math inline">\(C_2\)</span> 为第二主成分</p><h5 id="意">意：</h5><p>​ &lt;1&gt; 各成分间互不相关，即 <span class="math display">\[Corr(C_i,C_j) = 0\ (i\not = j)\]</span> ​ &lt;2&gt; 组合系数构成的向量 <spanclass="math inline">\((a_{i1},a_{i2},…,a_{ip})\)</span> 为单位向量</p><p>​ &lt;3&gt; 主成分的方差是依次递减的，即 <span class="math display">\[Var(C_1)\geq Var(C_2)\geq …\geq Var(C_p)\]</span></p><p>​ &lt;4&gt; 总方差不增不减（主成分只是原变量的线性组合），即 <spanclass="math display">\[\sum_{i = 1}^pVar(C_i)=\sum_{i=1}^pVar(x_i)=p\]</span> ​ &lt;5&gt; 主成分与原变量的相关系数满足 <spanclass="math display">\[Corr(C_i,x_j) = a_{ij}\]</span> ​ &lt;6&gt; 令 <spanclass="math inline">\(X_1,X_2,…,X_p\)</span> 的相关矩阵为 <spanclass="math inline">\(R\)</span>，<spanclass="math inline">\((a_{i1},a_{i2}.…,a_{ip})\)</span> 则是相关矩阵<span class="math inline">\(R\)</span> 的第 <spanclass="math inline">\(i\)</span> 个特征向量。且特征值 <spanclass="math inline">\(l_i\)</span> 就是第 <spanclass="math inline">\(i\)</span> 主成分的方差</p><h4 id="线性判别分析-lda">9.3.3 线性判别分析 LDA</h4><p>​ 判别分析是一种统计技术，其中，线性判别分析 （Linear DiscriminantAnalysis）是对 <span class="math inline">\(Fisher\)</span>线性鉴别方法的归纳</p><h5 id="定义-9.5线性判别分析">定义 9.5：线性判别分析</h5><p>​线性判别分析是一种找到最佳分离两个或者多个类的变量的线性组合的方法</p><h4 id="局部线性嵌入-lle">9.3.4 局部线性嵌入 LLE</h4><h5 id="定义-9.6局部线性嵌入">定义 9.6：局部线性嵌入</h5><p>局部线性嵌入（Locally LinearEmbedding，LLE）消除了估计广泛分析的数据点之间成对距离的需要，从局部线性拟合中恢复全局非线性结构</p><h4 id="t-分布邻域嵌入-t-sne">9.3.5 t 分布邻域嵌入 t-SNE</h4><h5 id="定义-9.7t-分布邻域嵌入">定义 9.7：t-分布邻域嵌入</h5><p>​ t-分布邻域嵌入（t-distributed stochastic neighborembedding，t-SNE）将数据点间的距离转化为概率分布并且以此来表达点与点之间的相似度，算法使得高低维数据分布尽可能接近为目标</p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Correlation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章 多维概率分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%A4%9A%E7%BB%B4%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%A4%9A%E7%BB%B4%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第八章-多维概率分布">第八章 多维概率分布</h2><h3 id="多维概率分布">8.1 多维概率分布</h3><h4 id="联合分布">8.1.1 联合分布</h4><ol type="1"><li><p>二维随机变量</p><p>设样本空间为 <span class="math inline">\(\Omega = e\)</span>，<spanclass="math inline">\(X = X(e)\)</span>，和 <spanclass="math inline">\(Y = Y(e)\)</span>，是定义在 <spanclass="math inline">\(\Omega\)</span> 上的随机变量，由他们构成的一个变量<span class="math inline">\((X,Y)\)</span>叫做二维随机变量或二维随机向量</p></li></ol><h5 id="定义-8.1联合分布">定义 8.1：联合分布</h5><p>设 <span class="math inline">\((X,Y)\)</span> 是二维随机变量， <spanclass="math inline">\(x,y\)</span> 是任意实数，称二元函数 <spanclass="math display">\[F(x,y) = P(X\leq x\cap Y\leq y) = P(X\leq x,Y\leq y)\]</span> 为二元随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布函数</p><h5 id="定义-8.2二维离散随机变量概率分布律">定义8.2：二维离散随机变量概率分布律</h5><p>若二维随机变量的可能取值只有有限个或者可列无穷个，则称二维随机变量为离散型随机变量。二维离散型随机变量<span class="math inline">\((X,Y)\)</span> 的所有可能取值为 <spanclass="math inline">\((x_i,y_i),(i=1,2,…,n)\)</span>，则称 <spanclass="math display">\[P\{X = x_i,Y = y_i\} = p_{ij}\]</span> 为二维离散行随机变量 <spanclass="math inline">\((X,Y)\)</span> 的概率分布律，简称分布律</p><p>注意，二维离散随机变量的概率分布仍然满足概率的公理化定义：非负性，规范性，可列可加性（级数）</p><h5 id="定义-8.3二位连续随机变量的概率密度">定义8.3：二位连续随机变量的概率密度</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span>的分布函数为 <spanclass="math inline">\(F(x,y)\)</span>，如果存在非负函数 <spanclass="math inline">\(f(x,y)\)</span>，使得 <spanclass="math inline">\(\forall x,y\in\mathbb{R}\)</span>，都有 <spanclass="math display">\[F(x,y) = \int_{-\infty}^{x}\int_{-\infty}^{y}f(s,t)dsdt\]</span> 则称 <span class="math inline">\((X,Y)\)</span>为二位连续随机变量，并称非负函数 <spanclass="math inline">\(f(x,y)\)</span> 为 <spanclass="math inline">\((X,Y)\)</span> 的概率密度函数，或称 <spanclass="math inline">\(f(x,y)\)</span> 为 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的联合概率密度</p><p>注意，二维连续随机变量的概率分布仍然满足概率的公理化定义：非负性，规范性，可列可加性（级数），在此基础上，我们还有<span class="math display">\[f(x,y) = \frac{\partial^2F(x,y)}{\partial x\partial y}\]</span></p><h4 id="边缘分布">8.1.2 边缘分布</h4><h5 id="定义-8.4二维随机变量的边缘分布">定义8.4：二维随机变量的边缘分布</h5><p>设 <span class="math inline">\((X,Y)\)</span>为二维随机变量，称一维随机变量 <span class="math inline">\(X\)</span> 或<span class="math inline">\(Y\)</span> 的概率分布为二维随机变量 <spanclass="math inline">\((X,Y)\)</span> 关于 <spanclass="math inline">\(X\)</span> 或 <spanclass="math inline">\(Y\)</span> 对应的边缘分布，分别记作 <spanclass="math inline">\(F_X(x), F_Y(y)\)</span></p><h5 id="定义-8.5二维离散随机变量的边缘分布律">定义8.5：二维离散随机变量的边缘分布律</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span> 的分布律为<span class="math inline">\(p_{ij}\)</span>，那么对于随机变量 <spanclass="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>其各自的分布律对于固定的 <span class="math inline">\(i,j =1,2,…\)</span>， 满足 <span class="math display">\[P\{X=x_i\} = \sum_jp_{ij}=p_i\]</span> 则称 <span class="math inline">\(p_i\)</span> 为随机变量 <spanclass="math inline">\((X,Y)\)</span> 的边缘分布律。</p><h5 id="定义-8.6二维连续随机变量的边缘概率密度">定义8.6：二维连续随机变量的边缘概率密度</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span>的概率密度为 <span class="math inline">\(f(x,y)\)</span>，边缘概率密度<span class="math inline">\(f_X(x)\)</span> 和 <spanclass="math inline">\(f_Y(y)\)</span> 定义为 <spanclass="math display">\[\begin{align}&amp;f_X(x) = \int_{-\infty}^{+\infty}f(x,y)dy\\&amp;f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx\end{align}\]</span></p><h4 id="条件分布">8.1.3 条件分布</h4><h5 id="定义-8.7离散型随机变量的条件概率">定义8.7：离散型随机变量的条件概率</h5><p>设 <span class="math inline">\((X,Y)\)</span>是二维离散型随机变量，其分布律为 <spanclass="math inline">\(P\{X=x_i,Y=y_i\}=p_{ij}\)</span>，其边缘概率分别为<span class="math inline">\(p_{i\cdot}\ p_{\cdotj}\)</span>，则条件概率定义为 <span class="math display">\[\begin{align}&amp;P\{X=x_i|Y=y_i\}=\frac{P\{X=x_i,Y=y_i\}}{P\{Y=y_i\}} =\frac{p_{ij}}{p_{\cdot j}}\\&amp;P\{Y=y_i|X=x_i\}=\frac{P\{X=x_i,Y=y_i\}}{P\{X=x_i\}} =\frac{p_{ij}}{p_{i \cdot}}\end{align}\]</span></p><h5 id="定义-8.8连续型随机变量的条件概率">定义8.8：连续型随机变量的条件概率</h5><p>设 <span class="math inline">\((X,Y)\)</span>是二维连续型随机变量，其概率密度为 <spanclass="math inline">\(f(x,y)\)</span>，其边缘改率分别为 <spanclass="math inline">\(f_X(x), f_Y(y)\)</span>，则条件概率定义为 <spanclass="math display">\[\begin{align}&amp;f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)}\\&amp;f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)}\\\end{align}\]</span> 连续型随机变量的条件概率分布定义为 <spanclass="math display">\[\begin{align}&amp;F_{X|Y}(x|y) = P\{X\leqx|Y=y\}=\int_{-\infty}^{x}\frac{f(x,y)}{f_Y(y)}dx\\&amp;F_{Y|X}(y|x) = P\{Y\leqy|X=x\}=\int_{-\infty}^{y}\frac{f(x,y)}{f_X(x)}dy\\\end{align}\]</span></p><h4 id="独立性">8.1.4 独立性</h4><h5 id="定义-8.9独立性">定义 8.9：独立性</h5><p>二维随机变量 <span class="math inline">\((X,Y)\)</span>的分布函数及其边缘分布函数分别设为 <spanclass="math inline">\(F(x,y)\)</span> 和 <spanclass="math inline">\(F_X(x),\ F_Y(y)\)</span>，若 <spanclass="math display">\[\forall (x,y):F(x,y) = F_X(x)F_Y(y)\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h5 id="定义-8.10离散随机变量的独立性">定义8.10：离散随机变量的独立性</h5><p>离散二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布律和边缘分布律分别设为 <spanclass="math inline">\(p_{ij}\)</span> 和 <spanclass="math inline">\(p_{i\cdot},\ p_{\cdot j}\)</span>，若 <spanclass="math display">\[\forall (i，j):p_{ij} = p_{i\cdot}\times p_{\cdot j}\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h5 id="定义-8.11连续随机变量的独立性">定义8.11：连续随机变量的独立性</h5><p>连续二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布律和边缘分布律分别设为 <spanclass="math inline">\(f(x,y)\)</span> 和 <spanclass="math inline">\(f_X(x),\ f_Y(y)\)</span>，若 <spanclass="math display">\[\forall (x,y):f(x,y) = f_X(x)\times f_Y(y)\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h3 id="多维分布的矩">8.2 多维分布的矩</h3><h4 id="独立性的多维矩">8.2.1 独立性的多维矩</h4><h5 id="定理-8.1">定理 8.1：</h5><p>已知 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则有： <spanclass="math display">\[E(XY) = E(X)E(Y)\]</span></p><h5 id="定理-8.2">定理 8.2：</h5><p>已知 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则有： <spanclass="math display">\[D(X+Y) = D(X) + D(Y)\]</span></p><h4 id="相关性的多维矩">8.2.2 相关性的多维矩</h4><h5 id="定义-8.12协方差">定义 8.12：协方差</h5><p>随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的协方差定义为 <spanclass="math display">\[Cov(X,Y)\triangleq E(X-E(X))E(Y-E(Y))\]</span></p><h5 id="定理-8.3协方差计算">定理 8.3：协方差计算</h5><p><span class="math display">\[Cov(X,Y) = E(XY)-E(X)E(Y)\]</span></p><h5 id="推论-8.1">推论 8.1：</h5><p>对于任意随机变量 <spanclass="math inline">\(X,Y,Z\)</span>，不难得出： <spanclass="math display">\[\begin{align}&amp;Cov(X,Y)=Cov(Y,X)\\&amp;Cov(a,a)=0\\&amp;Cov(aX,bY)=abCov(X,Y)\\&amp;Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\end{align}\]</span></p><h5 id="推论-8.2">推论 8.2：</h5><p>对于任意随机变量 <span class="math inline">\(X,Y:\)</span> <spanclass="math display">\[D(X\pm Y)=D(X)+D(Y)\pm 2Cov(X,Y)\]</span></p><h5 id="推论-8.3">推论 8.3：</h5><p>若 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 相互独立，则： <spanclass="math display">\[Cov(X,Y) = 0\]</span></p><h5 id="定义-8.13相关系数">定义 8.13：相关系数</h5><p>协方差的数值会收到 <span class="math inline">\(X,Y\)</span>的量纲的影响，为了更加客观地度量变量之间的关系，我们将协方差归一化，定义为相关系数。若随机变量<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的数学期望和方差都存在，则称： <spanclass="math display">\[\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\\\]</span> 为随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的相关系数</p><h5 id="定理-8.4schwarz不等式">定理 8.4：Schwarz不等式</h5><p><span class="math display">\[Cov^2(X,Y)\leq \sigma^2_X\sigma^2_Y\\\]</span></p><h5 id="推论-8.4相关系数归一性">推论 8.4：相关系数归一性</h5><p><span class="math display">\[|\rho_{XY}|\leq 1\\\]</span></p><h5 id="定理-8.5线性相关定理">定理 8.5：线性相关定理</h5><p><span class="math inline">\(|\rho_{XY}|=1\)</span> 的充要条件是 <spanclass="math inline">\(X,Y\)</span> 几乎处处线性相关</p><h3 id="常用二维分布">8.3 常用二维分布</h3><h4 id="二维均匀分布">8.3.1 二维均匀分布</h4><h5 id="定义-8.14二维均匀分布">定义 8.14：二维均匀分布</h5><p>设 <span class="math inline">\(G\)</span>是平面上的有界闭区域，其面积为 <spanclass="math inline">\(A\)</span>，若二维随机变量 <spanclass="math inline">\((X,Y)\)</span> 具有概率密度 <spanclass="math display">\[\begin{align}&amp;\forall(x,y)\in G:f(x,y)=\frac{1}{A}\\&amp;\forall(x,y)\not \in G:f(x,y) = 0\\\end{align}\]</span> 则称 <span class="math inline">\((X,Y)\)</span> 在 <spanclass="math inline">\(G\)</span> 上二维均匀分布</p><h4 id="二维正态分布">8.3.2 二维正态分布</h4><p>如果随机变量 <span class="math inline">\((X,Y)\)</span> 的概率密度为<span class="math display">\[\begin{gather}&amp;f(x,y) =\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho)^2}\bigg[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}\bigg]}\\&amp;(-\infty&lt;x,y&lt;+\infty)\\\end{gather}\]</span> 则称 <span class="math inline">\((X,Y)\)</span> 服从参数为<span class="math inline">\(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho\)</span>的二维正态分布，记为 <span class="math display">\[(X,Y)\sim \mathbb{N}(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\\\]</span></p><h3 id="函数的概率分布">8.4 函数的概率分布</h3><h4 id="离散函数的分布">8.4.1 离散函数的分布</h4><h4 id="连续函数的分布">8.4.2 连续函数的分布</h4><h5 id="定理-8.6函数的分布定理">定理 8.6：函数的分布定理</h5><p><span class="math inline">\(X\)</span> 的密度函数为 <spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infty&lt;x&lt;+\infty\)</span>，<spanclass="math inline">\(Y = g(X)\)</span> 严格单调，即 $g'(x)&gt;0 $ 或 $g'(x)&lt;0$，则 <span class="math inline">\(Y\)</span> 的密度函数为：<span class="math display">\[f_Y(x) = f_X(h(y))|h&#39;(y)|\ \ \ (a&lt;y&lt;b)\\\]</span> 其中 <span class="math display">\[\begin{align}&amp;a = min(g(-\infty),g(+\infty))\\ &amp;b = max(g(-\infty),\g(+\infty))\\ &amp;h(y) = g^{-1}(x)\end{align}\]</span></p><h4 id="极值函数的分布">8.4.3 极值函数的分布</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Moment</tag>
      
      <tag>Distribution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章 假设检验</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="第七章-假设检验">第七章 假设检验</h2><h3 id="假设检验概述">7.1 假设检验概述</h3><h4 id="基本概念">7.1.1 基本概念</h4><ol type="1"><li><p>原假设 (Null Hypothesis) <spanclass="math inline">\(H_0\)</span>: <span class="math inline">\(\mu =\mu_0\)</span></p></li><li><p>备择假设（Alternative Hypothesis）<spanclass="math inline">\(H_1\)</span>：<span class="math inline">\(\mu\not= \mu_0\)</span></p></li><li><p>显著性水平（Significance Level）<spanclass="math inline">\(\alpha\)</span>：小概率水平</p></li><li><p>确定假设的界限 <spanclass="math inline">\(\mathcal{K}\)</span></p></li></ol><p>​ 5. 假设检验的拒绝域 <span class="math inline">\(\mathscr{D}\subseteq \mathbb{X}^n\)</span></p><h4 id="两种错误">7.1.2 两种错误</h4><h5 id="第一类错误">1. 第一类错误</h5><h5 id="第二类错误">2. 第二类错误</h5><h4 id="显著性水平与p值">7.1.3 显著性水平与p值</h4><h5 id="使用p值进行假设检验的基本法则是">1.使用p值进行假设检验的基本法则是：</h5><p>​ 若 <span class="math inline">\(p\)</span> 值小于 $$ , 则拒绝 <spanclass="math inline">\(H_0\)</span>，否则就不拒绝 <spanclass="math inline">\(H_0\)</span> (<spanclass="math inline">\(\alpha\)</span> 决定是否显著，<spanclass="math inline">\(p\)</span> 表现有多显著)</p><p>​ <span class="math inline">\(p\)</span>值越小，则认为拒绝原假设的理由越充分</p><h4 id="单边与双边检验">7.1.4 单边与双边检验</h4><h5 id="双边two-tail检验">1. 双边（Two-Tail）检验</h5><p><span class="math display">\[H_0:\mu=\mu_0,\ H_1:\mu=\mu_1\]</span></p><h5 id="单边one-tail假设">2. 单边（One-Tail）假设</h5><p><span class="math display">\[H_0:\mu\leq\mu_0,\ H_1:\mu&gt;\mu_0\]</span></p><h4 id="基本步骤">7.1.5 基本步骤</h4><ol type="1"><li><p>建立原假设和备选假设，选择合适的 <spanclass="math inline">\(p\)</span> 值</p></li><li><p>对总体抽样，获取总体样本值</p></li><li><p>选取统计量（其抽样分布要明确，不含参数）</p></li><li><p>分两种（或同时）方法进行决策判断</p></li></ol><p>​ &lt;1&gt; 利用 <span class="math inline">\(\alpha\)</span>决定什么是拒绝域</p><p>​ &lt;2&gt; 利用样本数据计算 <span class="math inline">\(p\)</span>值，将其与 <span class="math inline">\(\alpha\)</span> 比较</p><h3 id="参数假设检验-先假定分布形式再来估计参数">7.2 参数假设检验(先假定分布形式，再来估计参数)</h3><h4 id="z-检验-大样本或方差已知">7.2.1 Z 检验 (大样本或方差已知)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(Z\sim \mathbb{N}(0,\1)\)</span>，计算统计量数值 <spanclass="math inline">\(z\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="t-检验-小样本且-sigma2-未知">7.2.2 t 检验 (小样本且 <spanclass="math inline">\(\sigma^2\)</span> 未知)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(t\simt(n&#39;)\)</span>，计算统计量数值 <spanclass="math inline">\(t\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="chi2检验-判断方差变化是否显著">7.2.3 <spanclass="math inline">\(\chi^2\)</span>检验 (判断方差变化是否显著)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(\chi^2\sim\chi^2(n&#39;)\)</span>，计算统计量数值 <spanclass="math inline">\(\chi^2\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="f检验-判断方差比变化是否显著">7.2.4 F检验(判断方差比变化是否显著)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(F\sim F(n_1,\n_2)\)</span>，计算统计量数值 <spanclass="math inline">\(F\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h3 id="非参数假设检验对总体分布形式未知">7.3非参数假设检验（对总体分布形式未知）</h3><h4 id="符号检验sign-test">7.3.1 符号检验（Sign Test）</h4><h4 id="秩和检验wilcoxon-rank-sum">7.3.2 秩和检验（WilcoxonRank-Sum）</h4><h5 id="秩rank指的是两组数据混合排序后的序号均值">1.秩（Rank）指的是两组数据混合排序后的序号均值</h5><h5 id="定理7.1大样本逼近">定理7.1：大样本逼近</h5><p>当两样本容量较大时（经验要求 <spanclass="math inline">\(n_1\)</span>, <span class="math inline">\(n_2 &gt;10\)</span> ），秩和统计检验量 <span class="math inline">\(T\)</span>近似服从 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>，其中： <spanclass="math display">\[\mu=\frac{n_1(n_1+n_2+1)}{2}\\\sigma^2=\frac{n_1n_2(n_1+n_2+1)}{12}\]</span> 则： <span class="math display">\[U=\frac{T-\mu}{\sigma}\sim\mathbb{N}(0,\ 1)\]</span> 所以秩和检验的拒绝域为 <spanclass="math inline">\(|U|&gt;z_{\frac{\alpha}{2}}\)</span></p><h4 id="偏度峰度检验">7.3.3 偏度峰度检验</h4><h5 id="偏度与峰度">1. 偏度与峰度</h5><p>偏度： <span class="math display">\[\nu_1\triangleq\frac{E((X-E(X))^3)}{(Var(X))^{\frac{3}{2}}}=E[(\frac{X-E(X)}{\sqrt{Var(X)}})^{3}]\\\]</span> 峰度： <span class="math display">\[\nu_1\triangleq\frac{E((X-E(X))^4)}{(Var(X))^{2}}=E[(\frac{X-E(X)}{\sqrt{Var(X)}})^{4}]\\\]</span></p><h5 id="section">2.</h5><h4 id="chi2拟合优度检验">7.3.4 <spanclass="math inline">\(\chi^{2}\)</span>拟合优度检验</h4><h5 id="定理7.2pearson定理">定理7.2：Pearson定理</h5><h4 id="chi2独立性检验">7.3.5 <spanclass="math inline">\(\chi^{2}\)</span>独立性检验</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hypothesis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 参数估计</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="第六章">第六章</h2><h3 id="点估计">6.1 点估计</h3><h4 id="矩估计">6.1.1 矩估计</h4><h5 id="定义6.1矩估计">定义6.1：矩估计</h5><p>随机变量 <span class="math inline">\(X\)</span>服从某总体分布，其中包含 <span class="math inline">\(k\)</span>个未知参数，<span class="math inline">\(θ_i(i = 1, 2, … , k), \ μ_l =E(X^l)\)</span> 为总体的 <span class="math inline">\(l\)</span>阶矩。<span class="math inline">\(X_i(i = 1, 2, … , n)\)</span> 是来自于<span class="math inline">\(X\)</span>的样本，那么求解以下方程组得到的估计值 <span class="math inline">\(θ_i(i= 1, 2, …, k)\)</span> 的方法称为矩估计法。 <spanclass="math display">\[μ_i = A_i(i = 1, 2, …， k)\]</span></p><h5 id="定理6.1-矩估计定理">定理6.1 矩估计定理</h5><p>设随机变量 <span class="math inline">\(X\)</span> 的数学期望和 <spanclass="math inline">\(μ\)</span> 和方差 <spanclass="math inline">\(σ^2\)</span> 都存在，且有估计量 <spanclass="math inline">\(σ^2&gt;0\)</span>。<spanclass="math inline">\(μ\)</span> 和 <spanclass="math inline">\(σ^2\)</span> 均未知。<spanclass="math inline">\(X_i(i = 1, 2, …， n)\)</span> 为来自 <spanclass="math inline">\(X\)</span> 的样本。则 <spanclass="math inline">\(μ\)</span> 和 <spanclass="math inline">\({σ}^2\)</span> 的估计量分别为 <spanclass="math display">\[\begin{align}\hat{μ} &amp;= \overline{X}\\\hat{σ}^2 &amp;= \frac{1}{n}\sum_{i = 1}^{n}(X_i - \overline{X})^2\end{align}\]</span></p><h4 id="极大似然估计">6.1.2 极大似然估计</h4><h5 id="定义6.2极大似然估计">定义6.2：极大似然估计</h5><p><span class="math inline">\(x\)</span> 是样本值，<spanclass="math inline">\(θ\)</span> 为需要估计的总体参数，<spanclass="math inline">\(L\)</span>为似然函数，极大似然估计的等式定义如下： <span class="math display">\[\hatθ_{MLE}(x) = \underset{θ}{arg\max}L(θ)\]</span> 其中，对于随机变量 <span class="math inline">\(X\)</span>,似然函数 <span class="math inline">\(L(θ) = \displaystyle\prod_{i =1}^nP(X = x)\)</span></p><h5id="定理6.2poisson分布极大似然估计定理">定理6.2：Poisson分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\pi(\lambda)\)</span> , <spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本,则<spanclass="math inline">\(\hat{\lambda} = \overline{X}\)</span></p><h5id="定理6.3exponential分布极大似然估计定理">定理6.3：Exponential分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span> ,<span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本, 则<spanclass="math inline">\(\hat{\lambda} =\frac{1}{\overline{X}}\)</span></p><h5id="定理6.4gauss分布极大似然估计定理">定理6.4：Gauss分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>, <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本, 则 <spanclass="math display">\[\begin{align}\hat{μ} &amp;= \overline{X}\\\hat{σ}^2 &amp;= \frac{1}{n}\sum_{i = 1}^{n}(X_i - \overline{X})^2\end{align}\]</span></p><h5id="定理6.5uniform分布极大似然估计定理">定理6.5：Uniform分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{U}(a,b)\)</span> , <spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本, 则 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的极大似然估计分别为 <spanclass="math inline">\(min_i{X_i}\)</span> ，<spanclass="math inline">\(max_i{X_i}\)</span></p><h4 id="截尾估计">6.1.3 截尾估计</h4><h4 id="评估分析">6.1.4 评估分析</h4><h5 id="定义6.3估计的无偏性">定义6.3：估计的无偏性</h5><p>无偏估计指的是估计量抽样分布的数学期望等于被估总体参数。即对于 <spanclass="math inline">\(\hat\theta(X_1,\ X_2, …，\ X_n)\)</span>，<spanclass="math inline">\(E(\hat\theta)\)</span> 存在且有 <spanclass="math display">\[E(\hat{\theta}) = \theta\]</span> 则称 <span class="math inline">\(\hat\theta\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的无偏估计</p><h5 id="引理6.1">引理6.1：</h5><p><span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本，<spanclass="math inline">\(g(x)\)</span> 是 <spanclass="math inline">\(x\)</span> 的函数且 <spanclass="math inline">\(E(g(X_i))\)</span> 和 <spanclass="math inline">\(Var(g(X_i))\)</span> 存在，则 <spanclass="math display">\[\begin{align}E(\sum_{i = 1}^ng(X_i)) &amp;= n(E(g(X_1)))\\Var(\sum_{i = 1}^ng(X_i)) &amp;= n(Var(g(X_1)))\end{align}\]</span></p><h5 id="定理6.6">定理6.6:</h5><p>设总体 <span class="math inline">\(X\)</span> 的均值是 <spanclass="math inline">\(\mu\)</span> ，方差为 <spanclass="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本，则：</p><p>（1）<span class="math inline">\(E(\overline{X}) = \mu\)</span> （<span class="math inline">\(\overline X\)</span> 是 <spanclass="math inline">\(\mu\)</span> 的无偏估计）</p><p>（2）<spanclass="math inline">\(Var(\overline{X})=\frac{\sigma^2}{n}\)</span></p><p>（3）<span class="math inline">\(E(S^2)=\sigma^2\)</span> （<spanclass="math inline">\(S^2\)</span> 是 <spanclass="math inline">\(\sigma^2\)</span> 的无偏估计）</p><p>其中，<span class="math inline">\(S^2\)</span>要考虑偏差，有 <spanclass="math inline">\(S^2 = \displaystyle \frac{1}{n -1}\displaystyle\sum_{i = 1}^{n}(X_i - \overline{X})^2\)</span></p><h5 id="定理6.7">定理6.7:</h5><p>设总体 <span class="math inline">\(X\)</span> 的 <spanclass="math inline">\(k\)</span> 阶矩 <span class="math inline">\(\mu_k= E(X^k)\)</span>，<span class="math inline">\(k \geq 1\)</span>存在，无论总体服从什么分布，<span class="math inline">\(k\)</span>阶样本矩<span class="math inline">\(A_k =\frac{1}{n}\displaystyle\sum_{i = 1}^nX_i^k\)</span> 是 <spanclass="math inline">\(k\)</span> 阶总体矩 <spanclass="math inline">\(\mu_k\)</span> 的无偏估计</p><h5 id="定义6.4估计的有效性">定义6.4：估计的有效性</h5><p>对于总体未知参数的两个无偏估计量，相应抽样分布的方差小视为更有效，即，若<span class="math inline">\(\hat\theta_1，\hat\theta_2\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的两个无偏估计，有 <spanclass="math display">\[Var(\hat\theta_1) &lt; Var(\hat\theta_2)\]</span> 则称 <span class="math inline">\(\hat\theta_1\)</span> 比<span class="math inline">\(\hat\theta_2\)</span> 更有效</p><h5id="定义6.5估计的一致性类比于一致收敛">定义6.5：估计的一致性（类比于一致收敛）</h5><p>一致性是指随着样本容量 <span class="math inline">\(n\)</span>增大，估计量越来越接近总体参数。即对于任意 <spanclass="math inline">\(\epsilon &gt; 0\)</span> ，有 <spanclass="math display">\[\lim_{n\rightarrow\infty}P(|\hat\theta - \theta|&lt;\epsilon) = 1\]</span> 则称 <span class="math inline">\(\hat\theta\)</span> 是 <spanclass="math inline">\(\theta\)</span> 的一致性估计量</p><h3 id="区间估计">6.2 区间估计</h3><h5 id="定义6.6置信区间">定义6.6：置信区间</h5><p>设总体 <span class="math inline">\(X\)</span> 的分布<spanclass="math inline">\(\ F(x;\theta)\)</span> 中含有未知参数 <spanclass="math inline">\(\theta\)</span> ，若存在样本的两个估计量 <spanclass="math inline">\(\underline{\theta}(X_i)\)</span> 和 <spanclass="math inline">\(\overline{\theta}(X_i)\)</span> <spanclass="math inline">\((i = 1, \ 2,\ …,\ n)\)</span> 使得对于给定的 <spanclass="math inline">\(\alpha\ (0 &lt; \alpha &lt;1)\)</span> ，有 <spanclass="math display">\[P(\underline\theta&lt;\theta&lt;\overline\theta) = 1 - \alpha\]</span> 则称随机区间 <spanclass="math inline">\((\underline\theta，\overline\theta)\)</span>为总体参数 <span class="math inline">\(\theta\)</span> 的置信水平为<span class="math inline">\(1 - \alpha\)</span>的（双侧）置信区间，<spanclass="math inline">\(\underline\theta\)</span> 和 $ $分别为置信下限和置信上限</p><h4 id="单总体均值区间估计">6.2.1 单总体均值区间估计</h4><h5 id="估计条件-1-xsimmathbbnmusigma2-且-sigma2-已知mu-未知">估计条件 1<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span> 已知，<spanclass="math inline">\(\mu\)</span> 未知</h5><h5 id="估计条件-2.-xsimmathbbnmusigma2-且-sigma2mu-未知">估计条件 2.<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu\)</span> 未知</h5><h5 id="估计条件-3.-x-不服从gauss分布但是样本容量较大大于30">估计条件 3.<span class="math inline">\(X\)</span>不服从Gauss分布，但是样本容量较大（大于30）</h5><h4 id="单总体方差区间估计">6.2.2 单总体方差区间估计</h4><h5 id="估计条件-1.-xsimmathbbnmusigma2-且-sigma2mu-未知">估计条件 1.<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu\)</span> 未知</h5><h4 id="双总体均值差区间估计">6.2.3 双总体均值差区间估计</h4><h5id="估计条件-1.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-已知">估计条件1. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu_1,\ \mu_2\)</span> 未知，<spanclass="math inline">\(\sigma_1^2,\ \sigma_2^2\)</span> 已知</h5><h5id="估计条件-2.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-未知但-sigma_12sigma_22">估计条件2. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span><spanclass="math inline">\(，\)</span><span class="math inline">\(\mu_1,\\mu_2\)</span> 未知，<span class="math inline">\(\sigma_1^2,\\sigma_2^2\)</span> 未知，但 <spanclass="math inline">\(\sigma_1^2=\sigma_2^2\)</span></h5><h5id="估计条件3.-x-和-y-不服从gauss分布但是样本容量均较大大于30">估计条件3.<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>不服从Gauss分布，但是样本容量均较大（大于30）</h5><h4 id="双总体方差比区间估计">6.2.4 双总体方差比区间估计</h4><h5id="估计条件-1.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-未知">估计条件1. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu_1,\ \mu_2\)</span> 未知，<spanclass="math inline">\(\sigma_1^2,\ \sigma_2^2\)</span> 未知</h5><h4 id="二项分布区间估计考察bernoulli分布正态逼近定理">6.2.5二项分布区间估计（考察Bernoulli分布正态逼近定理）</h4><h4 id="单侧置信区间">6.2.6 单侧置信区间</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Estimate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 抽样分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-抽样分布">第五章 抽样分布</h2><h3 id="数据抽样">5.1 数据抽样</h3><h4 id="数据分析">5.1.1 数据分析</h4><h5 id="全体数据-rightarrow-整体结论">1. 全体数据 <spanclass="math inline">\(\rightarrow\)</span> 整体结论</h5><h5id="全体数据-rightarrow-样本数据-rightarrow-样本结论-rightarrow-整体结论">1.全体数据 <span class="math inline">\(\rightarrow\)</span> 样本数据 <spanclass="math inline">\(\rightarrow\)</span> 样本结论 <spanclass="math inline">\(\rightarrow\)</span> 整体结论</h5><h4 id="抽样方法">5.1.2 抽样方法</h4><h5 id="简单随机抽样">1. 简单随机抽样</h5><h5 id="系统抽样">2. 系统抽样</h5><h5 id="整群抽样">3. 整群抽样</h5><h5 id="分层抽样">4. 分层抽样</h5><h4 id="抽样应用示例">5.1.3 抽样应用示例</h4><h3 id="矩与抽样分布">5.2 矩与抽样分布</h3><h4 id="矩与统计量">5.2.1 矩与统计量</h4><h5 id="定理5.1统计量抽样收敛定理">定理5.1：统计量抽样收敛定理</h5><p>设总体 <span class="math inline">\(X\)</span> 的均值是 <spanclass="math inline">\(\mu\)</span> ，方差为 <spanclass="math inline">\(\sigma^2\)</span> ，<spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本，则：</p><p>（1）<span class="math inline">\(E(\overline{X}) = \mu\)</span> （<span class="math inline">\(\overline X\)</span>是 <spanclass="math inline">\(\mu\)</span> 的无偏估计）</p><p>（2）<spanclass="math inline">\(Var(\overline{X})=\frac{\sigma^2}{n}\)</span></p><p>（3）<span class="math inline">\(E(S^2)=\sigma^2\)</span> （<spanclass="math inline">\(S^2\)</span> 是 <spanclass="math inline">\(\sigma^2\)</span> 的无偏估计）</p><p>其中，<span class="math inline">\(S^2\)</span> 要考虑偏差，有 <spanclass="math inline">\(S^2 = \frac{1}{n - 1}\displaystyle\sum_{i =1}^{n}(X_i - \overline{X})^2\)</span></p><h4 id="抽样分布">5.2.2 抽样分布</h4><h5 id="抽样分布的种类">1. 抽样分布的种类</h5><p>目前已知的抽样分布就多大几十种，但是常见的抽样分布只有四种：<spanclass="math inline">\(Gauss\)</span> 分布，<spanclass="math inline">\(t\)</span> 分布，<spanclass="math inline">\(F\)</span> 分布，<spanclass="math inline">\(\chi^2\)</span> 分布</p><h4 id="抽样分布示例">5.2.3 抽样分布示例</h4><h3 id="极限定理">5.3 极限定理</h3><h4 id="矩的不等式">5.3.1 矩的不等式</h4><h5 id="定理5.2marcov不等式">定理5.2：Marcov不等式</h5><p>设 <span class="math inline">\(X\)</span>是非负随机变量且具有数学期望 <span class="math inline">\(E(X)\)</span>，则 <span class="math inline">\(\forall{\varepsilon} &gt;0\)</span>，有： <span class="math display">\[P(X\geq\varepsilon)\leq\frac{E(X)}{\varepsilon}\]</span></p><h5 id="定理5.3chebyshev不等式">定理5.3：Chebyshev不等式</h5><p>设随机变量 <span class="math inline">\(X\)</span> 具有数学期望 <spanclass="math inline">\(E(X)=\mu\)</span> ，<spanclass="math inline">\(Var(X) = \sigma^2\)</span> ，则 <spanclass="math inline">\(\forall{\varepsilon} &gt; 0\)</span> ，有： <spanclass="math display">\[P(|x-\mu|\geq\varepsilon)\leq\frac{\sigma^2}{\varepsilon^2}\]</span></p><h4 id="大数定律">5.3.2 大数定律</h4><h5 id="定理5.4方差为0的充要条件">定理5.4：方差为0的充要条件</h5><p><span class="math inline">\(Var(X)=0\)</span> <spanclass="math inline">\(iff.\)</span> <spanclass="math inline">\(P(X=E(X)) = 1\)</span></p><h5 id="定理5.5bernoulli大数定律">定理5.5：Bernoulli大数定律</h5><p><span class="math inline">\(X_n\sim\mathbb{B}(n,\ p)\)</span>，<spanclass="math inline">\(\forall\varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{x_n}{n}-p|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.6chebyshev大数定律">定理5.6：Chebyshev大数定律</h5><p>设 <span class="math inline">\(X_i(i =1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <spanclass="math inline">\(E(X) = \mu\)</span> 和有限的方差 <spanclass="math inline">\(Var(X_i) = \sigma_i^2\)</span>，<spanclass="math inline">\(\forall\ \varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}EX_i|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.7khinchin大数定律">定理5.7：Khinchin大数定律</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的独立同分布随机变量，数学期望 <spanclass="math inline">\(E(X_i) = \mu\)</span> 存在，<spanclass="math inline">\(\forall\ \varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{1}{n}\sum_{i=1}^{n}X_i-\mu|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.8弱大数定律">定理5.8：弱大数定律</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <span class="math inline">\(E(X)\)</span>存在，则 <span class="math inline">\(\overline{X}_n\)</span>依概率收敛于 <span class="math inline">\(EX\)</span> ，即 <spanclass="math inline">\(\forall\ \varepsilon &gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{x_n}{n}-p|&lt;\varepsilon)=1\]</span></p><h4 id="中心极限定理">5.3.3 中心极限定理</h4><h5 id="定理5.9de-moivre-laplace中心极限定理">定理5.9：DeMoivre-Laplace中心极限定理</h5><p><span class="math inline">\(X_n\sim\mathbb{B}(n,\ p)\)</span> ，则：<span class="math display">\[\lim_{n\rightarrow\infty}P(\frac{X_n-np}{\sqrt{np(1-p)}}\leq{x})=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{\frac{-t^2}{2}}dt\]</span></p><h5id="定理5.10独立同分布中心极限定理">定理5.10：独立同分布中心极限定理</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <span class="math inline">\(E(X) =\mu\)</span> 和有限的方差 <span class="math inline">\(Var(X_i) =\sigma_i^2\)</span>，随机变量之和 <spanclass="math inline">\(\displaystyle\sum_{i = 1}^{n}X_i\)</span> ，设：<span class="math display">\[Y_n = \frac{\displaystyle\sum_{i = 1}^{n}X_i-E(\displaystyle\sum_{i =1}^{n}X_i)}{\sqrt{D(\displaystyle\sum_{i =1}^{n}X_i)}}=\frac{\displaystyle\sum_{i =1}^{n}X_i-n\mu}{\sqrt{n}\sigma}\]</span> 则： <span class="math display">\[\lim_{n\rightarrow\infty}P(Y_n\leq{x})=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{\frac{-t^2}{2}}dt=\Phi(x)\]</span></p><h5 id="定理5.11独立同分布正态样本">定理5.11：独立同分布正态样本</h5><p><span class="math inline">\(X_i\)</span> <spanclass="math inline">\((i = 1，2，…，n)\)</span> 是总体 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span> 的样本，<spanclass="math inline">\(\overline{X}\)</span> 是样本均值，则： <spanclass="math display">\[\overline{X}\sim\mathbb{N}(\mu,\frac{\sigma^2}{n})\]</span></p><h3 id="常用抽样分布">5.4 常用抽样分布</h3><h4 id="gamma函数">5.4.1 <spanclass="math inline">\(\Gamma\)</span>函数</h4><h5 id="定义5.1gamma函数">定义5.1：<spanclass="math inline">\(\Gamma\)</span>函数</h5><p>实数域上 <span class="math inline">\(\Gamma\)</span> 函数定义为：<span class="math display">\[\Gamma(x)=\int_{0}^{+\infty}t^{x-1}e^{-t}dt\ (x&gt;0)\]</span> <span class="math inline">\(\Gamma\)</span> 函数的重要性质：<span class="math display">\[\begin{align}&amp;\Gamma(n) = (n-1)!\ \ \ n\in\mathbb{N}\\&amp;\Gamma(1-x)\Gamma(x) =\frac{\pi}{sin\pi{x}}\\&amp;\Gamma(\frac{1}{2}) =\sqrt{\pi}\\&amp;\Gamma(x)\rightarrow\sqrt{2\pi}e^{-x}x^{x-\frac{1}{2}}\ \ \x\rightarrow+\infty\end{align}\]</span></p><h4 id="chi2-分布-karl-pearson">5.4.2 <spanclass="math inline">\(\chi^{2}\)</span> 分布 (Karl Pearson)</h4><h5 id="定理5.2chi2分布">定理5.2：<spanclass="math inline">\(\chi^{2}\)</span>分布</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(\mathbb{N}(0,1)\)</span>的独立同分布随机变量，则称随机变量： <span class="math display">\[\chi^2 = \sum_{i=1}^{n}X_i^2\]</span> 为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(\chi^2\)</span> 分布，记为 <spanclass="math inline">\(\chi^2(n)\)</span></p><h5 id="定理5.12chi2分布可加性">定理5.12：<spanclass="math inline">\(\chi^{2}\)</span>分布可加性</h5><p>设 <span class="math inline">\(X_1 \sim \chi^2(n_1)\)</span>，<spanclass="math inline">\(X_2 \sim\chi^2(n_2)\)</span>，且 <spanclass="math inline">\(X_1\)</span> 和 <spanclass="math inline">\(X_2\)</span> 相互独立，则： <spanclass="math display">\[X_1+X_2\sim\chi^2(n_1+n_2)\]</span></p><h5 id="定理5.13chi2分布的概率密度">定理5.13：<spanclass="math inline">\(\chi^{2}\)</span>分布的概率密度</h5><p><span class="math inline">\(\chi^2(n)\)</span> 分布的概率密度函数为：<span class="math display">\[f(x)=\frac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}}\]</span></p><h5 id="定理5.14chi2分布的是数字特征">定理5.14：<spanclass="math inline">\(\chi^{2}\)</span>分布的是数字特征</h5><p>若 <span class="math inline">\(X \sim \chi^2(n)\)</span>，则 <spanclass="math inline">\(E(X)=n\)</span>，<spanclass="math inline">\(Var(X)=2n\)</span></p><h5 id="定理5.15均值抽样分布定理">定理5.15：均值抽样分布定理</h5><p><span class="math inline">\(X_i\)</span> <spanclass="math inline">\((i = 1，2，…，n)\)</span> 是总体 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span> 的样本，<spanclass="math inline">\(\overline{X}\)</span> 是样本均值，则： <spanclass="math display">\[\overline{X}\sim\mathbb{N}(\mu,\frac{\sigma^2}{n})\]</span></p><h5 id="定理5.16方差抽样分布定理">定理5.16：方差抽样分布定理</h5><p><span class="math inline">\(X_i\)</span> (i = 1，2，…，n) 是总体<span class="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>的样本，<span class="math inline">\(S^2\)</span> 是样本方差，则有：<span class="math display">\[\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\]</span></p><h4 id="t-分布-gosset">5.4.3 <span class="math inline">\(t\)</span> 分布(Gosset)</h4><h5 id="定义5.3t-分布">定义5.3：<span class="math inline">\(t\)</span>分布</h5><p>设 <span class="math inline">\(X\sim\mathbb{N}(0,1)\)</span>，<spanclass="math inline">\(Y\sim\chi^2(n)\)</span>，且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则随机变量 <spanclass="math display">\[t=\frac{X}{\sqrt{\frac{Y}{n}}}\]</span> 称为服从自由度为 <span class="math inline">\(n\)</span> 的<span class="math inline">\(t\)</span> 分布，记为 <spanclass="math inline">\(t(n)\)</span></p><h5 id="定理5.17预备定理">定理5.17：预备定理</h5><p>设 <span class="math inline">\((X_1\)</span>，<spanclass="math inline">\(X_{2})\)</span> 是二维随机变量，其分布密度函数为<span class="math inline">\(f(x_1,\ x_2)\)</span>，且 <spanclass="math inline">\(X_1\)</span> 和 <spanclass="math inline">\(X_2\)</span> 相互独立，则 <spanclass="math inline">\(X\)</span> 的分布密度函数为： <spanclass="math display">\[f_X(x)=f_{x_1}(xx_2)f_{x_2}(x_2)|x_2|dx_2\]</span></p><h5 id="定理5.18t-分布密度函数">定理5.18：<spanclass="math inline">\(t\)</span> 分布密度函数</h5><p><span class="math inline">\(t(n)\)</span> 的密度函数为: <spanclass="math display">\[f(x)=\frac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\frac{x^2}{n})^{-\frac{n+1}{2}}\]</span></p><h5 id="定理5.19t-分布数字特征">定理5.19：<spanclass="math inline">\(t\)</span> 分布数字特征</h5><p><span class="math inline">\(X\sim t(n)\)</span> ，则：</p><p><span class="math display">\[\begin{align}E(X) &amp;= 0\\Var(X)&amp;=\frac{n}{n-2}\end{align}\]</span></p><h5 id="定理5.20t-分布对称性">定理5.20：<spanclass="math inline">\(t\)</span> 分布对称性</h5><p>对于给定的正数 <span class="math inline">\(\alpha\(0&lt;\alpha&lt;1)\)</span>，称满足条件 <spanclass="math inline">\(P(t&gt;t_{\alpha}(n))=\int_{t_{\alpha}(n)}^{+\infty}f(x)dx=\alpha\)</span>的点 <span class="math inline">\(t_{\alpha}(n)\)</span> 称为 <spanclass="math inline">\(t(n)\)</span> 上的 <spanclass="math inline">\(\alpha\)</span> 分位点。则： <spanclass="math display">\[t_{1-\alpha}(n)=-t_{\alpha}{(n)}\]</span></p><h5 id="定理5.21t-分布的正态收敛性">定理5.21：<spanclass="math inline">\(t\)</span> 分布的正态收敛性</h5><p><span class="math inline">\(t_(n)\)</span> 分布的概率密度 <spanclass="math inline">\(f(x)\)</span> 趋向于标准正态分布的概率密度，即：<span class="math display">\[\lim_{n\rightarrow\infty}f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}，(-\infty&lt;x&lt;+\infty)\]</span></p><h5 id="定理5.22均值抽样分布定理">定理5.22：均值抽样分布定理</h5><p><span class="math display">\[X_i\ (i = 1，2，…，n)\]</span> 是总体<span class="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>的样本，总体方差未知，样本均值和样本方差分别为 <spanclass="math inline">\(\overline{X}\)</span> 和 <spanclass="math inline">\(S^2\)</span> ，则： <span class="math display">\[\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1)\]</span></p><h4 id="f-分布-fisher">5.4.4 <span class="math inline">\(F\)</span> 分布(Fisher)</h4><h5 id="定义5.4f-分布">定义5.4：<span class="math inline">\(F\)</span>分布</h5><p>设 <span class="math inline">\(X\sim\chi^2(n_1)\)</span>，<spanclass="math inline">\(Y\sim\chi^2(n_2)\)</span>，且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则随机变量 <spanclass="math display">\[F=\frac{\frac{X}{n_1}}{\frac{Y}{n_2}}=\frac{n_2}{n_1}\frac{X}{Y}\]</span> 称为服从自由度为 <span class="math inline">\(n_1，n_2\)</span>的 <span class="math inline">\(F\)</span> 分布，记为 <spanclass="math inline">\(F(n_1，n_2)\)</span>，其中 <spanclass="math inline">\(n_1\)</span> 称为第一自由度，<spanclass="math inline">\(n_2\)</span> 称为第二自由度。</p><h5 id="定理5.23f-分布的倒数对称性">定理5.23：<spanclass="math inline">\(F\)</span> 分布的倒数对称性</h5><p><span class="math display">\[F_{1-\alpha}(n_1,\ n_2)=\frac{1}{F_{\alpha}(n_1, \ n_2)}\]</span></p><h5 id="定理5.24f-分布密度函数">定理5.24：<spanclass="math inline">\(F\)</span> 分布密度函数</h5><p><span class="math inline">\(F(n_1, \ n_2)\)</span>分布的概率密度函数为： <span class="math display">\[f(x;\ n_1,\ n_2) =\frac{\Gamma(\frac{n_1+n_2}{2})}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})}(\frac{n_1}{n_2})^{\frac{n_1}{2}}\frac{x^{\frac{n_1-2}{2}}}{(1+\frac{n_1}{n_2}x)^{\frac{n_1+n_2}{2}}}，\x&gt;0\]</span></p><h5 id="定理5.25f-分布数学期望">定理5.25：<spanclass="math inline">\(F\)</span> 分布数学期望</h5><p>若 <span class="math inline">\(X\sim F(n_1，n_2)\)</span>，则： <spanclass="math display">\[E(X)=\frac{n_2}{n_2-2}，\ n_2&gt;2\\Var(X)=\frac{n_2^2(2n_1+2n_2-4)}{n_1(n_2-2)^2(n_2-4)}，\ n_2&gt;4\]</span></p><h5 id="定理5.26正态分布逼近定理">定理5.26：正态分布逼近定理</h5><p>设 <span class="math inline">\(X_{i}\ (i=1，2，…，n_1)\)</span> ，<span class="math inline">\(Y_{i}\ (i=1，2，…，n_2)\)</span>，是分别来自两正态总体 <spanclass="math inline">\(\mathbb{N}(\mu_1,\sigma_1^2)\)</span>， <spanclass="math inline">\(\mathbb{N}(\mu_2,\sigma_2^2)\)</span>，则： <spanclass="math display">\[\frac{(\overline X-\overlineY)-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\sim\mathbb{N}(0,\ 1)\]</span></p><h5 id="定理5.27方差抽样分布定理">定理5.27：方差抽样分布定理</h5><p>设 <span class="math inline">\(X_{i}\ (i=1，2，…，n_1)\)</span> ，<span class="math inline">\(Y_{i}\ (i=1，2，…，n_2)\)</span>，是分别来自两正态总体 <spanclass="math inline">\(\mathbb{N}(\mu_1,\sigma_1^2)\)</span>， <spanclass="math inline">\(\mathbb{N}(\mu_2,\sigma_2^2)\)</span>，$S_1<sup>2, S_2</sup>2$ 分别为两样本方差，则： <span class="math display">\[\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\sim F(n_1-1,\ n_2-1)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distribution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 常用概率分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第四章-常用概率分布">第四章 常用概率分布</h2><h3 id="离散概率分布">4.1 离散概率分布</h3><h4 id="bernoulli-分布">4.1.1 Bernoulli 分布</h4><h5 id="定义4.1-bernoulli-分布">定义4.1 Bernoulli 分布</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数 <spanclass="math inline">\(p\)</span> 的伯努利分布，若： <spanclass="math display">\[\begin{gather}&amp;P\{X = k\} = p^k(1-p)^{1-k}\\&amp;k \in \{0,\ 1\}\end{gather}\]</span> 记作 <span class="math display">\[X\sim Bern(p)\]</span></p><h5 id="定理4.1-bernoulli-分布矩生成函数">定理4.1 Bernoulli分布矩生成函数</h5><p><span class="math inline">\(X\)</span> 为伯努利分布随机变量，则 <spanclass="math display">\[M_X(s) = (1-p)+pe^s\]</span></p><h4 id="binomial-分布">4.1.2 Binomial 分布</h4><h5 id="定义4.2-binomial-分布">定义4.2 Binomial 分布</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数 <spanclass="math inline">\(n,\ p\)</span> 的二项分布，若 <spanclass="math display">\[\begin{gather}&amp;P\{X = k\} = \binom{n}{k}p^k(1-p)^{n-k}\\&amp;k = 1,\ 2,…,n\end{gather}\]</span> 其中 <span class="math inline">\(n,\ p\)</span> 为参数，记为<span class="math inline">\(X\sim \mathbb{B}(n,\ p)\)</span>.特别地，利用微分恒等式可以得到二项分布的数字特征 <spanclass="math display">\[\begin{gather}&amp;E(X) = np\\&amp;V(X) = np(1-p)\end{gather}\]</span></p><h5 id="定理4.2-binomial-分布矩生成函数">定理4.2 Binomial分布矩生成函数</h5><p><span class="math inline">\(X\sim \mathbb{B}(n,\ p)\)</span>，则<span class="math display">\[M_X(s) = (pe^s+1-p)^n\]</span></p><h5 id="定理4.3-binomial-分布可加性">定理4.3 Binomial 分布可加性</h5><p>两二项分布随机变量 <span class="math inline">\(X\sim \mathbb{B}(m,\p), Y\sim\mathbb{B}(n,\ p)\)</span> 相互独立，则有 <spanclass="math display">\[X+Y\sim\mathbb{B}(m+n,\ p)\]</span></p><h4 id="poisson-分布">4.1.3 Poisson 分布</h4><h5 id="定义4.3-poisson-分布">定义4.3 Poisson 分布</h5><p>泊松分布的概率分布律为 <span class="math display">\[\begin{gather}&amp;P\{X = k\} = \frac{\lambda^k}{k!}e^{-\lambda}\\&amp;k= 0,\ 1,\ 2,\ …\end{gather}\]</span> 其中 <span class="math inline">\(\lambda\)</span> 为参数，记作<span class="math inline">\(X\sim \pi(\lambda)\)</span>.利用简单的变形可得泊松分布的数字特征 <span class="math display">\[\begin{gather}&amp;E(X) = \lambda\\&amp;V(X) = \lambda\end{gather}\]</span></p><h5 id="定理4.4-poisson-分布矩生成函数">定理4.4 Poisson分布矩生成函数</h5><p><span class="math inline">\(X\sim\pi(\lambda)\)</span>，则 <spanclass="math display">\[M_X(s) = e^{\lambda(e^s - 1)}\]</span></p><h5 id="定理4.5-binomial-分布-poisson-逼近定理">定理4.5 Binomial 分布Poisson 逼近定理</h5><p>设 <span class="math inline">\(\lambda&gt;0\)</span>是一个常数，<span class="math inline">\(n\)</span> 为正整数，若 <spanclass="math inline">\(np_n\)</span> 近似为 <spanclass="math inline">\(\lambda\)</span> ，则对于任意固定的非负整数 <spanclass="math inline">\(k\)</span>，有 <span class="math display">\[\lim_{n\rightarrow\infty}\binom{n}{k}p_n^k(1-p_n)^{n-k}=\frac{\lambda^k}{k!}e^{-\lambda}\]</span></p><h4 id="geometric-分布">4.1.4 Geometric 分布</h4><h5 id="定义4.4-geometric-分布">定义4.4 Geometric 分布</h5><p>几何分布的概率分布律为 <span class="math display">\[\begin{gather}P\{X=k\}=(1-p)^{k-1}p\\k = 1,\ 2,\ …,\ n\end{gather}\]</span> 其中 <span class="math inline">\(p\)</span> 为参数，记作 <spanclass="math inline">\(X\sim\mathbb{G}(p)\)</span>.利用等比数列求和错位相减得到几何分布的数字特征 <spanclass="math display">\[\begin{gather}&amp;E(X) = \frac{1}{p}\\&amp;V(x) = \frac{1-p}{p^2}\end{gather}\]</span></p><h5 id="定理4.6-geometric-分布无记忆性">定理4.6 Geometric分布无记忆性</h5><p>取值为正整数的随机变量 <span class="math inline">\(X\)</span>服从几何分布，当且仅当 <span class="math inline">\(X\)</span> 有无记忆性<span class="math display">\[\begin{gather}&amp;P\{X&gt;m+n\ |\ X&gt;m\} = P\{X&gt;n\}\\&amp;\forall m,\ n\geq0\end{gather}\]</span></p><h5 id="定理4.7-geometric-分布矩生成函数">定理4.7 Geometric分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{G}(p)\)</span> ，则 <spanclass="math display">\[M_X(s) = \frac{pe^s}{1-(1-p)e^s}\]</span></p><h4 id="negative-binomial-pascal-分布">4.1.5 Negative-Binomial (Pascal)分布</h4><h5 id="定义4.5-negative-binomial-分布一般化的几何分布">定义4.5Negative-Binomial 分布(一般化的几何分布)</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数为 <spanclass="math inline">\(r\)</span> 和 <spanclass="math inline">\(p\)</span> 的负二项分布，其概率分布律为 <spanclass="math display">\[\begin{gather}&amp;\mathbb{NB}(k;r,p) = \binom{k-1}{n-r}(1-p)^{k-r}p^r\\&amp;k = r,\ r+1,\ ……\end{gather}\]</span> 记作 <span class="math inline">\(X\sim\mathbb{NB}(r,\p)\)</span>. 特别地，利用组合恒等式不难求出负二项分布的数字特征 <spanclass="math display">\[\begin{gather}E(X) = \frac{r}{p}\\V(X) = \frac{r(1-p)}{p^2}\end{gather}\]</span></p><h5 id="定理4.8-negative-binomial-分布-poisson-逼近定理">定理4.8Negative-Binomial 分布 Poisson 逼近定理</h5><p>令 <span class="math inline">\(p = \frac{r}{\lambda+r}\)</span>，则<span class="math display">\[\lim_{r\rightarrow\infty}\mathbb{NB}(k&#39;;r,p) =\lim_{r\rightarrow\infty}\binom{k&#39;+r-1}{k&#39;}(1-p)^{k&#39;}p^r =\pi(k&#39;;\lambda)\]</span></p><h4 id="hyper-geometric-分布">4.1.6 Hyper-Geometric 分布</h4><h5 id="定义4.6-hyper-geometric分布">定义4.6 Hyper-Geometric分布</h5><p>超几何分布的概率分布律为 <span class="math display">\[\begin{gather}&amp;P(X=i) = \frac{\binom{m}{i}\binom{N-m}{n-i}}{\binom{N}{n}}\\&amp;i = 1,\ 2,\ …,\ n\end{gather}\]</span> 其中参数 <span class="math inline">\(n,\ N,\ m\)</span>均为正整数且 <span class="math inline">\(m\le N,\ n\le N\)</span>，记作<span class="math inline">\(X\sim\mathbb{H}(N,n,m)\)</span>.特别地，利用极大似然估计不难得到超几何分布的数字特征 <spanclass="math display">\[\begin{gather}&amp;E(X) = \frac{nm}{N}\\&amp;V(X) =\frac{nm}{N}\bigg(\frac{(n-1)(m-1)}{N-1}+1-\frac{nm}{N}\bigg)\end{gather}\]</span></p><h5 id="定理4.9-hyper-geometric-分布-binomial-逼近定理">定理4.9Hyper-Geometric 分布 Binomial 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\mathbb{H}(N,M,n)=\mathbb{B}(n,p)\]</span></p><p>其中 <span class="math inline">\(\frac{M}{N}=p\)</span></p><h3 id="连续概率分布">4.2 连续概率分布</h3><h4 id="uniform-分布">4.2.1 Uniform 分布</h4><h5 id="定义4.7-uniform-分布">定义4.7 Uniform 分布</h5><p>均匀分布的概率密度函数为 <span class="math display">\[\begin{gather}&amp;f(x)= \frac{1}{b-a}\\&amp;a&lt;x&lt;b\end{gather}\]</span> 其中 <span class="math inline">\(a,\ b\)</span> 为参数，记作<spanclass="math inline">\(X\sim\mathbb{U}(a,b)\)</span>，利用定义不难求出均匀分布的数字特征<span class="math display">\[\begin{gather}&amp;E(X) = \frac{a+b}{2}\\&amp;V(X) = \frac{(b-a)^2}{12}\end{gather}\]</span></p><h5 id="定理4.10-uniform-分布矩生成函数">定理4.10 Uniform分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{U}(a,b)\)</span>，则 <spanclass="math display">\[M_X(s) = \frac{e^{sb}-e^{sa}}{s(b-a)}\]</span></p><h4 id="exponential-分布">4.2.2 Exponential 分布</h4><h5 id="定义4.8-exponential-分布">定义4.8 Exponential 分布</h5><p>指数分布的概率密度为 <span class="math display">\[\begin{gather}&amp;f(x) = \lambda e^{-\lambda x}\\&amp;x&gt;0\end{gather}\]</span> 其中 <span class="math inline">\(\lambda &gt; 0\)</span>为参数，称 <span class="math inline">\(X\)</span> 服从参数为 <spanclass="math inline">\(\lambda\)</span> 的指数分布，记作 <spanclass="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>.利用矩生成函数不难算出指数分布的数字特征 <span class="math display">\[\begin{gather}&amp;E(X) = \frac{1}{\lambda}\\&amp;V(X) = \frac{1}{\lambda^2}\end{gather}\]</span></p><h5 id="定理4.11-exponential-分布的无记忆性">定理4.11 Exponential分布的无记忆性</h5><p><span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>，则<span class="math display">\[\forall s.\ t&gt;0:P\{X&gt;s+t\ |\ X&gt;s\}=P\{X&gt;t\}\]</span></p><h5 id="定理4.12-exponential-分布矩生成函数">定理4.12 Exponential分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>，则<span class="math display">\[\begin{gather}&amp;M_X(s) = \frac{\lambda}{\lambda-s}\\&amp;s&lt;\lambda\end{gather}\]</span></p><h5 id="定理4.13-geometric-分布连续化定理">定理4.13 Geometric分布连续化定理</h5><p><span class="math inline">\(X_n\sim\mathbb{G}(x_n;p)\)</span>，令<span class="math inline">\(p = \frac{\lambda}{n}\)</span>，则对于 <spanclass="math inline">\(t&gt;0,\ n\geq1\)</span>，有 <spanclass="math display">\[\lim_{n\rightarrow\infty}P\{X_n&lt;nt\} = 1-e^{-\lambda t}\]</span></p><h4 id="normal-分布">4.2.3 Normal 分布</h4><h5 id="定义4.9-normal-分布">定义4.9 Normal 分布</h5><p>正态分布的概率密度为 <span class="math display">\[\begin{gather}&amp;f(x) =\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\\&amp;-\infty&lt;x&lt;+\infty\end{gather}\]</span></p><p>其中，<span class="math inline">\(\mu,\sigma\)</span> 为参数，记作<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>.利用二重积分不难得到正态分布的数字特征 <span class="math display">\[\begin{gather}&amp;E(X) = \mu\\&amp;V(X) = \sigma^2\end{gather}\]</span></p><h5 id="定理4.14-standard-normal-分布的对称性">定理4.14 Standard Normal分布的对称性</h5><p>为了方便，记标准正态分布的概率密度函数和分布函数分别为 <spanclass="math inline">\(\phi(x)\)</span> 和 <spanclass="math inline">\(\Phi(x)\)</span> <span class="math display">\[\begin{gather}&amp;\phi(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\\&amp;\Phi(x) = \int_{-\infty}^{x}\phi(x)dx\end{gather}\]</span> 则有 <span class="math display">\[\Phi(x) + \Phi(-x) = 1\]</span></p><h5 id="定理4.15-normal-分布标准化">定理4.15 Normal 分布标准化</h5><p>若 <spanclass="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>，则 <spanclass="math display">\[Z = \frac{X-\mu}{\sigma}\sim\mathbb{N}(0,1)\]</span></p><h5 id="定理4.16-normal-分布矩生成函数">定理4.16 Normal分布矩生成函数</h5><p>若 <spanclass="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>，则 <spanclass="math display">\[M_X(s) = exp\{\mu t + \frac{\sigma^2t^2}{2}\}\]</span></p><h5 id="定理4.17-binomial-分布-normal-逼近定理">定理4.17 Binomial 分布Normal 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\mathbb{B}(n,p) = \mathbb{N}(\mu,\sigma^2)\]</span></p><p>其中，<span class="math inline">\(\mu = np,\ \sigma^2 =np(1-p)\)</span></p><h5 id="定理4.18-poisson-分布-normal-逼近定理">定理4.18 Poisson 分布Normal 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\pi(\lambda) = \mathbb{N}(\mu,\sigma^2)\]</span></p><p>其中 <span class="math inline">\(\sigma^2 = \lambda\)</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distribution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 随机变量</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-随机变量">第三章 随机变量</h2><h3 id="数据分布与概率分布">3.1 数据分布与概率分布</h3><h4 id="数据分布">3.1.1 数据分布</h4><h5 id="一般性定义">1. 一般性定义</h5><p>数据分布的一般性定义：从特定数据到一般规律的抽象。</p><h4 id="随机变量">3.1.2 随机变量</h4><h5 id="定义-3.1随机变量">定义 3.1：随机变量</h5><p>给定的样本空间为 <span class="math inline">\(\Omega =\{\omega\}\)</span>，若对于每一个样本点 <spanclass="math inline">\(\omega \in\Omega\)</span>，都有唯一确定的 <spanclass="math inline">\(X(\omega)\)</span> 与之对应，则称 <spanclass="math inline">\(X(\omega)\)</span> 是一个随机变量，简记为 <spanclass="math inline">\(X\)</span>, 即： <span class="math display">\[X: \Omega\rightarrow X(\Omega)\]</span></p><h5 id="定义-3.2分布函数">定义 3.2：分布函数</h5><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数定义为<span class="math display">\[F(x) = P(X\leq x) \  \ \ (x\in\mathbb{R})\]</span></p><h5 id="引理-3.1分布函数基本性质">引理 3.1：分布函数基本性质</h5><p>对于任意随机变量 <span class="math inline">\(X\)</span>，其分布函数<span class="math inline">\(F(x)\)</span> 具有以下的性质： <spanclass="math display">\[\begin{align*}&amp;1.\ \forall x\in \mathbb{R},0\le F(x)\le 1 \\ &amp;2.\ \forallx_1\leq x_2,F(x_1)\leq F(x_2)\\ &amp;3.\ \forall x_0\in\mathbb{R},F(x_0)= \lim_{x\rightarrow x_0^{+}} F(x)\\ &amp;4.\ F(-\infty) =\lim_{x\rightarrow - \infty}F(x) = 0,\ F(+\infty) = \lim_{x\rightarrow +\infty}F(x) = 1\end{align*}\]</span></p><h4 id="离散随机变量">3.1.3 离散随机变量</h4><h5 id="定义3.3离散型随机变量">定义3.3：离散型随机变量</h5><p>一个随机变量的可能（概率非零）取值至多可列个，则称它为离散型随机变量。<spanclass="math inline">\(X=x_i\)</span> 的概率标记为 <spanclass="math display">\[P(X = x_i) = p_i\\(i = 1,2,3,…)\]</span></p><h4 id="连续随机变量">3.1.4 连续随机变量</h4><h5 id="定义-3.4连续随机变量">定义 3.4：连续随机变量</h5><p>对于随机变量 <span class="math inline">\(X\)</span> 及其分布函数<span class="math inline">\(F(x)\)</span>，如存在非负可积函数 <spanclass="math inline">\(f(x)\)</span>，满足 <spanclass="math inline">\(\forall x:F(x) =\int_{-\infty}^{+\infty}f(t)dt\)</span> ，则称 <spanclass="math inline">\(X\)</span> 为连续随机变量，<spanclass="math inline">\(f(x)\)</span> 称为 <spanclass="math inline">\(X\)</span> 的概率密度函数</p><h5 id="定理-3.1连续随机变量性质">定理 3.1：连续随机变量性质</h5><ol type="1"><li><p>若 <span class="math inline">\(F\)</span> 在点 <spanclass="math inline">\(x\)</span> 处连续，则 <spanclass="math inline">\(F&#39;(x) = f(x)\)</span></p></li><li><p>连续随机变量 <span class="math inline">\(X\)</span>的任意一点概率为 <span class="math inline">\(0\)</span> , 即有 <spanclass="math display">\[\forall x:P(X=x)=0\]</span></p></li></ol><h4 id="随机变量的函数的分布">3.1.5 随机变量的函数的分布</h4><h5 id="定理-3.2函数的分布定理">定理 3.2：函数的分布定理</h5><p><span class="math inline">\(X\)</span> 的密度函数为 <spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infty&lt;x&lt;+\infty\)</span>，<spanclass="math inline">\(Y = g(X)\)</span> 严格单调，即 <spanclass="math inline">\(g&#39;(x)&gt;0\)</span> 或 <spanclass="math inline">\(g&#39;(x)&lt;0\)</span>，则 <spanclass="math inline">\(Y\)</span> 的密度函数为： <spanclass="math display">\[f_Y(x) = f_X(h(y))|h&#39;(y)|\ \ \ (a&lt;y&lt;b)\]</span> 其中 <span class="math display">\[\begin{align}&amp;a = min(g(-\infty),g(+\infty))\\&amp;b = max(g(-\infty),\ g(+\infty))\\&amp;h(y) = g^{-1}(x)\end{align}\]</span></p><h3 id="期望与矩">3.2 期望与矩</h3><h4 id="原点矩">3.2.1 原点矩</h4><h5 id="原点矩-1">1. 原点矩</h5><p>给定一批数据 <spanclass="math inline">\(x_1,x_2,x_3,…,x_n\)</span>，其 <spanclass="math inline">\(k\)</span> 阶原点矩 <spanclass="math inline">\(A_k \triangleq \frac{1}{n}\displaystyle{\sum_{i =1}^{n}x_i^k}\)</span></p><h5 id="定义-3.5">定义 3.5：</h5><p>离散随机变量 <span class="math inline">\(X\)</span> 的数学期望定义为<span class="math display">\[E(X)= \displaystyle{\sum_{i = 1}^\infty}x_ip_i\]</span> 连续随机变量 <span class="math inline">\(X\)</span>的数学期望定义为 <span class="math display">\[E(X) = \int_{-\infty}^{+\infty}xf(x)dx\]</span> 这里要求 <span class="math inline">\(\displaystyle{\sum_{i =1}^\infty}x_ip_i\)</span> 和 <spanclass="math inline">\(\int_{-\infty}^{+\infty}xf(x)dx\)</span>绝对收敛</p><h5 id="定理-3.3数学期望性质">定理 3.3：数学期望性质</h5><p>随机变量的数学期望有如下性质</p><ol type="1"><li><span class="math inline">\(E(C) = C \ (C\in\mathbb{R})\)</span></li><li><span class="math inline">\(E(CX) = CE(X)\ (C\in\mathbb{R})\)</span></li><li><span class="math inline">\(E(X\pm Y) = E(X)\pm E(Y)\)</span></li><li><span class="math inline">\(E(XY) = E(X)E(Y) \ iff.X,Y\ are\independent\)</span></li></ol><h4 id="中心矩">3.2.2 中心矩</h4><h5 id="定义-3.6中心矩">定义 3.6：中心矩</h5><p>给定随机变量 <span class="math inline">\(X\)</span>，若 <spanclass="math inline">\(E((X-E(X))^k)\)</span> 存在，则其 <spanclass="math inline">\(k\)</span> 阶中心矩定义为 <spanclass="math inline">\(E((X-E(X))^k)\)</span></p><h5 id="定义-3.7方差与标准差">定义 3.7：方差与标准差</h5><p><span class="math inline">\(X\)</span>随机变量的二姐中心矩为方差，记作 <spanclass="math inline">\(\sigma^2(X)\)</span> 或 <spanclass="math inline">\(Var(X)\)</span> 或 <spanclass="math inline">\(D(X)\)</span> ，而 <spanclass="math inline">\(\sqrt{Var(X)}\)</span> 称为 <spanclass="math inline">\(X\)</span> 的标准差，记为 <spanclass="math inline">\(\sigma(X)\)</span></p><h5 id="定理-3.4方差计算定理">定理 3.4：方差计算定理</h5><p><span class="math display">\[D(X) = E(X^2) - E^2(X)\]</span></p><h5 id="定理-3.5方差的性质">定理 3.5：方差的性质</h5><ol type="1"><li><p>设 <span class="math inline">\(C\)</span> 为常数，则 <spanclass="math inline">\(D(C) = 0\)</span></p></li><li><p>设 <span class="math inline">\(X\)</span> 是随机变量，<spanclass="math inline">\(C\)</span> 是常数，则 <spanclass="math display">\[D(X+C)=D(X)\\D(CX) = C^2D(X)\]</span></p></li><li><p>设随机变量 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 相互独立，则： <spanclass="math display">\[D(X\pm Y) = D(X) + D(Y)\]</span></p></li></ol><h3 id="矩的数学工具">3.3 矩的数学工具</h3><h4 id="微分恒等式">3.3.1 微分恒等式</h4><h5 id="定义-3.8微分恒等式法">定义 3.8：微分恒等式法</h5><p><span class="math inline">\(\alpha,\beta,\omega\)</span>是一些参数，<span class="math inline">\(\existsc\in\mathbb{N},s.t.n_{min},n_{max}\leq c\)</span>，设 <spanclass="math display">\[\displaystyle{\sum_{n = n_{min}}^{n_{max}}}f(n;\alpha,\beta,…,\omega)=g(\alpha,\beta,…,\omega)\]</span> 其中 <span class="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 是关于 <spanclass="math inline">\(\alpha\)</span> 的可微函数. 如果 <spanclass="math inline">\(f\)</span>退化到足以保证求和和求微分的次序可以交换，则 <spanclass="math display">\[\displaystyle{\sum_{n = n_{min}}^{n_{max}}}\frac{\partialf(n;\alpha,\beta,…,\omega)}{\partial\alpha}= \frac{\partialg(\alpha,\beta,…,\omega)}{\partial\alpha}\]</span></p><h4 id="矩生成函数的定义">3.3.1 矩生成函数的定义</h4><h5 id="定义-3.9矩生成函数">定义 3.9：矩生成函数</h5><p>随机变量 <span class="math inline">\(X\)</span> 的矩生成函数 <spanclass="math display">\[M_X(s) \triangleq E(e^{sX})\]</span> 其中，如果 <spanclass="math inline">\(\exists\delta\in\mathbb{R},s.t. \forall s\in[-\delta,\delta],M_X(s) \ is\ finite\)</span>，则称 <spanclass="math inline">\(M_X(s)\)</span> 存在</p><h4 id="矩生成函数的计算">3.3.3 矩生成函数的计算</h4><h5 id="定理-3.6矩生成定理">定理 3.6：矩生成定理</h5><p>假设随机变量 <span class="math inline">\(X\)</span> 的矩生成函数<span class="math inline">\(M_X(s)\)</span> 存在，则： <spanclass="math display">\[A_k = E(X^k) = {\frac{d^k}{dx^k}M_X(s)}\bigg{|}_{s=0}\]</span></p><h4 id="矩生成函数的性质">3.3.4 矩生成函数的性质</h4><h5 id="定理-3.7矩生成函数唯一性定理">定理3.7：矩生成函数唯一性定理</h5><p>对于两随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> ，假设存在常数 <spanclass="math inline">\(\delta\)</span> ，使得 <spanclass="math inline">\(M_X(s)\)</span> 和 <spanclass="math inline">\(M_Y(s)\)</span> 对于任意 <spanclass="math inline">\(s\in[-\delta,\ \delta]\)</span> 存在且相等，则<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的分布函数相等，即 <spanclass="math display">\[\forall t\in \mathbb{R} :F_X(t) = F_Y(t)\]</span></p><h5 id="定理-3.8矩生成函数可加性定理">定理3.8：矩生成函数可加性定理</h5><p><span class="math inline">\(X_i(i = 1,\ 2,\ …,\ n)\)</span>为独立随机变量，则 <span class="math display">\[M_{ {\sum_{i =1}^{n} }X_i(s)} = \displaystyle{\prod_{i= 1}^{n}}M_{X_i}(s)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Radom Variable</tag>
      
      <tag>Expectation</tag>
      
      <tag>Moment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 概率论基础</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-概率论基础">第二章 概率论基础</h2><h3 id="概率定义">2.1 概率定义</h3><h4 id="集合表示">2.1.1 集合表示</h4><h5 id="定义-2.1随机事件">定义 2.1：随机事件</h5><p>样本空间 <span class="math inline">\(\Omega\)</span> 的任意一个子集<span class="math inline">\(\Omega&#39;\)</span>称为随机事件，简称事件。记某次实验结果 <spanclass="math inline">\(\omega\)</span> ，当 <spanclass="math inline">\(\omega\in\Omega&#39;\)</span> 时，我们称这一事件<span class="math inline">\(\Omega&#39;\)</span> 发生</p><h4 id="古典概率">2.1.2 古典概率</h4><h5 id="定义-2.2古典概率">定义 2.2：古典概率</h5><p><span class="math inline">\(\Omega = \{\omega_1,\ \omega_2,\ …,\\omega_n\}\)</span> 有穷且每个样本点等可能，即 <spanclass="math inline">\(P(\{\omega_i\}) =\frac{1}{n}\)</span>，则称这样的概率类型为古典概率</p><h4 id="几何概率">2.1.3 几何概率</h4><p>试验可能结果是欧几里得空间中的点，所有样本点的集合 <spanclass="math inline">\(\Omega\)</span> 是此空间中的一个几何图形，满足条件<span class="math inline">\(0&lt;m(\Omega)&lt;+\infty\)</span> ，这里<span class="math inline">\(m(\Omega)\)</span>表示该集合的勒贝格测度（如长度，面积，体积等）。对 <spanclass="math inline">\(\Omega\)</span> 的任何可测子集 <spanclass="math inline">\(A\)</span> 的几何概率定义为 <spanclass="math display">\[P(A) = \frac{m(A)}{m(\Omega)}\]</span></p><h4 id="概率公理化">2.1.4 概率公理化</h4><h5 id="定义2.4概率公理化定义">定义2.4：概率公理化定义</h5><p>随机试验样本空间为 <span class="math inline">\(\Omega\)</span>，任意事件 <span class="math inline">\(A\)</span> 赋予一实数 <spanclass="math inline">\(P(A)\)</span>，满足下列三个条件</p><ol type="1"><li><p>非负性：<span class="math inline">\(P(A)\geq0\)</span></p></li><li><p>规范性：<span class="math inline">\(P(\Omega) =1\)</span></p></li><li><p>可列可加性：若事件 <span class="math inline">\(A_k(k = 1,\ 2,\…,\infty)\)</span> 两两不相容，则 <span class="math display">\[P(\bigcup_{i = 1}^{\infty}A_i) = \displaystyle\sum_{i = 1}^{n}P(A_i)\]</span></p></li></ol><p>称 <spanclass="math inline">\(P:\mathscr{F}\rightarrow\mathbb{R}\)</span>为概率函数，简称概率</p><h5 id="引理-2.1空集为零">引理 2.1：空集为零</h5><p><span class="math display">\[P(\varnothing) = 0\]</span></p><h5 id="引理-2.2互补性">引理 2.2：互补性</h5><p><span class="math display">\[P(\overline{A}) = 1-P(A)\]</span></p><h5 id="引理-2.3单调性">引理 2.3：单调性</h5><p>设 <span class="math inline">\(A, B\)</span> 是两个事件，则 <spanclass="math display">\[A\subseteq B \implies P(A)\leq P(B)\]</span></p><h5 id="引理-2.4可拆性">引理 2.4：可拆性</h5><p>对于任意两个随机事件 <span class="math inline">\(E_1,\ E_2\)</span><span class="math display">\[P(E_1\cup E_2) = P(E_1)+P(E_2)- P(E_1\cap E_2)\]</span></p><h5 id="引理-2.5事件概率的估计">引理 2.5：事件概率的估计</h5><p>对任意有限或可列无穷的事件序列 <span class="math inline">\(E_1,E_2,…,E_n\)</span>，总有 <span class="math display">\[P\bigg(\bigcup_{i&gt;1}E_i\bigg)\leq\sum_{i\geq1}P(E_i)\]</span></p><h3 id="概率计算">2.2 概率计算</h3><h4 id="条件概率">2.2.1 条件概率</h4><h5 id="定义2.5条件概率">定义2.5：条件概率</h5><p>对于事件 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> , 若 <span class="math inline">\(P(B)\not= 0\)</span>，称 <span class="math display">\[P(A|B) = \frac{P(AB)}{P(B)}\]</span></p><h4 id="乘法公式">2.2.2 乘法公式</h4><h5 id="定理-2.1乘法公式">定理 2.1：乘法公式</h5><p>若 <span class="math inline">\(P(A_1)&gt;0\)</span>，则 <spanclass="math inline">\(P(A_1A_2)= P(A_1)P(A_2|A_1)\)</span>，一般地，我们有 <span class="math display">\[P(\prod_{i = 1}^{n}A_i) =P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2A_3…A_{n-1})\]</span></p><h4 id="全概率公式">2.2.3 全概率公式</h4><p>设 <span class="math inline">\(B_k(k = 1,\ 2,\ …,\ n)\)</span>是样本空间 <span class="math inline">\(\Omega\)</span>的一个完备事件组，且 <span class="math inline">\(P(B_k)&gt;0\ (k = 1,\2,\ …,\ n)\)</span>，则对于任意随机事件 <spanclass="math inline">\(A\)</span> ，有 <span class="math display">\[P(A) = \sum_{i =1}^nP(B_i)P(A|B_i)\]</span></p><h4 id="bayes公式">2.2.4 Bayes公式</h4><p>设 <span class="math inline">\(B_k(k = 1,\ 2,\ …,\ n)\)</span>是样本空间 <span class="math inline">\(\Omega\)</span>的一个完备事件组，且 <span class="math inline">\(P(B_k)&gt;0\ (k = 1,\2,\ …,\ n)\)</span>，则对于任意随机事件 <span class="math inline">\(A,\P(A)&gt;0\)</span> ，有 <span class="math display">\[P(B_i|A) = \frac{P(A|B_i)P(B_i)}{P(A)}\]</span></p><h4 id="独立性">2.2.5 独立性</h4><h5 id="定义2.6独立性">定义2.6：独立性</h5><p>一般地，若事件 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> , 满足 <span class="math display">\[P(AB)=P(A)P(B)\]</span> 则称事件 <span class="math inline">\(A,B\)</span> 相互独立</p><p>一般地，若事件 <span class="math inline">\(A_k(k = 1,\ 2,\ …,\n)\)</span> 对于任意 <span class="math inline">\(I\subset \{1,\ 2,\ …,\n\}\)</span>，有 <span class="math display">\[P(\bigcap_{i\in I}A_i) = \prod_{i\in I}P(A_i)\]</span> 则称 <span class="math inline">\(A_k(k = 1,\ 2,\ …,\n)\)</span> 相互独立</p><h5 id="定理-2.4独立性的另一定义">定理 2.4：独立性的另一定义</h5><p>设 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span> 是两个事件，且 <spanclass="math inline">\(P(A) &gt; 0\)</span> ，则 <spanclass="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>独立当且仅当 <span class="math display">\[P(B|A) = P(B)\]</span></p><h5 id="定理-2.5独立性的推论">定理 2.5：独立性的推论</h5><p>若事件 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span> 独立，则对下列各对事件均相互独立 <spanclass="math display">\[A\ \&amp;\ \overline{B}\\ \overline{A}\ \&amp;\ B\\ \overline{A}\\&amp;\ \overline{B}\]</span></p><h3 id="随机测试示例">2.3随机测试示例</h3><h4 id="问题背景">2.3.1 问题背景</h4><h4 id="随机测试初步">2.3.2 随机测试初步</h4><h4 id="随机测试改进">2.3.3 随机测试改进</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Testing</tag>
      
      <tag>Possibility</tag>
      
      <tag>Bayes公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 数据分析初探</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-数据分析初探">第一章 数据分析初探</h2><h3 id="认识数据">1.1 认识数据</h3><h5 id="定义-1.1数据">定义 1.1：数据</h5><p>数据是自然世界抽象为集合元素的表示。在实际应用中，采用某种数学元素作为数据的抽象表示，数据集作为相应的集合</p><h5 id="定义-1.2信息">定义 1.2：信息</h5><p>数据赋予某种结构获得信息 <spanclass="math inline">\(\mathcal{I=S}(\mathcalD)\)</span>。信息通常能被人类所理解，并被用来消除不确定性。</p><h5 id="定义-1.3偏序结构">定义 1.3：偏序结构</h5><p><span class="math inline">\(A\)</span> 上的关系 <spanclass="math inline">\(R\)</span> 是自反的，反对称的，传递的。则 <spanclass="math inline">\(R\)</span> 是一个偏序，集合 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(R\)</span>一起称作偏序集，记做 <spanclass="math inline">\((A,\ R)\)</span>，在不引起混淆的情况下，可以简写成<span class="math inline">\(A\)</span></p><h5 id="定义-1.4知识">定义 1.4：知识</h5><p>知识是信息和规则的二元组 <spanclass="math inline">\(\mathcal{K}=&lt;\mathcal{I,R}&gt;\)</span>。信息与规则结合获得知识，并且能够推理出更多的知识</p><h3 id="数据类型">1.2 数据类型</h3><h5 id="定义1.5定类数据norminal">定义1.5：定类数据（Norminal）</h5><p>定类数据是对事物进行分类的结果，表现为类别，是仅仅反映观测对象所属类别的数据</p><h5 id="定义-1.6定序数据original">定义 1.6：定序数据（Original）</h5><p>定序数据是只仅仅反映观测对象等级，顺序关系的数据，是有定序尺度计量而形成的，表现为类别，可以进行排序，属于品质数据</p><h5 id="定义-1.7定距数据interval">定义 1.7：定距数据（Interval）</h5><p>定距数据是指具有顺序和距离属性的数据，室友定距尺度计量形成的，表现为数值，可以进行加、减运算以精确计算的数据</p><h5 id="定义-1.8定比数据ratio">定义 1.8：定比数据（Ratio）</h5><p>定比数据是指具有顺序，距离和比例属性的数据，室友定比尺度计量形成的，表现为数值，可以进行四则运算。没有负数。</p><h3 id="数据汇总">1.3 数据汇总</h3><h5 id="定义-1.9众数">定义 1.9：众数</h5><p>众数是一批数据中出现次数最多的那个数，记为 <spanclass="math inline">\(M_0\)</span></p><h5 id="定义-1.10中位数">定义 1.10：中位数</h5><p>设一批数据经过排序之后为 <span class="math inline">\(X_1,\ X_2,\ …,\X_n\)</span>，则其中位数 <span class="math inline">\(M_e \triangleqM_{[\frac{n+1}{2}]}\)</span></p><h5 id="定义-1.11四分位数">定义 1.11：四分位数</h5><p>一批数据按升序排序后为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其第 <span class="math inline">\(i\)</span> 位的四分位数<span class="math inline">\(Q_i \triangleq \frac{i(n+1)}{4},\ (i = 1,\2,\ 3)\)</span></p><h5 id="定义-1.12算术平均值">定义 1.12：算术平均值</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其算数平均值 <span class="math display">\[\overline{X}\triangleq\frac{1}{n}\sum_{i = 1}^{n}X_i\]</span></p><h5 id="定理-1.1算术平均值归零性">定理 1.1：算术平均值归零性</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，<span class="math inline">\(\overline{X}\)</span>为其算数平均值，则 <span class="math display">\[\sum_{i = 1}^{n}(X_i-\overline{X}) = 0\]</span></p><h5 id="定义-1.13加权算术平均值">定义 1.13：加权算术平均值</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，相应的权重为 <span class="math inline">\(\omega_1,\\omega_2\ ,…,\ \omega_n\)</span>，不失一般性，我们假设权重和为 <spanclass="math inline">\(1\)</span> ，则其加权算术平均值为 <spanclass="math display">\[\overline{X} = \sum_{i = 1}^{n}\omega_iX_i\]</span></p><h5 id="定义-1.14内四分位距">定义 1.14：内四分位距</h5><p>内四分位距 <span class="math inline">\(\triangleqQ_3-Q_1\)</span></p><h5 id="定义-1.15偏差平方和方差和标准差">定义1.15：偏差平方和，方差和标准差</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则数据的偏差平方和为每个数据与平均值偏差平方的和，即 <spanclass="math display">\[d^2\triangleq\sum_{i = 1}^{n}(X_i-\overline X)^2\]</span> 数据的方差 <span class="math inline">\(S^2\)</span>为偏差平方和的平均值 <span class="math display">\[S^2\triangleq {d^2\over n}\]</span> 数据的标准差 <span class="math inline">\(S\)</span>为方差的算术平方根 <span class="math display">\[S \triangleq \sqrt{S^2}\]</span></p><h5 id="定理-1.2偏差平方和计算公式">定理 1.2：偏差平方和计算公式</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，其方差为 <span class="math inline">\(S^2\)</span>，则<span class="math display">\[d^2= \sum_{i = 1}^{n}X_i^2-{(\displaystyle\sum_{i = 1}^nX_i)^2\over n}\]</span></p><h5 id="定义-1.16修正方差和标准差">定义 1.16：修正方差和标准差</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则数据的方差和标准差 <span class="math inline">\(S^2,\S\)</span> 为 <span class="math display">\[S^2 = {d^2\over n -1}\\S = \sqrt{S^2}\]</span></p><h5 id="定义-1.17变异系数">定义 1.17：变异系数</h5><p>样本的变异系数为样本标准差除以样本的均值</p><h5 id="定理-1.3算术平均值偏差极小性">定理1.3：算术平均值偏差极小性</h5><p>设数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，<span class="math inline">\(\overline{X}\)</span>为其算术均值，则算术平均值 <span class="math inline">\(\overlineX\)</span> 的偏差平方和最小，即 <span class="math display">\[\overline{X} = arg\min_{a}\sum_{i = 1}^{n}(X_i - a)^2\]</span></p><h5 id="定义-1.18矩">定义 1.18：矩</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，其 <span class="math inline">\(k\)</span> 阶原点矩定义为<span class="math inline">\((k\in\mathbb{N})\)</span> <spanclass="math display">\[A_k = {1\over n}\sum_{i = 1}^{n}x_i^k\]</span> 其 <span class="math inline">\(k\)</span> 阶中心矩定义为 <spanclass="math inline">\((k\in\mathbb{N})\)</span> <spanclass="math display">\[B_k = {1\over n}\sum_{i = 1}^{n}(X_i - \overline{X})^k\]</span></p><h5 id="定理-1.4矩表示">定理 1.4：矩表示</h5><p><span class="math display">\[B_k = \sum_{i = 0}^{n}C_n^i(-A_1)^iA_{n-i}\]</span></p><h5 id="定义-1.19偏度">定义 1.19：偏度</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其偏度 <span class="math inline">\(s^3\)</span> 为 <spanclass="math display">\[s^3\triangleq {B_3\over B_2^{1.5}}\]</span></p><h5 id="定义-1.20峰度">定义 1.20：峰度</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其峰度 <span class="math inline">\(s^4\)</span> 为 <spanclass="math display">\[s^4 = {B_4\over B_2^2}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Moment</tag>
      
      <tag>DIKW</tag>
      
      <tag>Order</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Network Layer</title>
    <link href="/2022/10/27/Computer%20Networking/OSI%20Model/OSI%20Network%20Layer/"/>
    <url>/2022/10/27/Computer%20Networking/OSI%20Model/OSI%20Network%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次网络层">OSI层次：网络层</h1><blockquote><p>关键词：路径选择、路由、寻址</p><p>刻画了寻址和最优路径选择</p><p>这些存在于地理上分离的网络</p></blockquote><h2 id="网络层概述">1. 网络层概述</h2><h3 id="网络层的责任">1.1. 网络层的责任</h3><ul><li><a href="">网络层</a>通过<ahref="https://zh.wikipedia.org/wiki/计算机网络">网络</a>传递数据</li><li>使用<strong>分层的</strong>寻址方案（不同于水平的MAC寻址）</li><li><ahref="https://baike.baidu.com/item/网段?fromModule=lemma_search-box">网段</a>与<ahref="https://baike.baidu.com/item/数据流/3002243">数据流</a>控制</li><li>减少<strong>拥塞</strong> (Reduce Congestion)</li><li>与其他网络连通</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005760.png" style="zoom:67%;" /></p><h3 id="面向连接的网络服务">1.2. 面向连接的网络服务</h3><p><ahref="https://baike.baidu.com/item/面向连接?fromModule=lemma_search-box"><strong>面向连接</strong></a>(ConnectionOriented)：在传输任何数据之前，在发送方和接收方之间建立连接。</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005779.png" style="zoom:50%;" /></p><blockquote><p>和<strong>面向连接</strong>类似的概念是<ahref="https://baike.baidu.com/item/电路交换/2472932"><strong>电路交换</strong></a>(Circuit Switching, CS) ，但是两者不是一个空间的概念</p></blockquote><ul><li>面向连接：首先与接受者建立连接，然后开始数据传输。所有的数据依次通过同一个通道，或者更常见的是，通过同一个虚拟电路</li><li>电路交换：</li></ul><h3 id="无连接网络服务">1.3. 无连接网络服务</h3><p>​ 在<ahref="https://baike.baidu.com/item/面向无连接?fromModule=lemma_search-box">无连接网络服务</a>(Connectionless Oriented) 中，是指通信双方不需要事先建立一条<ahref="https://baike.baidu.com/item/通信线路/1527630?fromModule=lemma_inlink">通信线路</a>，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线（每个包会被区别对待）进行传输。邮政系统是一个无连接的模式，天罗地网式的选择路线，天女散花式的传播形式；IP、<ahref="https://baike.baidu.com/item/UDP协议?fromModule=lemma_inlink">UDP</a>就是无连接协议的例子。</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005797.png" alt="" style="zoom:50%;" /></p><blockquote><p>和无连接网络类似的概念是<strong><ahref="https://baike.baidu.com/item/包交换技术?fromtitle=包交换&amp;fromid=9719811&amp;fromModule=lemma_search-box">分组交换技术</a></strong>(Packet switching technology)，但是两者也不是一个空间的概念</p></blockquote><ul><li>当数据包从源传递到目标时，它们可以：<ul><li>切换到不同的路径</li><li>不正常到达</li></ul></li><li>设备根据各种标准确定每个包的路径，有些函数可能因数据包而异</li></ul><h3 id="网络设备-路由器">1.4. 网络设备-路由器</h3><blockquote><p>关于路由器与路由协议更详细的内容可以查看<ahref="https://naturalifica.top/2022/10/10/Computer%20Networking/OSI%20Model/Routing%20&amp;%20Router/">这篇文章</a></p></blockquote><p>路由器的功能是：</p><ul><li><p>物理地互连<strong>网段</strong>形成逻辑段 或者 互联网络</p></li><li><p>根据IP地址做出逻辑决策</p></li><li><p>确定最佳路径</p></li><li><p>将数据包从传入端口切换到传出端口</p></li></ul><h2 id="ip-地址和子网">2. IP 地址和子网</h2><blockquote><p>一个难蚌的<ahref="https://zh.wikipedia.org/wiki/以鸟类为载体的网际协议">相关协议</a></p></blockquote><h3 id="ip-数据报">2.1. IP 数据报</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005829.png" style="zoom:60%;" /></p><ul><li><p><strong>版本</strong>——4位</p><ul><li>指的是IP协议的版本</li><li>目前的IP协议版本号为4（即<ahref="https://baike.baidu.com/item/IPv4?fromModule=lemma_search-box">IPv4</a>）</li></ul></li><li><p><strong>首部长度</strong>——4位</p><ul><li>可表示的最大数值是15个单位 (一个单位为4字节)，因此IP的首部长度的最大值是60字节，最小值是20字节</li></ul></li><li><p><strong>服务类型</strong>——8位</p><ul><li>用来区分服务以获得更好的服务，这个字段之前一直没有被人们使用</li><li>区分服务，Delay = 1 延迟小，Throughput = 1吞吐量大，Reliability = 1质量比较高，Cost = 1 最小代价</li></ul></li><li><p><strong>总长度</strong>——占16位</p><ul><li>指的是首部和数据之和的长度，单位为字节，因此数据报的最大长度为65536字节，总长度必须不超过<ahref="https://baike.baidu.com/item/最大传输单元?fromtitle=mtu&amp;fromid=508920&amp;fromModule=lemma_search-box">MTU</a>(Maximum Transmission Unit, 最大传输单元)</li></ul></li><li><p><strong>标识</strong> (identification)——16位</p><ul><li>它是一个计数器，用来产生数据报的标识</li></ul></li><li><p><strong>标志</strong>——3位</p><blockquote><p>注意：发送数据报过大，就要对其数据报分片处理，每一个分片都会含有一个标识（IP地址+ 标识），到达目的地要对其所有的分片进行重新组装；</p></blockquote><ul><li>最高位为0，标志字段<ahref="https://zhidao.baidu.com/question/1180225348239268619.html">MF</a>(More Fregment), MF = 1表示后面还有分片，MF = 0 表示最后一个分片；</li></ul></li><li><p><strong>片位移</strong>——13位</p><ul><li>指出：较长的分组在分片之后，某片在原分组中的相对位置，片位移以8个字节为偏移单位</li></ul></li><li><p><strong>生存时间</strong>——8位</p><ul><li>记为<a href="https://baike.baidu.com/item/TTL/130248">TTL</a> (TimeTo Live) 数据报在网络中可通过的路由器数的最大值</li></ul></li><li><p><strong>协议</strong>——8位</p><ul><li>指出此数据报携带的数据使用何种协议（TCP协议还是UDP协议）</li><li>以便目的主机的 IP 层将数据部分上交给哪个处理过程</li></ul></li><li><p><strong>首部检验和</strong>——16位</p><ul><li>只检验数据报的首部，不包括数据部分，这里不采用 CRC检验码而采用简单的计算方法</li></ul></li><li><p><strong>源地址和目标地址</strong>——8位</p><ul><li><strong>源地址</strong>：数据向外发送，发送机器本身的IP地址，也成为逻辑地址</li><li><strong>目的地址</strong>：数据具体要发送目标及其的IP地址</li></ul></li></ul><h3 id="ip地址">2.2. IP地址</h3><h4 id="ip-地址组成">2.2.1. IP 地址组成</h4><p>IP地址由32位<ahref="https://zh.wikipedia.org/wiki/二进制">二进制</a>数组成，为便于使用，常以XXX.XXX.XXX.XXX形式表现，每组XXX代表小于或等于255的10进制数，该表示方法称为<strong>点分十进制</strong>。IP地址由两部分组成：</p><ul><li><p>网络ID</p></li><li><p>由<strong><ahref="https://baike.baidu.com/item/ARIN?fromModule=lemma_search-box">ARIN</a></strong>(American Registry for Internet Numbers, 美国因特网号码注册中心)分配</p></li><li><p>标志设备连接到的网络</p></li><li><p>可以由<strong>前三个八位</strong>中的一个，两个，或者三个识别出</p></li><li><p>主机ID</p></li><li><p>由<strong><ahref="https://baike.baidu.com/item/网络管理员/595848">网络管理员</a></strong>(Network Administrator) 分配</p></li><li><p>标志了该网络中的被连接的设备</p></li><li><p>可以由<strong>后三个八位</strong>中的一个，两个，或者三个识别出(与网络ID互补)</p></li></ul><h4 id="ipv4-地址分类">2.2.2. IPv4 地址分类</h4><blockquote><p>IPv4 地址包括 ABCDE 五类</p><p>N表示Network，H表示Host</p></blockquote><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><strong>A类IPv4地址</strong></th><th style="text-align: center;"><strong>B类IPv4地址</strong></th><th style="text-align: center;"><strong>C类IPv4地址</strong></th><th style="text-align: center;"><strong>D类IPv4地址</strong></th><th style="text-align: center;"><strong>E类IPv4地址</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>网络标志位</strong></td><td style="text-align: center;">0</td><td style="text-align: center;">10</td><td style="text-align: center;">110</td><td style="text-align: center;">1110</td><td style="text-align: center;">11110</td></tr><tr class="even"><td style="text-align: center;"><strong>四个字节的含义</strong></td><td style="text-align: center;">N.H.H.H</td><td style="text-align: center;">N.N.H.H</td><td style="text-align: center;">N.N.N.H</td><td style="text-align: center;">N.N.N.N</td><td style="text-align: center;">N.N.N.N</td></tr><tr class="odd"><td style="text-align: center;"><strong>IP地址范围</strong></td><td style="text-align: center;">0.0.0.0 ~ 127.255.255.255</td><td style="text-align: center;">128.0.0.0 ~ 191.255.255.255</td><td style="text-align: center;">192.0.0.0 ~ 223.255.255.255</td><td style="text-align: center;">224.0.0.0 ~ 239.255.255.255</td><td style="text-align: center;">240.0.0.0 ~ 247.255.255.255</td></tr><tr class="even"><td style="text-align: center;"><strong>可用IP地址范围</strong></td><td style="text-align: center;">1.0.0.1 ~ 127.255.255.254</td><td style="text-align: center;">128.0.0.1 ~ 191.255.255.254</td><td style="text-align: center;">192.0.0.1 ~ 223.255.255.254</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><strong>是否可以分配给主机使用</strong></td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">是</td><td style="text-align: center;">否</td><td style="text-align: center;">否</td></tr><tr class="even"><td style="text-align: center;"><strong>网络数量（个）</strong></td><td style="text-align: center;">126 (<spanclass="math inline">\(2^7-2\)</span>)</td><td style="text-align: center;">16384 (<spanclass="math inline">\(2^{14}\)</span>)</td><td style="text-align: center;">2097152 (<spanclass="math inline">\(2^{21}\)</span>)</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td></tr><tr class="odd"><tdstyle="text-align: center;"><strong>每个网络中可容纳主机数（个）</strong></td><td style="text-align: center;">16777214 (<spanclass="math inline">\(2^{24}-2\)</span>)</td><td style="text-align: center;">65534 (<spanclass="math inline">\(2^{16}-2\)</span>)</td><td style="text-align: center;">254 (<spanclass="math inline">\(2^8-2\)</span>)</td><td style="text-align: center;">---</td><td style="text-align: center;">---</td></tr><tr class="even"><td style="text-align: center;"><strong>适用范围</strong></td><td style="text-align: center;">大量主机的大型网络</td><td style="text-align: center;">中等规模主机数的网络</td><td style="text-align: center;">小型局域网</td><td style="text-align: center;">留给IAB(Internet体系结构委员会)使用【组播地址】</td><tdstyle="text-align: center;">保留，仅作为搜索、Internet的实验和开发用</td></tr><tr class="odd"><td style="text-align: center;">备注</td><td style="text-align: center;">0.0.0.0为特殊地址，表示本网主机</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><tdstyle="text-align: center;">255.255.255.255为特殊地址，用于定向广播</td></tr></tbody></table><h4 id="主机数量">2.2.3. 主机数量</h4><ul><li>不同类别的主机最大数量是不同的</li><li>A类网络中最多有 16,777,214 个主机 (<spanclass="math inline">\(2^{24}–2\)</span>)</li><li>B类网络中最多有 65,534 个主机 (<spanclass="math inline">\(2^{16}–2\)</span>)</li><li>C类网络中最多有 254 个主机 (<spanclass="math inline">\(2^8–2\)</span>)</li><li>每个网络中的第一个地址（即主机号全为0）是预留的网络地址，表示本机所连接的<strong>网络地址</strong></li><li>最后一个地址（即主机号全为1）预留的，用于表示<strong>所有主机</strong></li></ul><h4 id="预留地4址">2.2.4. 预留地4址</h4><ul><li><p><strong>网络地址</strong></p></li><li><p>主机号部分地址全为0</p></li><li><p>A类网络地址实例: 113.0.0.0</p></li><li><p>网络中的主机只能在网络号相同的时候，与其它主机直接通讯</p></li><li><p><strong>广播地址</strong></p></li><li><p>用于给该网络中所有设备发送数据</p></li><li><p>广播IP地址是主机号全为1的地址</p></li><li><p>B类地址示例: 176.10.255.255</p></li><li><p>受限网络地址：255.255.255.255</p></li></ul><h4 id="ip寻址">2.2.5. IP寻址</h4><p><strong>私有地址空间</strong></p><p>有一些IP地址范围预留给<ahref="https://baike.baidu.com/item/私有IP/2216993">私有IP地址空间</a>。下面是IPv4地址下全部的私有IP地址空间</p><ul><li>10.0.0.0 ～ 10.255.255.255</li><li>172.16.0.0 ～ 172.31.255.255</li><li>192.168.0.0 ～ 192.168.255.255</li></ul><p><strong>为什么有了 IP 地址还要用 <ahref="https://zh.wikipedia.org/wiki/MAC地址">MAC 地址</a>?</strong></p><blockquote><p>①IP地址一般情况下容易修改和变动，具有随意性，不能在网络上固定标识一台设备；</p><p>②MAC地址一般情况出厂时由厂家烧录到网卡中，不容易修改，在局域范围内容易唯一定位一台设备。</p><p>③从拓扑结构和分层上分析，IP地址属于网络层，主要功能在广域网范围内路由寻址，选择最佳路由，而MAC地址在网络接口层要形成适合于网络媒体上传输的数据帧。</p><p>注意：标识一个设备的三种方式：① 域名访问（www.baidu.com，应用层）；②设备的IP地址访问（网络层）；③设备的MAC地址（在局域网当中唯一标识该设备，实际不用其访问，在网络接口层，具有固定的特性，不易发生紊乱现象）</p><p>参考文章: <ahref="https://blog.csdn.net/super_YC/article/details/72290931">IP协议及IP数据包详解</a></p></blockquote><p><strong>IP地址耗尽</strong> 和它的解决办法 :</p><blockquote><p>1981年，<ahref="https://zh.wikipedia.org/wiki/IETF">IETF</a>定义了32位IP地址的<ahref="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>。随着互联网的发展，网络位置（IPv4）渐渐被消耗殆尽，虽然当前的<ahref="https://zh.wikipedia.org/wiki/网络地址转换">网络地址转换</a>及<ahref="https://zh.wikipedia.org/wiki/无类别域间路由">无类别域间路由</a>等技术可延缓网络位置（IPv4）匮乏之现象，但为求解决根本问题，从1990年开始，<ahref="https://zh.wikipedia.org/wiki/互联网工程工作小组">互联网工程工作小组</a>开始规划<ahref="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>的下一代协议，除要解决即将遇到的IP地址短缺问题外，还要发展更多的扩展，为此IETF小组创建IPng，以让后续工作顺利进行。</p><p>1994年，各IPng领域的代表们于<ahref="https://zh.wikipedia.org/wiki/多倫多">多伦多</a>举办的IETF会议中，正式提议<strong>IPv6</strong>发展计划，该提议直到同年的11月17日才被认可，并于1996年8月10日成为IETF的草案标准，最终IPv6在1998年12月由互联网工程工作小组以互联网标准规范（RFC2460）的方式正式公布。</p></blockquote><ul><li><p><ahref="https://baike.baidu.com/item/nat/320024">NAT</a>（Network AddressTranslation, 网络地址转换）</p></li><li><p><ahref="https://baike.baidu.com/item/无类别域间路由/15758573">CIDR</a>（ClasslessInter-Domain Routing, 无类别域间路由）</p></li><li><p><ahref="https://baike.baidu.com/item/IPv6?fromModule=lemma_search-box">IPv6</a>（InternetProtocol Version 6, 互联网协议）</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimage-20221104221806891.png" alt="" style="zoom:40%;" /></p><h3 id="子网">2.3. 子网</h3><p>网络管理员有时候需要把网络划分成更小的网络，即<ahref="https://baike.baidu.com/item/子网/1186929">子网</a>(subnet)，来提供额外的灵活性</p><blockquote><p>从主机号的地址域借了几位用于表示子网地址域</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005963.png" style="zoom:67%;" /></p><h4 id="子网基础">2.3.1. 子网基础</h4><ul><li><p>子网是网络的小划分</p></li><li><p>提供寻址的灵活性</p></li><li><p>子网地址通常由网管分配</p></li><li><p>子网减少了广播域</p></li></ul><h4 id="子网的借位">2.3.2. 子网的借位</h4><blockquote><p>子网的借位指的是从主机位中借几位出来，作为子网位。即：<spanclass="math inline">\(N + H \rightarrow N + S + H&#39;\)</span></p><p>为什么至少要借两位 ？</p><p>取一位的话无法区分 <strong>subNetID</strong> 和<strong>masterNetID</strong>，如果你只借了一位来构造子网，那么你只有一个网络号0，以及广播号1</p></blockquote><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">主机域大小</th><th style="text-align: center;">最多借位</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Class A</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr class="even"><td style="text-align: center;">Class B</td><td style="text-align: center;">16</td><td style="text-align: center;">14</td></tr><tr class="odd"><td style="text-align: center;">Class C</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td></tr></tbody></table><h4 id="副产品浪费的地址">2.3.3. 副产品：浪费的地址</h4><p>我们必须在需要的子网数量，可接受的每个子网中主机的数量，和导致的地址浪费中，保持平衡。</p><blockquote><p>以C类网络为例</p></blockquote><table><thead><tr class="header"><th style="text-align: center;"><strong>借的位数</strong></th><th style="text-align: center;"><strong>构造的子网数量</strong></th><thstyle="text-align: center;"><strong>每个子网中主机的个数</strong></th><th style="text-align: center;"><strong>主机的总个数</strong></th><th style="text-align: center;"><strong>利用率</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">62</td><td style="text-align: center;">124</td><td style="text-align: center;">49%</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">30</td><td style="text-align: center;">180</td><td style="text-align: center;">71%</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">14</td><td style="text-align: center;">14</td><td style="text-align: center;">196</td><td style="text-align: center;">77%</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">30</td><td style="text-align: center;">6</td><td style="text-align: center;">180</td><td style="text-align: center;">71%</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">62</td><td style="text-align: center;">2</td><td style="text-align: center;">124</td><td style="text-align: center;">49%</td></tr></tbody></table><p>构造子网的数量 = <span class="math inline">\(2^{借的位数}−2\)</span>（注意要去掉全为 0 的网络号和全为 1 的广播地址）</p><h4 id="子网掩码">2.3.4. 子网掩码</h4><p><a href="https://baike.baidu.com/item/子网掩码/100207">子网掩码</a>(subnet mask) 决定了我们用多少位来构建网络，以及多少位描述主机地址</p><p><strong>特殊地</strong>，我们有：</p><ul><li><p>A类 IP 地址的子网掩码: 255.0.0.0</p></li><li><p>B类 IP 地址的子网掩码: 255.255.0.0</p></li><li><p>C类 IP 地址的子网掩码: 255.255.255.0</p></li></ul><p><strong>一般地</strong>，我们有：</p><ul><li>含子网的子网掩码:与主机位对应的都为0，与网络位和子网位对应的都为1</li></ul><h2 id="网络层设备">3. 网络层设备</h2><blockquote><p>在这里，网络层设备指的就是路由器</p><p>关于路由器与路由协议更详细的内容可以查看<ahref="https://naturalifica.top/2022/10/10/Computer%20Networking/OSI%20Model/Routing%20&amp;%20Router/">这篇文章</a></p></blockquote><ul><li>路由器的功能是路径选择。更详细地说，是基于<strong>链路带宽、距离、延迟</strong>等等因素来选择传递数据包<strong>到目的地的下一个路径</strong>。</li></ul><h3 id="ip-地址与路由器">3.1. IP 地址与路由器</h3><ul><li><p>IP 地址被应用在软件层面，用于指出设备所在的网络</p></li><li><p>路由器<strong>连接到网络</strong>，每一个网络必须有一个独特的<strong>网络号</strong>使得路由能成功地连接</p></li><li><p>独特的网络号包含于IP地址中，被分配给每一个连接到该网络的设备</p></li></ul><h3 id="路由接口">3.2. 路由接口</h3><p>​ 一个路由器通过<ahref="https://jingyan.baidu.com/article/4b52d702aa8bb3fc5c774b91.html">接口</a>连接到网络，接口也可能指<ahref="https://baike.baidu.com/item/IP网络路由技术/10619274">IP路由</a>(IP Routing) 中的一个端口。每一个接口都有一个独一无二的网络地址</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005036.png" style="zoom:50%;" /></p><p>​ 举例如下：</p><p><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgs202210291005068.png" /></p><h3 id="路由功能">3.4. 路由功能</h3><blockquote><p>以下图为例</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimage-20221104161759159.png" style="zoom: 33%;" /></p><ul><li><p>剥离框架中的数据链路报头（数据链路报头包括<strong>来源 MAC地址和目的 MAC 地址</strong>）</p></li><li><p>检查<strong>网络层地址</strong>来决定目的地网络</p></li><li><p>查询它的<strong><ahref="https://baike.baidu.com/item/路由表?fromModule=lemma_search-box">路由表</a></strong>(Routing Table)来决定使用哪一个接口来发送数据，使得数据可以到达目的地网络</p></li><li><p>通过B1接口发送数据，路由器会将数据封装在合适的数据链路框架(帧)中</p></li></ul><h3 id="ip地址分配">3.6. IP地址分配</h3><blockquote><p>这针对的是网络中的每一个节点，不仅仅是路由器</p></blockquote><ul><li><p><strong>静态地址分配</strong></p><ul><li><p>给每一个设备配置一个IP地址</p></li><li><p>但缺点也很明显：需要保留非常细致的记录以避免使用重复的IP地址</p></li></ul></li><li><p><strong>动态地址分配</strong></p><ul><li><p><ahref="https://baike.baidu.com/item/反向地址转换协议/2991811"><strong>RARP</strong></a>(Reverse Address Resolution Protocol, 反向地址转换协议)</p></li><li><p><ahref="https://baike.baidu.com/item/BOOTP?fromModule=lemma_search-box"><strong>BOOTP</strong></a>(Bootstrap Protocol, 引导程序协议)</p></li><li><p><ahref="https://baike.baidu.com/item/DHCP?fromModule=lemma_search-box"><strong>DHCP</strong></a>(Dynamic Host Configuration Protocol, 动态主机配置协议):这是最常使用的</p></li><li><p>etc.</p></li></ul></li></ul><h2 id="arp-协议">4. ARP 协议</h2><blockquote><p><ahref="https://baike.baidu.com/item/ARP/609343?fromModule=lemma_search-box">ARP</a>(Address Resolution Protocol, 地址解析协议)</p></blockquote><h3 id="作用">4.1. 作用</h3><p>​值得注意的是，发送方的设备必须同时有有<strong>目的设备的IP地址和MAC地址</strong>，才能与目的设备进行通讯。ARP使得一台电脑可以获取与一个IP地址相关的MAC地址。</p><h3 id="arp操作">4.2. ARP操作</h3><ul><li><p>发送设备<strong>广播询问</strong>同一网段下的所有设备的MAC地址(请求)</p></li><li><p>所有的设备进行IP地址匹配 (检查)</p></li><li><p>如果某一设备发现自己的IP地址符合请求报文中的IP地址，就对应主机回复自己的MAC地址(应答)</p></li><li><p>发送设备将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。(ARP缓存表中每个条目具有一定的生命周期)(缓存)</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005269.png" alt="" style="zoom:50%;" /></p></li></ul><p>​</p><blockquote><p>​ 我们不难发现，ARP是建立在网络中各个主机<strong>互相信任</strong>的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时<strong>不会检测该报文的真实性就会将其记入本机ARP缓存</strong>；由此攻击者就可以向某一主机发送<strong>伪ARP应答报文</strong>，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个<ahref="https://baike.baidu.com/item/ARP欺骗?fromModule=lemma_inlink">ARP欺骗</a>。</p></blockquote><h3 id="网际通讯">4.3. 网际通讯</h3><blockquote><p>一个平凡的问题是：怎么与不在一个物理网段的设备通讯？</p></blockquote><p>有两种常见的方法：</p><ul><li>默认网关 (Default Gateway)</li><li><ahref="https://blog.csdn.net/wangdongm123/article/details/103999173"><strong>默认网关</strong></a>是连接来源主机所处的网段的路由接口的IP地址</li><li>为了让一个设备可以给其它网段上的设备发送数据，来源设备将数据发送到默认网关</li><li>代理 ARP (Proxy ARP)</li><li><ahref="https://baike.baidu.com/item/代理ARP/9765556"><strong>代理ARP</strong></a>是ARP的一种变化形式</li><li>这种情况下，来源主机<strong>没有配置默认网关</strong>(有较大的局限性)</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005153.png" style="zoom:50%;" /></p><h2 id="路由与被动路由协议">5. 路由与被动路由协议</h2><h3 id="网络协议操作">5.1. 网络协议操作</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005511.png" alt="" style="zoom:50%;" /></p><h3 id="被动路由协议">5.2. 被动路由协议</h3><blockquote><p>什么是<ahref="https://baike.baidu.com/item/被动路由协议?fromModule=lemma_search-box">被动路由协议</a>(Passive Route protocol)</p><p>通俗地说，可路由表示这个协议的信息包格式能被路由器接受</p></blockquote><ul><li><strong>给网络层提供帮助</strong>的协议被称为被动 (routed)路由协议或可路由 (routable) 协议</li><li>IP是一个网络层协议。因此，它可以被互联网发送</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005547.png" alt="" style="zoom:50%;" /></p><blockquote><p>下图展示了访问可路由协议的步骤</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005604.png" alt="" style="zoom:50%;" /></p><h3 id="不可路由协议">5.3. 不可路由协议</h3><blockquote><p>什么是<ahref="https://blog.csdn.net/snlying/article/details/4221383">不可路由协议</a></p><p>通俗地说，不可路由表示这个协议的信息包格式不能被路由器接受</p></blockquote><ul><li><p>不可路由协议不支持<strong>网络层</strong></p><blockquote><p>不得不提到，网路层的一个任务就是进行网络之间的通讯，可以认为是“主机到主机” 的通讯；对比之下，传输层的重大任务就是 “进程到进程”的通讯</p></blockquote></li><li><p>其中最常见的不可路由协议是<ahref="https://baike.baidu.com/item/NetBEUI/611226">NetBEUI</a> (NetBiosEnhanced User Interface, 网络BIOS扩充用户接口)</p><ul><li>NetBEUI 是一个小、快、高效的协议，但只能在一个网段上运行</li></ul></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005558.png" style="zoom:50%;" /></p><h3 id="路由协议">5.4. 路由协议</h3><p><strong>路由 (routing) 协议</strong>决定了<strong>被动路由 (routed)协议</strong>前往目的地的<strong>路径</strong></p><p>用于路由器之间的协议，以便它们可以动态地获知路由信息，并将它们添加到路由表中。</p><h3 id="路由协议的分类">5.5. 路由协议的分类</h3><blockquote><p>路由协议可以分为静态路由和动态路由，也可以分成 <ahref="https://baike.baidu.com/item/距离矢量协议/2111053">DVP</a>(这就是大名鼎鼎的 <em>Ford-Fulkerson</em> 算法) 和 <ahref="https://baike.baidu.com/item/链路状态路由协议/1219386">LSP</a>(这也是大名鼎鼎的 <em>Dijkstra</em> 的 SPF 算法)</p><p>要将 <em>路由协议的动静态</em> 和 <em>IP地址分配的动静态</em>区别开来</p></blockquote><h4 id="静态和动态">5.5.1. 静态和动态</h4><ul><li>静态路由:<ul><li><strong><ahref="https://baike.baidu.com/item/网关/98992">网关</a></strong>手动将路由信息输入路由器</li></ul></li><li>动态路由:<ul><li>路由器可以联机 (on the fly) 交换彼此信息</li><li>使用如下的路由 (routing) 协议来更新路由信息<ul><li><strong>RIP, IGRP, EIGRP, OSPF</strong></li><li>上述协议会在下面有详细介绍</li></ul></li></ul></li></ul><p><strong>静态路由VS动态路由</strong></p><ul><li>静态路由:<ul><li>隐藏了部分互联网</li><li>测试网络中某个特定的链接</li><li>当只有一条路径到达目的网络时，便于维持路由表</li></ul></li><li>动态路由:<ul><li>维持路由表</li><li>定时更新路由信息</li><li>基于路由 (routing) 协议，共享路由信息</li><li>路由器可以适应变化的网络条件</li></ul></li></ul><h4 id="动态路由的-igp-和-egp">5.5.2. 动态路由的 IGP 和 EGP</h4><ul><li><p>IGP (Interior Gateway Protocols, 内部网关协议)</p><ul><li><p>RIP, IGRP, EIGRP, OSPF (下文会有介绍)</p></li><li><p>用于<ahref="https://baike.baidu.com/item/自治系统?fromModule=lemma_inlink">自治系统</a>，管理局域网中的路由器，如：校园网，公司内网……</p></li></ul></li><li><p>EGP (Exterior Gateway Protocols, 外部网关协议)</p><ul><li><p>EGP, <ahref="https://baike.baidu.com/item/边界网关协议/2987527">BGP</a> (BorderGateway Protocal, 边界网关协议)</p></li><li><p>是一种在<ahref="https://baike.baidu.com/item/自治系统?fromModule=lemma_inlink">自治系统</a>的相邻两个网关主机间交换路由信息的协议</p></li></ul></li></ul><blockquote><p>下图展示了 EGP 和 IGP 的直观区别</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005617.png" alt="pic25" style="zoom:67%;" /></p><h4 id="dvp-和-lsp">5.5.3. DVP 和 LSP</h4><ul><li><p>DVP (Distance Vector Protocol, 距离矢量协议)</p><blockquote><p>RIP 和 IGRP 都算是典型的 DVP （朴素的贪心算法）</p></blockquote><ul><li>从<strong>相邻的视角</strong>看网络拓扑</li><li>路由器之间添加距离矢量</li><li>周期性频繁的更新</li><li>复制一份路由表，传给相邻路由器</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005654.png" style="zoom:50%;" /></p></li><li><p>LSP (Link State Protocol, 链路状态协议)</p><blockquote><p>OSPF 算是典型的 LSP</p></blockquote><ul><li>了解整个网络拓扑</li><li>计算去其它路由的最短路径</li><li>由事件触发更新</li><li>把链路状态路由的更新信息发给其它路由</li></ul></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005749.png" style="zoom:50%;" /></p><h3 id="常见的路由协议">5.6. 常见的路由协议</h3><h4 id="rip">5.6.1. RIP</h4><blockquote><p><a href="https://baike.baidu.com/item/路由信息协议/2707187">RIP</a>(Route Information Protocol, 路由信息协议)是基于<strong>距离矢量算法</strong>的<strong>内部网关路由协议</strong>，利用跳数来作为计量标准。在带宽、配置和管理方面要求较低，主要适合于规模较小的网络中。也是目前<strong>最受欢迎</strong>的路由协议</p></blockquote><ul><li><p>跳数<strong>hop</strong>是唯一的度量标准</p><ul><li><p>最大跳数为15</p></li><li><p>每30秒更新一次</p></li><li><p>不总是选择最快路径</p></li><li><p>产生很多网络拥塞</p></li></ul></li><li><p>RIP v2 是 RIP v1的一个很重要的改进版本</p></li></ul><h4 id="igrp-eigrp">5.6.2. IGRP &amp; EIGRP</h4><blockquote><p><a href="https://baike.baidu.com/item/内部网关路由协议">IGRP</a>(Interior Gateway Routing Protocol, 内部网关路由选择协议) &amp; <ahref="https://baike.baidu.com/item/EIGRP">EIGRP</a> (Enhanced InteriorGateway Routing Protocol, 增强内部网关路由选择协议)是基于<strong>距离矢量算法</strong>的<strong>内部网关路由协议</strong>，且都是<ahref="https://baike.baidu.com/item/思科?fromModule=lemma_search-box"><strong>思科</strong></a>(Cisco) 专利</p></blockquote><ul><li><p>综合以延迟，带宽，负载，可靠性为度量标准</p><ul><li><p>最大跳数为255</p></li><li><p>每90秒更新一次</p></li></ul></li><li><p>EIGRP 是 IGRP的进阶版, 混合了路由（routing）协议</p></li></ul><h4 id="ospf">5.6.3. OSPF</h4><blockquote><p><a href="https://baike.baidu.com/item/组播扩展OSPF">OSPF</a> (OpenShortest Path First, 开放最短路径优先)是基于<strong>链路状态协议</strong>的<strong>内部网关路由协议</strong></p></blockquote><ul><li><p>综合以代价，速度，可靠性，安全性为衡量</p></li><li><p>由事件触发更新</p></li></ul><h2 id="vlsm">7. VLSM</h2><blockquote><p>什么是 <a href="">VLSM</a> (Variable Length Subnet Mask,可变长子网掩码)</p></blockquote><ul><li>VLSM 指的是允许一个自治系统使用不同的子网掩码</li><li>与之相对的概念是<strong>有类路由</strong>：一个网络只能使用一个子网掩码</li></ul><h3 id="vlsm概述">7.1. VLSM概述</h3><ul><li><p>有了VLSM，网管可以在<strong>少量主机的网络上使用长子网掩码</strong>，<strong>大量主机的网络上使用短子网掩码</strong></p></li><li><p>如果路由协议允许VLSM：</p><ul><li><p>在网络连接上使用一个30位的子网掩码，255.255.255.252</p></li><li><p>给用户网络一个24位的掩码，255.255.255.0</p></li><li><p>或者是22位的掩码，255.255.252.0，给有着近1000用户的网络</p></li></ul></li><li><p>优点:</p><ul><li><p>更有效地使用IP地址</p></li><li><p>使用<ahref="https://baike.baidu.com/item/路由汇聚?fromtitle=路由汇总"><strong>路由汇总</strong></a>的能力更强</p></li></ul></li><li><p>支持 VLSM 的路由协议:</p><ul><li><p>OSPF</p></li><li><p><a href="https://baike.baidu.com/item/is-is/930474">IntegratedIS-IS</a> (Integrated Intermediate System to Intermediate System,集成化中间系统到中间系统)</p></li><li><p>EIGRP增强内部网关路由选择协议</p></li><li><p>RIP v2</p></li><li><p>静态路由 (显然动态路由是不支持VLSM的)</p></li></ul></li></ul><p><strong>过去建议不要使用第一个和最后一个子网，但是我们可以在Cisco IOSver12.0中使用子网 0</strong></p><p><strong>在 IOS ver12.0 中, 思科路由器默认使用子网 0</strong></p><blockquote><p><strong>router(config)#</strong>no ip subnet-zero</p></blockquote><h3 id="vlsm的优势">7.2. VLSM的优势</h3><ul><li><p>VLSM允许一个组织在一个网络地址空间，使用不只一个子网掩码</p></li><li><p>使用 VLSM通常被理解为“给子网划分子网”，可以用来使得<strong>寻址效率最大化</strong></p></li><li><p>VLSM 是帮助<strong>缩小 IPv4 和 IPv6之间差距</strong>的修正之一</p></li></ul><h3 id="示例">7.3. 示例</h3><p>  已知一个C类地址192.168.10.0/24 (表示前24位为网络号)已经被分配，珀斯、悉尼、新加坡分别有一个连接到KL的广域网。珀斯需要60个主机，KL需要28个主机，悉尼和新加坡各需要12个主机。</p><p>  为了计算VLSM子网和各自的主机数，在地址范围中<strong>先分配最大的需求</strong>。需求水平应该<strong>按照从大到小的顺序排列</strong>。</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005783.png" alt="" style="zoom:67%;" /></p><p><strong>步骤一</strong></p><p>  珀斯需要 <span class="math inline">\(60\)</span> 个主机。用 <spanclass="math inline">\(6\)</span> 位，因为这样有 <spanclass="math inline">\(2^6-2=62\)</span>个可用主机地址，因此第四个八位中的前两位将表示/26的扩展网络前缀，剩余的<span class="math inline">\(6\)</span> 位用来表示主机地址</p><p>  将VLSM用在地址192.168.10.0/24上，有：</p><blockquote><p>IP: 192.168.10.00hhhhhh /26</p><p>SM: 255.255.255.192 (11000000)</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005812.png" style="zoom:67%;" /></p><p><strong>步骤二</strong></p><p>  KL 需要 <span class="math inline">\(28\)</span> 个主机。在192.168.10.63/26 后，下一个可用的地址是 192.168.10.64/26。因为需要 <spanclass="math inline">\(28\)</span> 个主机，所以需要 <spanclass="math inline">\(5\)</span> 位表示主机地址，这样有 <spanclass="math inline">\(2^5-2=30\)</span> 个可用的主机。因此需要 <spanclass="math inline">\(5\)</span> 位来表示主机，<spanclass="math inline">\(3\)</span> 位用于/27的扩展网络前缀</p><p>  将VLSM使用在192.168.10.64/26上，有：</p><blockquote><p>IP: 192.168.10.010hhhhh /27</p><p>SM: 255.255.255.224 (11100000)</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005902.png" style="zoom:60%;" /></p><p><strong>步骤三</strong></p><p>  现在悉尼和新加坡各需要12个主机，下一个可用地址从192.168.10.96/27开始。因为需要12个主机，所以需要4位表示主机地址，有<span class="math inline">\(2^4-2=14\)</span>个可用地址。因此4位代表主机，4位用于/28的扩展网络前缀</p><p>  将VLSM用在192.168.10.96/27上，有：</p><blockquote><p>192.168.10.0110hhhh /28</p><p>255.255.255.240 (11110000)</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005210.png" style="zoom:60%;" /></p><p><strong>步骤四</strong></p><p>  现在给<strong>广域网</strong>分配链接地址，记住，每个广域网链接需要<span class="math inline">\(2\)</span>个IP地址，下个可获取的子网是192.168.10.128/28。因为每个广域网链接需要<span class="math inline">\(2\)</span> 个网络地址，所以 <spanclass="math inline">\(2\)</span> 位用于表示主机，有 <spanclass="math inline">\(2^2-2=2\)</span> 个可用地址。因此需要 <spanclass="math inline">\(2\)</span> 位表示链接，<spanclass="math inline">\(6\)</span> 位表示 /30 的扩展网络前缀</p><p>  将VLSM用在192.168.10.128/28上，有：</p><blockquote><p>192.168.10.100000hh /30</p><p>255.255.255.250 (11111100)</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005471.png" style="zoom:60%;" /></p><p><strong>result</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005565.png" alt="pic33" style="zoom:67%;" /></p><ul><li><p>只有<strong>没有被使用的子网</strong>可以被进一步划分子网</p></li><li><p>如果一个子网的任何地址被使用了，那么这个子网不能再被划分</p></li></ul><h3 id="路由聚合">7.4. 路由聚合</h3><blockquote><p><ahref="https://baike.baidu.com/item/路由聚合/5322155?fr=aladdin">路由聚合</a>(Route Summarization)是让路由选择协议能够<strong>用一个地址通告众多网络</strong>，旨在缩小路由器中路由选择表的规模，以节省内存，并缩短IP对路由选择表进行分析以找出前往远程网络的路径所需的时间的方法。</p></blockquote><p><strong>CIDR (无类别域间路由)</strong> 和 <strong>VLSM</strong>的使用，不仅防止了地址浪费，还促进路由聚合</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005575.png" style="zoom:60%;" /></p><p><strong>示例</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005655.png" style="zoom:60%;" /></p><p><strong>计算</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005742.png" style="zoom:60%;" /></p><p><strong>优点</strong></p><ul><li><p>减少路由表条目数</p></li><li><p>用于隔离拓扑的变化</p></li><li><p>为了让聚合正确工作，要仔细地在层次结构中分配地址，使得汇总的地址分享同样的高位比特</p></li><li><p>VLSM允许路由聚合，通过将聚合完全基于左边共享的高位，来增加灵活性，即使网络是不连续的。</p></li></ul><h2 id="icmp">8. ICMP</h2><h3 id="一些概念">8.1. 一些概念</h3><blockquote><p>ICMP（Internet Control Message Protocol, 因特网控制报文协议）是<ahref="https://baike.baidu.com/item/TCP%2FIP协议簇?fromModule=lemma_inlink">TCP/IP协议簇</a>的一个子协议，用于在IP<ahref="https://baike.baidu.com/item/主机/455151?fromModule=lemma_inlink">主机</a>、<ahref="https://baike.baidu.com/item/路由?fromModule=lemma_inlink">路由</a>器之间传递<strong>控制消息</strong>。控制消息是指<strong>网络通不通、<ahref="https://baike.baidu.com/item/主机/455151?fromModule=lemma_inlink">主机</a>是否可达、<ahref="https://baike.baidu.com/item/路由/363497?fromModule=lemma_inlink">路由</a>是否可用</strong>等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p>ICMP 报文作为 IP层数据报的数据，加上<strong>数据报的首部</strong>，组成 IP数据报发送出去。提高了 IP 数据报交付成功的机会</p></blockquote><h3 id="icmp报文的格式">8.2. ICMP报文的格式</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005795.png" style="zoom:67%;" /></p><h3 id="两种icmp报文">8.3. 两种ICMP报文</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005858.png" alt="" style="zoom:60%;" /></p><h3 id="目的站不可到达">8.4. 目的站不可到达</h3><ul><li><p><strong>网络不可到达</strong>(net unreachable)</p></li><li><p><strong>主机不可到达</strong>(host unreachable)</p></li><li><p><strong>协议不可到达（</strong>protocol unreachable）</p></li><li><p><strong>端口不可到达（</strong>port unreachable）</p></li><li><p><strong>源路由选择不能完成（</strong>source routefailed）</p></li><li><p><strong>目的网络不可知（</strong>unknown destinationnetwork）</p></li><li><p><strong>目的主机不可知</strong>（unknown destinationhost）</p></li></ul><h3 id="icmp差错报告报文的数据字段的内容">8.5.ICMP差错报告报文的数据字段的内容</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005892.png" style="zoom:67%;" /></p><h3 id="不应发送icmp差错报告报文的几种情况">8.6.不应发送ICMP差错报告报文的几种情况</h3><ul><li><p>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</p></li><li><p>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP差错报告报文</p></li><li><p>对具有多播地址的数据报都不发送 ICMP 差错报告报文</p></li><li><p>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送 ICMP差错报告报文</p></li></ul><h3 id="ping">8.7. PING</h3><blockquote><p><ahref="https://baike.baidu.com/item/ping/6235?fromModule=lemma_search-box">PING</a>(Packet InterNet Groper, 因特网包探索器) 是一种<ahref="https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink">因特网</a>包探索器，用于测试<strong>网络连接量</strong>的程序。Ping是工作在<ahref="https://baike.baidu.com/item/%20TCP%2FIP/214077?fromModule=lemma_inlink">TCP/IP</a>网络体系结构中<ahref="https://baike.baidu.com/item/应用层/16412033?fromModule=lemma_inlink">应用层</a>的一个服务命令，测试目的站是否可达及了解其有关状态</p></blockquote><ul><li><p>PING 是用 ICMP 的 "Echo request" 和 "Echo reply"消息来实现的</p></li><li><p>PING 使用了 ICMP 回送请求与回送回答报文</p></li><li><p>PING 是<strong>应用层直接使用网络层</strong> ICMP的例子，它<strong>没有通过运输层</strong>的 TCP或UDP</p></li></ul><blockquote><p>可见，上层可以<strong>跳过邻近的下层</strong>而直接使用底层协议，未必要一层一层地自顶向下。</p></blockquote><h2 id="移动ip">9. 移动IP</h2><h3 id="基本概念">9.1. 基本概念</h3><blockquote><p><ahref="https://baike.baidu.com/item/移动IP?fromModule=lemma_search-box">移动IP</a>(Mobile IP) 是由<ahref="https://baike.baidu.com/item/互联网工程任务组?fromModule=lemma_inlink">互联网工程任务组</a>(IETF)制定的一种网上传输协议标准。由于移动终端的互联网接入点会不断发生变化，所以其IP地址在两方面发生分离，一是<strong>移动节点需要一种机制来唯一标识自己</strong>，另一是需要这种标识不会被用来<ahref="https://baike.baidu.com/item/路由?fromModule=lemma_inlink">路由</a>。移动IP便是为了能让移动节点能够分离IP地址这两方面功能，而又不彻底改变现有互联网的结构而设计。</p></blockquote><ul><li><p>移动 IP让电脑可以在从一个因特网接入点换到另一个接入点的时候，保持网络连接</p></li><li><p>移动 IP 和 nomadic (不定) IP 是不同的:</p></li><li><p>移动 IP可以<strong>无视接入点的变化，自动保持电脑的网络</strong></p></li><li><p>不定 IP在接入点变化时，必须<strong>先停止连接，然后初始化新的电脑连接</strong></p></li></ul><h3 id="移动ip的运作">9.2. 移动IP的运作</h3><ul><li><strong>本地网络</strong>：移动节点被分配给名为本地网络 (homenetwork)的特定网络,在该网络里名为本地地址的IP地址是<strong>静态</strong>的.</li><li><strong>外部网络</strong>：移动节点移至另一个网络，该网络被认为是此主机的外部网络。</li><li><strong>外部代理</strong>：移动节点通过网络节点(路由器)注册，如果路由器在外部网络，名为外部代理。</li></ul><p>移动节点与用户本地网络的、名为本地代理的类似代理通信,将移动节点的<strong>转交地址</strong>(care-of address)给予<strong>本地代理</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005928.png" style="zoom:70%;" /></p><h3 id="转交地址">9.3. 转交地址</h3><p>移动 IP 提供<strong>两种获取转交地址的模式</strong></p><h4 id="外地代理转交地址">9.3.1. 外地代理转交地址</h4><ul><li><p>该地址通常是发送通告的外地代理的 IP 地址</p></li><li><p>通过代理通告消息被通告给移动节点</p></li><li><p>外地代理是隧道的端点</p></li><li><p>外地代理通过隧道接收数据报时，会对收到的数据报解除封装。然后，外地代理会将内部数据报传送到移动节点</p></li><li><p>许多移动节点可以共用同一转交地址</p></li></ul><h4 id="协同定位转交地址">9.3.2. 协同定位转交地址</h4><ul><li><p>由移动节点通过一些方法 (e.g. DHCP) 获取，作为自身临时IP</p></li><li><p>移动节点充当隧道的端点</p></li><li><p>移动节点对通过隧道传来的数据报解除封装</p></li><li><p>协同定位转交地址可使移动节点在没有外地代理的情况下正常工作</p></li><li><p>如果某个移动节点正在使用协同定位的转交地址，则该移动节点必须与该转交地址处于同一网段。否则，发往该转交地址的数据报将无法传送</p></li></ul><h3 id="基本功能">9.4. 基本功能</h3><h4 id="发现">9.4.1. 发现</h4><blockquote><p>移动节点使用发现程序来标识期望的本地代理和外部代理</p><p>使用ICMP协议</p></blockquote><ul><li><p>移动节点可能在IP层不知道的情况下，由于某些切换机制的作用，从一个网络移到另一个网络。</p></li><li><p>代理发现进程的目的是使代理能检测到这样的移动</p></li><li><p>作为代理的路由器或其他网络节点，周期性发布带广播扩展的路由器广播ICMP报文。报文包括路由器的IP地址</p></li><li><p>移动节点监听这些广播报文。将路由器的网络部分与自身本地地址的网络部分比较，如果不匹配就说明移动节点在外部网络</p></li><li><p>如果移动节点未能接收到代理信息，允许其发布一个ICMP路由器请求报文来寻求路由器响应</p></li></ul><h4 id="注册">9.4.2. 注册</h4><blockquote><p>移动节点使用认证注册程序将它的转交地址告知它的本地代理</p><p>用UDP协议</p></blockquote><ul><li><p>注册程序的不安全性</p></li><li><p>移动IP被设计成能抵挡两类攻击</p></li><li><p>一个节点可能伪装成外部代理,并向本地代理发送注册请求,以求将目的为移动节点的通信转到自己.</p></li><li><p>恶意代理可能重发旧的注册报文,有效地将移动节点由网络中除去</p></li><li><p>为达到报文认证,每个注册请求和回应包含认证扩充</p></li></ul><h4 id="隧道">9.4.3. 隧道</h4><blockquote><p>用于将IP数据报由本地地址发至转交地址</p><p>使用IP协议</p></blockquote><ul><li><p>将原来整个数据报封装入一个首部带有转交地址的新IP数据报中。</p></li><li><p>隧道将原有的IP报文作为载荷，在外面包上一层新的IP包头，转换成为一个新的IP报文</p></li><li><p>在一定程度上提高了安全性</p></li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005976.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ queue</title>
    <link href="/2022/10/26/C++%20Basic/STL%20Containers/C++%20queue/"/>
    <url>/2022/10/26/C++%20Basic/STL%20Containers/C++%20queue/</url>
    
    <content type="html"><![CDATA[<p>queue是一种容器转换器模板，调用<code>#include&lt; queue&gt;</code>即可使用队列类。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="queue-初始化">2. queue 初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;Type, Container&gt; <span class="hljs-comment">//(&lt;数据类型，容器类型&gt;）</span><br></code></pre></td></tr></table></figure><p>初始化时必须要有数据类型，容器可省略，省略时则默认为<ahref="https://so.csdn.net/so/search?q=deque&amp;spm=1001.2101.3001.7020">deque</a>类型</p><p><strong>注意：不能用vector容器初始化queue</strong></p><p>因为<code>queue</code>转换器要求容器支持<code>front(), back(), push_back()</code>及<code>pop_front()</code>，说明<code>queue</code>的数据从容器后端入栈而从前端出栈。所以可以使用<code>deque（double-ended queue，双端队列）</code>和<code>list</code>对<code>queue</code>初始化，而<code>vector</code>因其缺少<code>pop_front()</code>，不能用于<code>queue</code>。</p><p>常见的初始化实例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>queue&lt;<span class="hljs-type">double</span>&gt; q2;  <br>queue＜<span class="hljs-type">char</span>＞ q3；<br><span class="hljs-comment">//默认为用deque容器实现的queue；</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="queue-常用函数">3. queue 常用函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//在队尾插入一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//删除队列第一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中元素个数</span><br><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//如果队列空则返回true</span><br><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中的第一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中最后一个元素</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="queue-使用实例">4. queue 使用实例</h4><ol type="1"><li><code>push()</code>在队尾插入一个元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>//输出 <span class="hljs-built_in">first</span><br><br>C++<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>pop()</code> 将队列中最靠前位置的元素删除，没有返回值</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>// 输出 <span class="hljs-built_in">second</span> <br>// 因为 <span class="hljs-built_in">first</span> 已经被<span class="hljs-built_in">pop</span>（）函数删掉了<br><br>C++<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>size()</code> 返回队列中元素个数</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">queue &lt;string&gt; q;<br>q.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.<span class="hljs-keyword">size</span>()&lt;&lt;endl;<br><br><span class="hljs-comment">//输出2，因为队列中有两个元素</span><br><br>C++<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>empty()</code> 如果队列空则返回<code>true</code></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">queue &lt;string&gt; q;<br>cout&lt;&lt;q.empty()&lt;&lt;endl;<br>q.push(<span class="hljs-string">&quot;first&quot;</span>);<br>q.push(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.empty()&lt;&lt;endl;<br><br><span class="hljs-regexp">//</span>分别输出<span class="hljs-number">1</span>和<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span>最开始队列为空，返回值为<span class="hljs-number">1</span>（ture）；<br><span class="hljs-regexp">//</span>插入两个元素后，队列不为空，返回值为<span class="hljs-number">0</span>（false）；<br><br>C++<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>front()</code> 返回队列中的第一个元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>// 第一行输出<span class="hljs-built_in">first</span>；<br>// 第二行输出<span class="hljs-built_in">second</span>，因为<span class="hljs-built_in">pop</span>（）已经将<span class="hljs-built_in">first</span>删除了<br><br>C++<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li><code>back()</code> 返回队列中最后一个元素</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">queue &lt;string&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br><br><span class="hljs-comment">//输出最后一个元素second</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="参考文章">5. 参考文章</h4><ol type="1"><li><ahref="https://blog.csdn.net/KEPROM/article/details/109744379">C++队列queue用法详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Data Link Layer</title>
    <link href="/2022/10/26/Computer%20Networking/OSI%20Model/OSI%20Data%20Link%20Layer/"/>
    <url>/2022/10/26/Computer%20Networking/OSI%20Model/OSI%20Data%20Link%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次数据链路层">OSI层次：数据链路层</h1><blockquote><p>关键词：帧、介质访问控制</p><p>刻画了通过物理链路提供可靠的数据传输的过程</p></blockquote><h2 id="数据链路层概述">1. 数据链路层概述</h2><h3 id="概述">1.1. 概述</h3><blockquote><p>如何在不稳定的链路上传输数据？</p><p>如下图：Node 指的是网络中所有的路由器和主机；Link指的是连接相邻节点的通道</p></blockquote><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211021749708.png" alt="" style="zoom: 33%;" /></p><ul><li><ahref="https://baike.baidu.com/item/数据链路层/4329290#:~:text=数据链路层是%20OSI参考模型%20中的第二层，介乎于%20物理层%20和%20网络层%20之间%E3%80%82,数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自物理层来的%20数据%20可靠地%20传输%20到%20相邻节点%20的目标机网络层%E3%80%82%20数据链路层定义了在单个链路上如何传输数据%E3%80%82">数据链路层</a>协议定义了：链路上数据交换的<strong>格式</strong>和 链路上两个<strong>节点</strong>的行为</li><li>数据链路层提供：对网络介质的访问 和 通过介质的物理传输</li><li>数据链路层最基本的服务是将源自物理层来的<ahref="https://baike.baidu.com/item/数据/5947370?fromModule=lemma_inlink">数据</a>可靠地<ahref="https://baike.baidu.com/item/传输/7078195?fromModule=lemma_inlink">传输</a>到<ahref="https://baike.baidu.com/item/相邻节点/22061788?fromModule=lemma_inlink">相邻节点</a>的目标机网络层。</li></ul><h3 id="lans-和数据链路层">1.2. LANS 和数据链路层</h3><h4 id="主要任务">1.主要任务：</h4><ul><li>错误通知</li><li>网络拓扑</li><li>数据流控制</li></ul><h4id="第一层和第二层之间的不同之处">2.第一层和第二层之间的不同之处</h4><ul><li>第一层不能和更高层沟通，第二层通过 <strong><ahref="https://baike.baidu.com/item/LLC协议/9441993">LLC</a></strong>(Logic Link Control, 逻辑链路控制) 与上层沟通</li><li>第一层根据传输介质发送信号，第二层通过 <strong><ahref="https://baike.baidu.com/item/介质访问控制/10081534">MAC</a></strong>(Media Access Control，介质访问控制) 发送信号</li><li>第一层不能命名或定义主机，第二层有命名过程</li><li>第一层只能描述比特流，第二层用帧 (frame) 组织比特</li></ul><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202211021803251.png" alt="" style="zoom: 33%;" /></p><h3 id="第二层提供的服务">1.3. 第二层提供的服务</h3><p>三个由 LLC 提供给网络层的服务:</p><ul><li>无应答的无连接服务（不需要对方同意）用于：可靠的链路(上层来保证数据正确性)、实时任务、绝大部分用于LAN</li><li>有应答的无连接服务，用于：不可靠的链路，如无线网络<ul><li>确认会降速（降低50%）</li></ul></li><li>有应答的连接服务，比如：蓝牙</li></ul><h3 id="在普通-lan-中的-mac">1.4. 在普通 LAN 中的 MAC</h3><p>注意这里的 <strong>以太网</strong>，<strong>令牌环</strong> 和<strong>FDDI</strong> 指的都是 <strong>LAN</strong> 的类型</p><p>以太网 (IEEE802.3)：逻辑总线拓扑 (信息流在线性总线上)和物理星型或扩展星型 (布线是星型)</p><p>令牌环 (IEEE802.5)：逻辑环形拓扑 (信息流在环中) 和一个物理星型(布线是星型)</p><p>FDDI (Fiber DistributedData Interface Network)：逻辑环形拓扑(信息流在环中) 和物理双环拓扑 (布线是双环形)</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002465.png" style="zoom:67%;" /></p><h3 id="mac-的访问方式">1.5. MAC 的访问方式</h3><h4 id="两个宽泛的种类">1.5.1. 两个宽泛的种类：</h4><ul><li>决定性-<strong>轮流</strong>：令牌环 和 FDDI</li><li>非决定性 (概率性)-<strong>先来先服务</strong>：以太网 /IEEE802.3</li></ul><h4 id="决定性mac协议">1.5.2. 决定性MAC协议：</h4><ul><li>一个特殊的数据令牌在环中循环</li><li>当主机收到令牌，它可以传输数据而不是令牌，这叫抓住令牌</li><li>当被传输的帧，传了一圈回到发射机处，站点会发射一个新令牌，原来的帧会从环上被抛弃</li></ul><h4 id="非决定性mac协议">1.5.3. 非决定性MAC协议：</h4><ul><li>这个MAC协议被称为，带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)<strong><em>Carrier</em></strong> <strong><em>Sense Multiple Access withCollision Detection (CSMA/CD</em></strong>)（考点！！！！！！）</li></ul><p>为了使用这个分享介质的技术，以太网允许网络设备仲裁传输的权利</p><h3 id="lan传输方式">1.6. LAN传输方式</h3><p><strong>单播</strong> (发送方只有一个人):—收到的帧的MAC地址与本站硬件地址相同</p><p><strong>多播</strong>: 发送给本局域网上部分站点的帧</p><p><strong>广播</strong>: 发送给本局域网上所有站点的帧</p><h2 id="以太网-和-csmacd">2. 以太网 和 CSMA/CD</h2><h3 id="lan标准">2.1. LAN标准</h3><ol type="1"><li>定义了<strong>物理介质</strong>和用于将设备连接到介质的连接器</li><li>定义了设备在数据链路层通讯的方式</li><li>数据链路层定义了数据怎样通过物理介质传输</li><li>数据链路层也定义了，在通信使用同一个通道去上层时，却用了不同的上层协议的情况下，怎样封装使用了特定协议的通信</li><li>数据链路层由 IEEE 分成了两个部分：<ul><li><strong>介质访问控制</strong> Media <strong>Access Control</strong><strong><em>(MAC)</em></strong> (向下层介质传输)</li><li><strong>逻辑链路控制</strong> Logical <strong>Link Control</strong><strong><em>(LLC)</em></strong> (向上层网络传输)</li></ul></li></ol><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002603.png" style="zoom:50%;" /></p><h3 id="mac子层重要考点">2.2. MAC子层（重要考点！！）</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002629.png" style="zoom:50%;" /></p><p>MAC 子层是帧中的域</p><ol type="1"><li>报头</li></ol><p>由0、1交替出现的开头，被称为报头 (10101011)以字节（byte）为单位（7+1）</p><p>报头（preamble）通知接收站，帧已经来了</p><ol type="1"><li>目的地址和源地址域</li></ol><p>源地址：通常是一个单播地址</p><p>目的地址：单播，多播，广播（48位）</p><p>目的地址在源地址之前：快速转发</p><ol type="1"><li>长度域暗示了这个域后面跟着的数据的字节，并先于帧校验序列域</li></ol><p><strong>由于数据长度可计算，改为type</strong></p><p><strong>小于0x0600表示length，大于0x0600表示type</strong>（0x0600=1536B）</p><ol type="1"><li>数据域包括你想要发送的信息</li></ol><p>数据域长度可变，最大是1500字节，最小是46字节</p><p>6+6+2+46+4=64<strong>确保发送一次数据占满100m双绞线，不会同时发送</strong></p><ol type="1"><li>FCS域（4字节）包括了一个循环冗余校验值cyclic redundancy check</li></ol><p>发送设备发送CRC</p><p>接受设备重新计算CRC来检查传输中帧可能受到的损失</p><h3 id="llc子层">2.3. LLC子层</h3><p>LLC子层管理通过一条链路上设备的通讯</p><p>LLC被定义在IEEE 802.2说明书中，支持无连接和面向连接的服务</p><p>LLC子层允许数据链路层的一部分，运作独立于已有技术</p><p>一个单独的LLC子层可以和不同的MAC子层相配</p><h3 id="mac地址的十六进制数字">2.4. MAC地址的十六进制数字</h3><p>MAC地址有48位，通常表示为12个十六进制</p><p>IEEE要求，前6个十六进制数（从左到右）指出制造商或供应商的身份，还包括了组织唯一标识符</p><p>剩下的6个十六进制数，由特定的供应商管理，包括接口编号</p><p><strong>对应MAC子层的目的地址</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002694.png" style="zoom:120%;" /></p><h3 id="以太网802.3广播">2.5. 以太网802.3广播</h3><ul><li><p>一种特殊的MAC地址</p></li><li><p>广播（所有端口转发，做成总线的方式）</p></li><li><p>MAC目的地址: <strong>全是1(FFFF.FFFF.FFFF)</strong></p></li><li><p>广播可以通过不必要的打断，严重影响站点的表现</p></li><li><p>所以广播仅在一下情况应该被使用：</p><ul><li><p>目的地的MAC地址未知</p></li><li><p>目的地是全体主机</p></li></ul></li></ul><h3 id="组帧framing">2.6. 组帧framing</h3><ul><li><p>组帧是数据链路层封装的过程</p></li><li><p>帧是第二层的协议数据单元</p></li><li><p>帧的部分叫做域，每个域由字节构成</p></li></ul><h3 id="以太网mac-csmacd历史">2.7. 以太网MAC-CSMA/CD：历史</h3><p>以太网传输数据时，所有的PC都会接收数据，再根据需求考虑是否丢弃数据</p><p>JAM SIGNAL：冲突信号，32位或者更多的1，所有的设备都会接收该信号</p><h4 id="csmacd传输流程">CSMA/CD传输流程</h4><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002703.png" style="zoom:50%;" /></p><h2 id="无线lan和csmacd">3. 无线LAN和CSMA/CD</h2><h3 id="无线lan标准">3.1. 无线LAN标准</h3><p><ahref="https://baike.baidu.com/item/海蒂·拉玛/10933854">一个小故事</a></p><ul><li>IEEE 802.11<ul><li>一个关键技术：直接序列扩频 Direct Sequence Spread Spectrum(DSSS)</li><li>DSSS 适用于操作在1到2 Mbps范围内的无线设备</li><li>DSSS 可能操作高达11 Mbps 但超过2Mbps的操作是不兼容的</li><li><strong>WIFI从此产生</strong></li></ul></li><li>IEEE 802.11b<ul><li>也叫 Wi-Fi™</li><li>它将传输能力提升至11 Mbps</li><li>所有802.11b系统都是向后兼容的，所以他们也支持802.11的 1~2Mbps数据传输率</li><li>通过使用802.11一个不同的编码技术获得更高的数据吞吐率</li><li>操作在2.4 GHz之内</li></ul></li><li>IEEE 802.11a<ul><li>覆盖使用 5 GHz传输带宽的WLAN设备</li><li>使用 5 GHz</li><li>802.11a 有能力提供 54 Mbps的数据吞吐率，若是使用叫做“双倍率”的专利技术可以到达</li><li>实际上，更标准的速率为 20-26 Mbps.</li></ul></li><li>IEEE 802.11g<ul><li>提供和802.11a (54Mbps)一样的吞吐率，但能向后兼容802.11b</li><li>使用正交频分多路复用技术(OFDM)技术</li></ul></li><li><strong>IEEE 802.11n：WLAN的下一代（目前主要使用的）</strong><ul><li>提供和802.11g相比两倍的带宽108Mbps，理论上可达500-600Mbps</li></ul></li></ul><h2 id="第二层设备">4. 第二层设备</h2><h3 id="网卡-nic">4.1. 网卡 NIC</h3><ul><li>NIC 在数据链路层扮演了重要的角色：<ul><li>LLC——在计算机中与上层通讯</li><li>MAC——提供对共享访问介质的结构化访问</li><li>命名——提供一个独特的MAC地址</li><li>组帧——封装过程的一部分，为了传输将比特打包</li><li>信号传递——通过使用内置的收发器来产生信号和介质接口</li><li>网卡解析01序列</li></ul></li></ul><h3 id="网桥">4.2. 网桥</h3><p>网桥将通信划分成段；基于MAC地址，而不是协议，过滤通信</p><p>网桥可以通过减少大的冲突域，来改进网络表现</p><p>当从网络中一个段到其它段的通信量比较低时，网桥工作的更好</p><p>当网段之间的通信量变得繁重，网桥会成为瓶颈，减慢通讯</p><p><strong>网桥可以识别帧了</strong></p><p><strong>透明网桥</strong></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002710.png" style="zoom:50%;" /></p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291004430.png" style="zoom:50%;" /></p><p>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的</p><p>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D</p><p>目前以太网中使用得最多的网桥</p><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002161.png" style="zoom:67%;" /></p><p>问题：当网络上的设备想要发送数据的时候，但是它不知道目的地址</p><p>发送一个广播给网络上的所有设备</p><p>因为网络上每一个设备都要关注这种广播，网桥总是向前传输广播 ​太多广播可能会导致广播风暴这又会导致：</p><p>网络超时</p><p>通信减慢</p><p>无法接受的网络表现</p><p><strong>源路由网桥</strong></p><p>源路由(sourceroute)网桥在发送帧时将详细的路由信息放在帧的首部中,从而使每个经过的网桥都了解帧的路径</p><p>在令牌环网络中被广泛使用</p><p>透明网桥容易安装，但网络资源的利用不充分</p><p>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中</p><p>源站以广播方式向欲通信的目的站发送一个发现帧，每个发现帧都记录所经过的路由</p><p>发现帧到达目的站时就沿各自的路由返回源站</p><p>源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由</p><p>凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息</p><h3 id="交换机">4.3. 交换机</h3><ul><li><p>有两个基本操作：</p><ul><li><p>交换数据帧：帧被输入介质接收，然后被输出介质传输</p></li><li><p>交换操作保持：交换机建立和保持交换表，搜索循环。路由器建立和保持路由表和服务表</p></li></ul></li><li><p>交换是一种。通过减少通信量，增加带宽，减轻EthernetLANs中的网络拥堵的技术</p><ul><li><p>交换机创造专用网段，或点对点连接，然后将这些网段在交换机内的虚拟网络中连接起来</p></li><li><p>这叫虚拟回路，因为它仅在两个节点需要通讯时存在，并且是建立在交换机内的</p></li><li><p>你可以把每个交换机端口想象成一个微型网桥，这个过程叫微分段microsegmentation</p></li><li><p>每一个交换机端口给予每个主机全部的介质带宽</p></li></ul></li><li><p>局域网交换机减小了冲突域的大小</p></li><li><p>然而，所有连接到交换机的主机仍然在同一个广播域中：</p><ul><li>也就是说，从一个节点发出的广播仍然会被其他所有连接这个局域网交换机的主机接收</li></ul></li></ul><h3 id="冲突域">4.4. 冲突域</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002214.png" style="zoom:67%;" /></p><h4 id="冲突域的桥分割">4.4.1. 冲突域的桥分割</h4><p>用网桥来分割局域网的以太网，给每个用户提供更多带宽，因为每个网段上用户更少</p><p>网桥不管第3层用什么协议，都会把数据帧继续传输下去</p><p>网桥增加了10%~30%的网络延迟，因为需要做决定</p><p>网桥被看做是存储转发设备，因为它必须接收全部帧，然后在转发之前，验证循环冗余校验CRC</p><h4 id="冲突域的交换机分割">4.4.2. 冲突域的交换机分割</h4><p>交换机更快，因为他们在硬件中交换，然而网桥在软件中交换</p><p>一个10 Mbps的以太局域网和一个100 Mbps以太局域网可以用交换机连接</p><p>在一个交换式以太网实现中，可用带宽可达100%</p><p>当因为CSMA/CD使得分享式以太网络只使用了全满容量的30%~40%时，网络表现最好</p><p>网桥仅仅支持存储转发，而有些交换机支持直通转发，这样减少了延迟</p><h4 id="冲突域的路由器分割">4.4.3. 冲突域的路由器分割</h4><p>路由器可以构造最高等级的分割：</p><p>构造更小的冲突域</p><p>构造更小的广播域：除非编写的程序要求，否则路由器不会继续向前传送广播</p><p>路由器通过检查数据包上的目的逻辑地址完成向前传输包，然后在它的路由表中查找向前的指令</p><p>因为路由器比网桥有更多的功能，所以操作时有着更大的延迟</p><p>路由器可以像网关一样工作：</p><p>用于连接不同的网络介质和不同的局域网技术</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请移步我的知乎</title>
    <link href="/2022/10/25/Discrete%20Math/%E8%AF%B7%E7%A7%BB%E6%AD%A5%E6%88%91%E7%9A%84%E7%9F%A5%E4%B9%8E/"/>
    <url>/2022/10/25/Discrete%20Math/%E8%AF%B7%E7%A7%BB%E6%AD%A5%E6%88%91%E7%9A%84%E7%9F%A5%E4%B9%8E/</url>
    
    <content type="html"><![CDATA[<p>我将 NJUSE大一下学期的离散数学（主要是简单的数据结构）进行了粗略的整理，发布在我的知乎上</p><blockquote><p><span class="citation"data-cites="怀明带你去夜生活">@怀明带你去夜生活</span></p><p>https://www.zhihu.com/column/c_1508391477789564928</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Discrete Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zhihu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ IO</title>
    <link href="/2022/10/25/C++%20Basic/Notes/C++%20IO/"/>
    <url>/2022/10/25/C++%20Basic/Notes/C++%20IO/</url>
    
    <content type="html"><![CDATA[<h3 id="控制台输入">1. 控制台输入</h3><h4 id="标准输入流-cin">1. 标准输入流 <code>cin</code></h4><p><code>cin</code> 输入原理简述：</p><p>程序的输入都建有一个缓冲区，即输入缓冲区。每次输入过程是这样的：当一次键盘输入结束时会将输入的数据存入输入缓冲区，而<code>cin</code>函数直接从输入缓冲区中取数据（<code>cin</code>读取数据是从第一个非空白字符开始到下一个空白字符结束）。正因为<code>cin</code>函数是直接从缓冲区取数据的，所以有时候当缓冲区中有<strong>残留数据</strong>时，<code>cin</code>函数会直接取得这些<strong>残留数据</strong>而不会请求键盘输入。</p><h5 id="头文件">1.1. 头文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//&lt;iostream&gt; 中定义了 cin/cout/cerr/clog 等对象</span><br></code></pre></td></tr></table></figure><h5 id="cin">1.2. <code>cin &gt;&gt;</code></h5><p>根据 <code>cin &gt;&gt; sth</code> 中 <code>sth</code>的变量类型读取数据，这里变量类型可以为<code>int, float, char, char*, string</code>等诸多类型。这一输入操作，在遇到<strong>结束符</strong><code>（Space、Tab、Enter）</code>就结束，且<strong>结束符并不保存到变量中</strong>。</p><p><strong>注意：最后一个 <code>enter</code> 也在缓冲区</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_input</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">char</span> ch1[<span class="hljs-number">10</span>], ch2[<span class="hljs-number">10</span>];  <br>  <span class="hljs-comment">//这里的char[] 换成char* 或者是 string有相同的效果</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入两个字符串：&quot;</span> &lt;&lt; endl;  <br>    cin &gt;&gt; ch1;  <br>    cin &gt;&gt; ch2;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;两个字符串分别为：&quot;</span> &lt;&lt; endl;  <br>    cout &lt;&lt; ch1 &lt;&lt; endl;  <br>    cout &lt;&lt; ch2 &lt;&lt; endl;  <br>    cin.<span class="hljs-built_in">get</span>(ch);<br>    cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl; <span class="hljs-comment">//输出10，为最后一个enter输入</span><br>&#125;  <br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210251510171.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210290955796.png"alt="image-20221025151057071" /></a></p><h5 id="cin.get">1.3. <code>cin.get()</code></h5><p>其中结束符意味着遇到该符号结束字符串读取,默认为enter，读取的字符个数最多为（长度-1），因为最后一个为’\0’。要注意的是，cin.get(字符数组名，接收长度，结束符)操作遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。cin.get函数有如下几种声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>&amp; c)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n, <span class="hljs-type">char</span> delim)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(streambuf&amp; sb)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(streambuf&amp; sb, <span class="hljs-type">char</span> delim)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="输入-int">1. 输入 <code>int</code></h4><h5 id="输入-10-个数字以空格或者是换行符分割">1.1. 输入 10个数字（以空格或者是换行符分割）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> nums[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    cin &gt;&gt; nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="输入未知个数的数字并求和">1.2. 输入未知个数的数字并求和</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    sum += n;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="读入一个整数之后再读入行">1.3. 读入一个整数之后再读入行</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>cin &gt;&gt; ws;<br>string t;<br><span class="hljs-built_in">getline</span>(cin, t);<br></code></pre></td></tr></table></figure><h4 id="输入-char">2. 输入 <code>char</code></h4><h5 id="输入一个字符包括空白符">2.1. 输入一个字符（包括空白符）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cin.<span class="hljs-built_in">get</span>(ch);<br><span class="hljs-comment">//就算ch是换行符/tab/空格都会被输入进去</span><br></code></pre></td></tr></table></figure><h5 id="输入一个非空白的字符">2.2. 输入一个非空白的字符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cin &gt;&gt; ch;<br><span class="hljs-comment">//直到输入非空白字符之前，程序都不会结束</span><br></code></pre></td></tr></table></figure><h5 id="输入未知个数的字符">2.3. 输入未知个数的字符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(cin.<span class="hljs-built_in">get</span>(ch))&#123;<br>  <span class="hljs-comment">//do something</span><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//这里连换行符或者是空格/tab都能输入，方便用来判断循环结束的条件</span><br></code></pre></td></tr></table></figure><p><code>get</code> 的返回值为 <code>istream</code> 对象，而<code>istream</code> 对象可以转换为<code>bool</code> 值，因而可以出现在<code>while</code> 的条件中；</p><p><code>&gt;&gt;</code> 实际上会转换成函数<code>operator&gt;&gt;</code> 的调用，函数的返回值也为<code>istream</code> 对象</p><h4 id="输入-stringchar">3. 输入 <code>string/char *</code></h4><h5 id="普通读入">3.1. 普通读入</h5><p>读入，以空白字符或 <code>EOF</code> 作为结束标志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br>cin &gt;&gt; s;<br></code></pre></td></tr></table></figure><h5 id="按需读入">3.2. 按需读入</h5><p>读入一行，以换行符（默认）或指定的字符（称为delimiter）作为结束标志，delimiter 会被读取但不会出现在 s 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-built_in">getline</span>(cin, a, <span class="hljs-string">&#x27;,&#x27;</span>);<br><br><span class="hljs-comment">//注意这里的 dlm 一定要是字符而不是字符串</span><br></code></pre></td></tr></table></figure><h5 id="能读入空格和回车符的输入方式">3.3.能读入空格和回车符的输入方式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>()) &#123;<br>    s += c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制台输出">2. 控制台输出</h3><h3 id="文件输入">3. 文件输入</h3><blockquote><p>待补充</p></blockquote><h3 id="文件输出">4. 文件输出</h3><blockquote><p>待补充</p></blockquote><h3 id="参考文章">5. 参考文章</h3><ol type="1"><li><ahref="https://blog.csdn.net/a3192048/article/details/80303547">cin、cin.get()、cin.getline()、getline()的区别</a></li><li>https://en.cppreference.com/w/cpp/io/basic_ios/operator_bool</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Proficiency</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ map</title>
    <link href="/2022/10/23/C++%20Basic/STL%20Containers/C++%20map/"/>
    <url>/2022/10/23/C++%20Basic/STL%20Containers/C++%20map/</url>
    
    <content type="html"><![CDATA[<p>C++ 中的 <code>map</code> 刻画了键-值对这一 ADT。需要注意的是，使用map容器存储的各个键-值对，<strong>键的值既不能重复也不能被修改</strong>。换句话说，map容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const修饰，这意味着只要键值对被存储到 map容器中，其键的值将不能再做任何修改。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>C++<br></code></pre></td></tr></table></figure><h4 id="初始化">2. 初始化</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><br><span class="hljs-comment">//or</span><br><br>map&lt;string, <span class="hljs-type">int</span>&gt; myMap&#123;&#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-number">114514</span>&#125;, &#123;<span class="hljs-string">&quot;xzj&quot;</span>, <span class="hljs-number">114514</span>&#125;&#125;;<br><span class="hljs-comment">//注意这里初始化的时候不用写等号，和 Java 区别开来</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="插入元素">3. 插入元素</h4><p><a href="http://c.biancheng.net/cplus/">C++</a> <ahref="http://c.biancheng.net/stl/">STL</a> map类模板中对<code>[ ]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[ ]</code>运算符可以实现不同的操作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>  <span class="hljs-comment">//map</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;string, string&gt; mymap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>,<span class="hljs-string">&quot;114&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//获取已存储键值对中，指定键对应的值</span><br>    cout &lt;&lt; mymap[<span class="hljs-string">&quot;gqc&quot;</span>] &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//向 map 容器添加新键值对</span><br>    mymap[<span class="hljs-string">&quot;ycy&quot;</span>] = <span class="hljs-string">&quot;514&quot;</span>;<br> <br>    <span class="hljs-comment">//修改 map 容器已存储键值对中，指定键对应的值</span><br>    mymap[<span class="hljs-string">&quot;gqc&quot;</span>] = <span class="hljs-string">&quot;064&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mymap.<span class="hljs-built_in">begin</span>(); iter != mymap.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//======================================</span><br><br><span class="hljs-comment">//输出为</span><br><span class="hljs-comment">//114</span><br><span class="hljs-comment">//ycy 514</span><br><span class="hljs-comment">//gqc 064</span><br><br>C++<br></code></pre></td></tr></table></figure><p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ]运算符才能成功获取该键对应的值；反之，若当前 map容器中没有包含该指定键的键值对，则此时使用 [ ]运算符将不再是访问容器中的元素，而变成了向该 map容器中增添一个键值对。其中，该键值对的键用 [ ]运算符中指定的键，其对应的值取决于 map容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是string 类型，其值为“”，即空字符串（即使用该类型的默认值作为键值对的值）。</p><p>同时，存储的键值对，其本质都是 pair 类模板创建的 pair对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">std::map&lt;std::string, <span class="hljs-type">int</span>&gt;myMap&#123;std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-number">114</span>),std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-number">514</span>)&#125;;<br><br>C++<br></code></pre></td></tr></table></figure><h4 id="获取元素">4. 获取元素</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      // map</span><br>using namespace std<span class="hljs-comment">;</span><br> <br><span class="hljs-built_in">int</span> main()&#123;<br>    //创建并初始化 map 容器<br>    std::map&lt;std::<span class="hljs-built_in">string</span>, std::<span class="hljs-built_in">string</span>&gt;myMap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-string">&quot;114&quot;</span>&#125;,<br>                                             &#123;<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-string">&quot;514&quot;&quot;&#125;,</span><br><span class="hljs-string">                                             &#123;&quot;</span>grl<span class="hljs-string">&quot;, &quot;</span><span class="hljs-number">1919</span><span class="hljs-string">&quot;&#125; &#125;;</span><br><span class="hljs-string">    string cValue = myMap[&quot;</span>gqc<span class="hljs-string">&quot;];</span><br><span class="hljs-string">    cout &lt;&lt; cValue &lt;&lt; endl;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">C++</span><br></code></pre></td></tr></table></figure><h4 id="迭代元素">5. 迭代元素</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      // pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>       // string</span><br>using namespace std<span class="hljs-comment">;</span><br> <br><span class="hljs-built_in">int</span> main() &#123;<br>    //创建并初始化 map 容器<br>    map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;myMap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-string">&quot;114&quot;</span>&#125;,<br>                              &#123;<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-string">&quot;514&quot;&quot;&#125;,</span><br><span class="hljs-string">                              &#123;&quot;</span>grl<span class="hljs-string">&quot;, &quot;</span><span class="hljs-number">1919</span><span class="hljs-string">&quot;&#125;&#125;;</span><br><span class="hljs-string">    //调用 begin()/end() 组合，遍历 map 容器</span><br><span class="hljs-string">    for (map&lt;string, string&gt;::iterator iter = myMap.begin(); iter != myMap.end(); ++iter) &#123;</span><br><span class="hljs-string">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;</span> <span class="hljs-string">&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">C++</span><br></code></pre></td></tr></table></figure><h4 id="删除元素">6. 删除元素</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sas">删除键为bfff指向的元素<br>cmap.erase(<span class="hljs-string">&quot;bfff&quot;</span>);<br><br> <br>删除迭代器 <span class="hljs-keyword">key</span>所指向的元素<br>map&lt;string,int&gt;::iterator <span class="hljs-keyword">key</span> = cmap.find(<span class="hljs-string">&quot;mykey&quot;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">key</span>!=cmap.<span class="hljs-keyword">end</span>())<br>&#123;<br>    cmap.erase(<span class="hljs-keyword">key</span>);<br>&#125;<br> <br>删除所有元素<br>cmap.erase(cmap.begi<span class="hljs-meta">n</span>(), cmap.<span class="hljs-keyword">end</span>());<br><br>C++<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ string</title>
    <link href="/2022/10/23/C++%20Basic/STL%20Containers/C++%20string/"/>
    <url>/2022/10/23/C++%20Basic/STL%20Containers/C++%20string/</url>
    
    <content type="html"><![CDATA[<h3 id="头文件">1. 头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">//这个可有可无</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br></code></pre></td></tr></table></figure><p><code>&lt;iostream&gt;</code>需要用到<code>std::ios_base</code>类型，<code>std::ios_base</code>有个成员函数的返回类型是<code>std::locale</code>，<code>std::locale</code>定义在<code>&lt;locale&gt;</code>头文件，<code>&lt;locale&gt;</code>中还有一个叫做<code>std::numpunct</code>的类模板，<code>std::numpunct</code>有一个成员函数的返回类型是<code>std::string</code>。</p><p>这就是为什么包含了<code>&lt;iostream&gt;</code>可以使用<code>std::string</code>。但可以看出这一串联系有多么间接和不可靠。</p><p><ahref="https://www.zhihu.com/question/270726509/answer/356155720">为什么可以不加#include</a></p><h3 id="声明一个c字符串">2. 声明一个C++字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s; <span class="hljs-comment">//调用 string 类的默认构造函数，不传入任何参数，生成一个空字符串 s </span><br><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str)</span> <span class="hljs-comment">//拷贝构造函数 生成str的复制品 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,stridx)</span> <span class="hljs-comment">//将字符串str内“始于位置stridx”的部分当 作字符串的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,stridx,strlen)</span> <span class="hljs-comment">//将字符串str内“始于stridx且长度 顶多strlen”的部分作为字符串的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(cstr)</span> <span class="hljs-comment">//将C字符串作为s的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(chars,chars_len)</span> <span class="hljs-comment">//将C字符串前chars_len个字符作为 字符串s的初值。 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(num,c)</span> <span class="hljs-comment">//生成一个字符串，包含num个c字符 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(beg,end)</span> <span class="hljs-comment">//以区间beg;end(不包含end)内的字符作 为字符串s的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">s.~<span class="hljs-title">string</span><span class="hljs-params">()</span> <span class="hljs-comment">//销毁所有字符，释放内存</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h3 id="相关函数">3. 相关函数</h3><h4 id="c字符串和c字符串的转换">3.1. C++字符串和C字符串的转换</h4><p>C++ 提供的由 C++ 字符串得到对应的<code>C_string的</code>方法是使用<code>data()、c_str()</code>和<code>copy()</code>，其中，<code>data()</code>以字符数组的形式返回字符串内容，但并不添加<code>'/0'</code>。<code>c_str()</code> 返回一个以<code>‘/0'</code> 结尾的字符数组， 而 <code>copy()</code>则把字符串的内容复制或写入既有的 <code>c_string</code> 或字符数组内。C++字符串并不以<code>'/0'</code>结尾。</p><h4 id="大小和容量函数">3.2. 大小和容量函数</h4><p>一个C++字符串存在三种大小：</p><ul><li>现有的字符数，函数是<code>size()</code>和<code>length()</code>，他们等效。<code>empty()</code>用来检查字符串是否为空。</li><li><code>max_size()</code>这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出<code>length_error</code>异常</li><li><code>capacity()</code>重新分配内存之前 <code>string</code>所能包含的最大字符数。这里另一个需要指出的是 <code>reserve()</code>函数，这个函数为 <code>string</code>重新分配内存。重新分配的大小由其参数决定， 默认参数为0，这时候会对<code>string</code>进行非强制性缩减。</li></ul><h4 id="元素存取">3.3. 元素存取</h4><p>我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引<code>0~str.length()</code>），如果索引失效，会引起未定义的行为。而<code>at()</code>会检查，如果使用 <code>at()</code> 的时候索引无效，会抛出<code>out_of_range</code> 异常。</p><p>有一个例外不得不说，<code>const string a;</code> 的操作符[]对索引值是<code>a.length()</code>仍然有效，其返回值是<code>'/0'</code>，而<code>at()</code> 对索引值为<code>a.length()</code>仍然会抛出异常。其他的各种情况，<code>a.length()</code>索引都是无效的。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> string <span class="hljs-title">Cstr</span><span class="hljs-params">(“<span class="hljs-type">const</span> string”)</span></span>; <br><br><span class="hljs-function">string <span class="hljs-title">Str</span><span class="hljs-params">(“string”)</span></span>; <br><br>Str[<span class="hljs-number">3</span>]; <span class="hljs-comment">//ok </span><br><br>Str.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//ok </span><br><br>Str[<span class="hljs-number">100</span>]; <span class="hljs-comment">//未定义的行为 </span><br><br>Str.<span class="hljs-built_in">at</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//throw out_of_range</span><br><br>Str[Str.<span class="hljs-built_in">length</span>()] <span class="hljs-comment">//未定义行为 </span><br>  <br>Cstr[Cstr.<span class="hljs-built_in">length</span>()] <span class="hljs-comment">//返回 ‘/0&#x27; </span><br>  <br>Str.<span class="hljs-built_in">at</span>(Str.<span class="hljs-built_in">length</span>());<span class="hljs-comment">//throw out_of_range </span><br><br>Cstr.<span class="hljs-built_in">at</span>(Cstr.<span class="hljs-built_in">length</span>()); <span class="hljs-comment">//throw out_of_range </span><br><br></code></pre></td></tr></table></figure><p>不赞成类似于下面的引用或指针赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>&amp; r=s[<span class="hljs-number">2</span>]; <br><span class="hljs-type">char</span>* p= &amp;s[<span class="hljs-number">3</span>];<br><br></code></pre></td></tr></table></figure><p>因为一旦发生重新分配，r,p立即失效。</p><p>避免的方法就是不使用。</p><h4 id="比较函数">3.4. 比较函数</h4><p>C ++字符串支持常见的比较操作符 (&gt;, &gt;=, &lt;, &lt;=, ==,!=)，甚至 支持<code>string</code>与<code>C_string</code>的比较(如<code>str &lt; "hello"</code>)。在使用 &gt;, &gt;=, &lt;, &lt;=这些操作符的时候是根据 “当前字符特性”将字符按字典顺序进行逐一比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，<code>string (“aaaa”)&lt;string(“aaaaaa”)</code>。</p><p>另一个功能强大的比较函数是成员函数<code>compare()</code>。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：</p><ul><li>0 - 相等</li><li>&gt; 0 - 大于</li><li>&lt; 0 - 小于</li></ul><p>举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(“abcd”)</span></span>; <br><br>s.<span class="hljs-built_in">compare</span>(“abcd”); <span class="hljs-comment">//返回0 </span><br><br>s.<span class="hljs-built_in">compare</span>(“dcba”); <span class="hljs-comment">//返回一个小于0的值 </span><br><br>s.<span class="hljs-built_in">compare</span>(“ab”); <span class="hljs-comment">//返回大于0的值 </span><br><br>s.<span class="hljs-built_in">compare</span>(s); <span class="hljs-comment">//相等</span><br><br>s.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,s,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//用”ab”和”cd”进行比较 小于零 </span><br><br>s.<span class="hljs-built_in">compare</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,”bcx”,<span class="hljs-number">2</span>); <span class="hljs-comment">//用”bc”和”bc”比较</span><br><br></code></pre></td></tr></table></figure><h4 id="更改内容">3.5. 更改内容</h4><h5 id="赋值">1. 赋值</h5><ul><li>第一个赋值方法当然是使用操作符<code>=</code>，新值可以是<code>string</code>(如：<code>s = ns</code>)、<code>c_string</code>(如：<code>s = ”gaint”</code>)甚至单一字符（如：`s = ‘j’ ）。</li><li>还可以使用成员函数<code>assign()</code>，这个成员函数可以使你更灵活的对字符串赋值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">assign</span>(str);<br><br>s.<span class="hljs-built_in">assign</span>(str,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//如果str是”iamangel” 就是把”ama”赋给字符串 </span><br><br>s.<span class="hljs-built_in">assign</span>(str,<span class="hljs-number">2</span>,string::npos);<span class="hljs-comment">//把字符串str从索引值2开始到结尾赋 给s </span><br><br>s.<span class="hljs-built_in">assign</span>(“gaint”); <span class="hljs-comment">//不说 </span><br><br>s.<span class="hljs-built_in">assign</span>(“nico”,<span class="hljs-number">5</span>);<span class="hljs-comment">//把&#x27;n&#x27; ‘I&#x27; ‘c&#x27; ‘o&#x27; ‘/0&#x27;赋给字符串 </span><br><br>s.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//把五个x赋给字符串</span><br><br></code></pre></td></tr></table></figure><ul><li><p>清空字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">s=””;<br>s.<span class="hljs-built_in">clear</span>();<br>s.<span class="hljs-built_in">erase</span>();<br><br></code></pre></td></tr></table></figure></li></ul><h5 id="增加">2. 增加</h5><ul><li>增加在末尾</li></ul><p>函数有 +=、 append()、push_back()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">s += str;<span class="hljs-comment">//加个字符串 </span><br><br>s += <span class="hljs-string">&quot;my name is jiayp&quot;</span>;<span class="hljs-comment">//加个C字符串 </span><br><br>s += <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//加个字符 </span><br><br>s.<span class="hljs-built_in">append</span>(str); <br><br>s.<span class="hljs-built_in">append</span>(str, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//同前面的函数参数assign的解释 </span><br><br>s.<span class="hljs-built_in">append</span>(str, <span class="hljs-number">2</span>, string::npos);<br><br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;my name is jiayp&quot;</span>); <br><br>s.<span class="hljs-built_in">append</span>(“nico”, <span class="hljs-number">5</span>); <br><br>s.<span class="hljs-built_in">append</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;x&#x27;</span>); <br><br>s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//这个函数只能增加单个字符对STL熟悉的理解起 来很简单</span><br></code></pre></td></tr></table></figure><ul><li>添加在中间的位置</li></ul><p>这时候可以用 <code>insert()</code>函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,”my name”); <br><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,str); <br></code></pre></td></tr></table></figure><p>这种形式的<code>insert()</code>函数不支持传入单个字符，这时的单个字符必须写成字符串形式。为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(size_type index,size_type num,chart c)<br><br><span class="hljs-built_in">insert</span>(iterator pos,size_type num, chart c)<br></code></pre></td></tr></table></figure><p>其中 <code>size_type</code> 是无符号整数，<code>iterator</code>是<code>char*</code>, 所以, 这么调用<code>insert</code>函数是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;j&#x27;</span>);<br></code></pre></td></tr></table></figure><p>必须这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>((string::size_type)<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;j&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>string</code> 有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</p><h5 id="删除">3. 删除</h5><p>删除函数也有若干种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s=”il8n”; <br><br>s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,”nternationalizatio”);<span class="hljs-comment">//从索引1开始的2个替换成后面的C_string </span><br><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">13</span>);<span class="hljs-comment">//从索引13开始往后全删除 </span><br><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">7</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//从索引7开始往后删5个</span><br></code></pre></td></tr></table></figure><h4 id="提取字串">3.6. 提取字串</h4><p>题取子串的函数是：<code>substr()</code>, 形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">substr</span>();<span class="hljs-comment">//返回s的全部内容 </span><br><br>s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">11</span>);<span class="hljs-comment">//从索引11往后的子串 </span><br><br>s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//从索引5开始6个字符</span><br></code></pre></td></tr></table></figure><p>值得注意的是，C++ 中的<code>substr()</code>第二个参数是长度，而 Java中 <code>substr()</code>的两个参数分别表示前闭后开区间的两个端点</p><h4 id="输入输出">3.7. 输入输出</h4><p>更具体的输入输出可以看<ahref="https://naturalifica.top/2022/10/23/C++%20Basic/考试必备/C++%20IO/">这篇文章</a></p><ul><li>&gt;&gt; 从输入流读取一个string。</li><li>&lt;&lt; 把一个string写入输出流。</li><li>getline(), 他从输入流读取一行内容，直到遇到分行符或到了文件尾。</li></ul><h4 id="搜索与查找">3.8. 搜索与查找</h4><p>查找函数很多，功能也很强大，包括了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find</span>()<br>  <br><span class="hljs-built_in">rfind</span>()<span class="hljs-comment">//反过来找</span><br>  <br><span class="hljs-built_in">find_first_of</span>()<br>  <br><span class="hljs-built_in">find_last_of</span>()<br>  <br><span class="hljs-built_in">find_first_not_of</span>()<br>  <br><span class="hljs-built_in">find_last_not_of</span>()<br><br></code></pre></td></tr></table></figure><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回<code>npos</code>。所有的函数的参数<strong>说明如下：</strong></p><p>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数.</p><p>最后再说说<code>npos</code>的含义，<code>string::npos</code>的类型是<code>string::size_type</code>,所以，一旦需要把一个索引与<code>npos</code>相比，这个索引值必须是<code>string::size)type</code>类型的，更多的情况下，我们可以直接把函数和<code>npos</code>进行比较（如：<code>if(s.find(“jia”)== string::npos</code>)</p><h3 id="参考文章">参考文章</h3><ol type="1"><li><ahref="https://blog.csdn.net/samkieth/article/details/50876347">Cpp–string常用函数用法总结</a></li><li><ahref="https://www.zhihu.com/question/270726509/answer/356155720">C++使用字符串一定要 #include吗?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tree &amp; Binary Tree</title>
    <link href="/2022/10/20/Data%20Structure/Tree%20&amp;%20Binary%20Tree/"/>
    <url>/2022/10/20/Data%20Structure/Tree%20&amp;%20Binary%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="tree-的相关定义">1. Tree 的相关定义</h3><h4 id="tree-的定义">1.1. Tree 的定义</h4><p><strong>满足下列三个条件的</strong>数据结构叫做树</p><ol type="1"><li><p>A tree T is a collection of nodes(element).</p></li><li><p>The collection can be empty.</p></li><li><p>Otherwise, a tree consists of a distinguished node r , called theroot, and zero or more nonemppty (sub) trees <spanclass="math inline">\(T_1 , T_2 , ……, T_k\)</span>.</p></li></ol><h4 id="tree-的度叶枝层次和高度">1.2. Tree 的度，叶，枝，层次和高度</h4><ol type="1"><li><p>Degree of an elememts(nodes): the number of children ithas.</p></li><li><p>Degree of a tree: the maximum of its element degrees.</p></li><li><p>Leaf: element whose degree is 0.</p></li><li><p>Branch: element whose degree is not 0.</p></li><li><p>Level: the level of root is 0.</p><ul><li>the level of an element = the level of its parent + 1.</li></ul></li><li><p>Depth(Height) of a tree: the maximum level of itselements.</p></li></ol><h4 id="tree-的存储方法">1.3. Tree 的存储方法</h4><ol type="1"><li>广义表表示法</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>(<span class="hljs-selector-tag">b</span>(f,g),c,<span class="hljs-built_in">d</span>(h,<span class="hljs-selector-tag">i</span>,j),e)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>双亲表示法</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>左子女-右兄弟表示法</li></ol><h3 id="binary-tree">2. Binary Tree</h3><h4 id="binary-tree-的定义">2.1. Binary Tree 的定义</h4><p><strong>满足下列两个条件</strong>的叫做二叉树</p><ol type="1"><li><p>Definition: A binary tree t is a finite (possibly empty)collection of elements.</p></li><li><p>When the binary tree is not empty:</p><ul><li><p>It has a root element</p></li><li><p>The remaining elements(if any) are partitioned into two binarytrees, which are called the left and right subtrees of t.</p></li></ul></li></ol><h4 id="binary-tree-和一般意义的-tree-的区别">2.2. Binary Tree和一般意义的 Tree 的区别</h4><ul><li>Each element in a binary tree has exactly two subtrees(one or bothof these subtrees may be empty).<ul><li>Each element in a tree can have any number of subtrees.</li></ul></li><li>The subtrees of each element in a binary tree are ordered. That is,we distinguish between the left and the right subtrees.<ul><li>The subtrees in a tree are unordered.</li></ul></li></ul><h4 id="binary-tree-的性质">2.3. Binary Tree 的性质</h4><ul><li>The drawing of every binary tree with n elements (n&gt;0) hasexactly n-1 edges.<ul><li>因为二叉树是恰好连通的</li></ul></li><li>The number of elements at level <spanclass="math inline">\(i\)</span> is at most <spanclass="math inline">\(2^i \ (i \geq0)\)</span>.</li><li>A binary tree of height <span class="math inline">\(h,h\geq0\)</span> , has at least <span class="math inline">\(h+1\)</span>and at most <span class="math inline">\(2^{h+1}–1\)</span> elements init.</li></ul><p><span class="math display">\[\sum_{i = 0}^h2^i = 2^{h+1}-1\]</span></p><ul><li>If number of leaves is <span class="math inline">\(n_0\)</span> ,and the number of the 2 degree elements is <spanclass="math inline">\(n_2\)</span> , then <spanclass="math inline">\(n_0=n_2+1\)</span>.</li><li>The height of a binary tree that contains <spanclass="math inline">\(n (n \geq 0)\)</span> element is at most <spanclass="math inline">\(n-1\)</span> and at least <spanclass="math inline">\([log2 (n+1)]-1\)</span><ul><li>proof: Since there must be at least one element at each level, theheight cannot exceed <span class="math inline">\(n-1\)</span>.</li><li>From property 3,we know <span class="math inline">\(n \leq 2^h+1-1\)</span>, so, <span class="math inline">\(h \geq log2(n+1)-1\)</span>, since h is an integer,we get <spanclass="math inline">\(h=[log2 (n+1)]-1\)</span></li></ul></li><li>Let <span class="math inline">\(i, 0\leq i \leq n-1\)</span>, be thenumber assigned to an element of a complete binary tree. The followingare true.<ul><li>if <span class="math inline">\(i=0\)</span>, then this element isthe root of the binary tree. if <spanclass="math inline">\(i&gt;0\)</span>,then the parent of this elementhas been assigned the number <span class="math inline">\([\frac{i -1}{2}]\)</span></li><li>if <span class="math inline">\(2 \times i+1 \geq n\)</span>, thenthis element has no left child. Otherwise,its left child has beenassigned the number <span class="math inline">\(2\times i +1\)</span>.</li><li>if <span class="math inline">\(2 \times i+2\geq n\)</span>, thenthis element has no right child, Otherwise its right child has beenassigned the number <span class="math inline">\(2 \times i +2\)</span>.</li></ul></li></ul><h4 id="特殊类型的-binary-tree">2.4. 特殊类型的 Binary Tree</h4><h5 id="full-binary-tree">2.4.1 Full Binary Tree</h5><ul><li>A binary tree of height h that contains exactly <spanclass="math inline">\(2^h+1 -1\)</span> elements is called a full binarytree.</li></ul><h5 id="complete-binary-tree">2.4.2 Complete binary tree</h5><ul><li>Suppose we number the elements in a full binary tree of height husing the number 1 through <span class="math inline">\(2^{h+1} -1\)</span>. We began at level <span class="math inline">\(0\)</span> andgo down to level <span class="math inline">\(h\)</span>. Within levelsthe elements are numbered left to right. Suppose we delete the <spanclass="math inline">\(k\)</span> elements numbered <spanclass="math inline">\(2^{h+1} -i\)</span>, <span class="math inline">\(1\leq i \leq k\)</span>, the resulting binary tree is called a completebinary tree.</li><li>也就是说在广度优先的基础上要使这个二叉树尽可能的满</li></ul><h4 id="binary-tree-的物理层">2.5. Binary Tree 的物理层</h4><h5 id="array-实现">2.5.1 Array 实现</h5><ol type="1"><li>The binary tree to be represented is regarded as a complete binarytree with some missing elements.<ul><li>如图</li></ul></li></ol><pre><code class=" mermaid">graph TD0((0))--&gt;1((1))--&gt;3((3))--&gt;7((7))1((1))--&gt;4((4))0((0))--&gt;2((2))--&gt;5((5))2((2))--&gt;6((6))</code></pre><ol start="2" type="1"><li>这样表示的缺点<ul><li>如果这样的二叉树离完全二叉树很远，那么会很浪费空间</li></ul></li></ol><h5 id="linkedlist-实现">2.5.2 LinkedList 实现</h5><ol type="1"><li>每一个节点存储三个数据<ul><li>LeftTree （如果不存在的话就是 nullptr）</li><li>data</li><li>RightTree (如果不存在的话就是 nullptr)</li></ul></li></ol><ul><li><p>代码表示</p><ul><li>Java （更具体的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryNode</span>&#123;<br>  <br>  BinaryNode left;<br>  BinaryNode right;<br>  Object element;<br>  <br>  <br>  BinaryNode()&#123;<br>    letf = right = <span class="hljs-number">0</span>;<br>  &#125;<br>  BinaryNode(Object e)&#123;<br>    element = e;<br>    left = right = <span class="hljs-number">0</span>;<br>  &#125;<br>  BinaryNode(Object e, BinaryNode l, BinaryNode r)&#123;<br>    element = e;<br>    left = l;<br>    right = r;<br>  &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * • Create()</span><br><span class="hljs-comment">*• IsEmpty()</span><br><span class="hljs-comment">*• Root(x)</span><br><span class="hljs-comment">*• MakeTree(root, left, right)</span><br><span class="hljs-comment">*• BreakTree(root, left, right)</span><br><span class="hljs-comment">*• PreOrder</span><br><span class="hljs-comment">*• InOrder</span><br><span class="hljs-comment">*• PostOrder</span><br><span class="hljs-comment">*• LevelOrder</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* binaty.h</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123; <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BinaryTree</span>()&#123;root=<span class="hljs-number">0</span>;&#125;;<br>~<span class="hljs-built_in">BinaryTree</span>()&#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> ((root)?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Root</span><span class="hljs-params">(T&amp; x)</span><span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeTree</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BreakTree</span><span class="hljs-params">(T&amp; data , BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span></span>&#123;<br>    <span class="hljs-built_in">PreOrder</span>(visit, root);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u))</span></span>&#123;<br>    <span class="hljs-built_in">InOrder</span>(visit, root);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 这里的函数参数 void(*visit) 是函数指针</span><br><span class="hljs-comment">  * 这个指针指向一段代码，而不是一个数据</span><br><span class="hljs-comment">  * 这个指针的作用是执行指向指针的代码</span><br><span class="hljs-comment">  * @return nothing</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * The function visit is used as parameter to the traversal methods,so that different operations can be</span><br><span class="hljs-comment">* implemented easily</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span> <span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span></span>&#123;<br>    <span class="hljs-built_in">PostOrder</span>(visit, root);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u))</span></span>;<br><span class="hljs-keyword">private</span>:<br>BinaryNode&lt;T&gt;* root;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit) (BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br>&#125;;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 下面是一些成员函数的实现</span><br><span class="hljs-comment">*/</span><br><br>Template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> BinaryTree&lt;T&gt;::<span class="hljs-built_in">MakeTree</span>(<span class="hljs-type">const</span> T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)&#123; <br>  root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>&lt;T&gt;(data, leftch.root, rightch.root);<br>  leftch.root = rightch.root = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> BinaryTree&lt;T&gt;::<span class="hljs-built_in">BreakTree</span>(T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)&#123; <br>  <span class="hljs-keyword">if</span>(!root)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BadInput</span>();<br>  &#125;<span class="hljs-comment">//tree empty</span><br>data = root.element;<br>leftch.root = root.Left;<br>rightch.root = root.Right;<br><span class="hljs-keyword">delete</span> root;<br>root = <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* main.cpp</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> “binary.h”</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>BinaryTree&lt;<span class="hljs-type">int</span>&gt; a, x, y, z;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这是四个二叉树</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(BinaryTreeNode&lt;T&gt; *t)</span></span>&#123;<br>  count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; <br>  a.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  z.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  x.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">3</span>, a, z);<br>  y.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">4</span>, x, <span class="hljs-number">0</span>);<br>  y.<span class="hljs-built_in">PreOrder</span>(ct);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 在遍历所有节点的同时，调用一次 ct（ct只是一个计数器）</span><br><span class="hljs-comment">  */</span><br>  cout &lt;&lt; count &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="cursor-静态链表-实现">2.5.3 Cursor (静态链表) 实现</h5><h4 id="binary-tree-的遍历">2.6. Binary Tree 的遍历</h4><p>Each element is visited exactly once</p><ul><li><p>V：表示访问一个结点</p></li><li><p>L：表示访问V的左子树</p></li><li><p>R：表示访问V的右子树</p></li></ul><p>那么有六种情况：VLR LVR LRV VRL RVL RLV</p><p>一般地，我们都只考虑 L 在 R之前的情况，否则可以将这个二叉树的每一个节点的子节点都左右交换，形成它的反二叉树</p><p>因此树的遍历包括这四种情况</p><ul><li>Preorder （VLR）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><ul><li>Inorder （LVR）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非递归的写法，但是脑袋里要一直有递归的过程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(BinaryNode &lt;T&gt; * t)</span></span>&#123; <br>  stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="hljs-built_in">s</span>(<span class="hljs-number">10</span>);<br>BinaryNode&lt;T&gt; * p = t;<br><span class="hljs-keyword">for</span> (;;)&#123;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123; <br>      s.<span class="hljs-built_in">push</span>(p); <br>      p = p-&gt;Left; <br>    &#125;<br><span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">IsEmpty</span>())&#123; <br>    p = s.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; p-&gt;element;<br>p = p-&gt;Right;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Postorder （LRV）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//和中序遍历的区别在于，要明确左右子树都要已经访问过了，再把当前节点弹出</span><br><span class="hljs-comment">//tag 的作用就在于此</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StkNode</span>&#123; <br>  BinaryNode &lt;T&gt; * ptr;<br><span class="hljs-type">int</span> tag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Postorder</span><span class="hljs-params">(BinaryNode &lt;T&gt; * t)</span></span>&#123; <br>  stack &lt;StkNode&lt;T&gt;&gt;<span class="hljs-built_in">s</span>(<span class="hljs-number">10</span>);<br>StkNode&lt;T&gt; Cnode;<br>BinaryNode&lt;T&gt; * p = t;<br><span class="hljs-keyword">for</span>(;;)&#123; <br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123; <br>      Cnode.ptr = p; <br>      Cnode.tag = <span class="hljs-number">0</span>; <br>      s.<span class="hljs-built_in">push</span>(Cnode);<br>p = p-&gt;Left;<br>&#125;<br>    Cnode = s.<span class="hljs-built_in">pop</span>(); <br>    p = Cnode.ptr;<br>     <span class="hljs-comment">//从右子树回来</span><br><span class="hljs-keyword">while</span> ( Cnode.tag = = <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; p-&gt;element;<br><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">IsEmpty</span>())&#123; <br>        Cnode = s.<span class="hljs-built_in">pop</span>(); <br>        p = Cnode.ptr; <br>      &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br>   Cnode.tag = <span class="hljs-number">1</span>; <br>    s.<span class="hljs-built_in">push</span>(Cnode); <br>    p = p-&gt;Right; <span class="hljs-comment">//从左子树回来</span><br>&#125;<span class="hljs-comment">//for</span><br>&#125; <br></code></pre></td></tr></table></figure><ul><li>Level order（一层一层地遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BinaryNode&lt;T&gt;* t)</span></span>&#123; <br>  LinkedQueue&lt;BinaryNode&lt;T&gt;*&gt; Q;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-built_in">visit</span>(t); <span class="hljs-comment">//visit t</span><br>  <span class="hljs-keyword">if</span>(t-&gt;Left) Q.<span class="hljs-built_in">Add</span>(t-&gt;Left);<br>  <span class="hljs-keyword">if</span>(t-&gt;Right) Q.<span class="hljs-built_in">Add</span>(t-&gt;Right);<br>  <span class="hljs-keyword">try</span>&#123;Q.<span class="hljs-built_in">Delete</span>(t);&#125;<br><span class="hljs-built_in">catch</span>(OutOfBounds)&#123;<span class="hljs-keyword">return</span>;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bianry-tree-的实现方式">2.7. Bianry Tree 的实现方式</h4><h5 id="利用maketree函数">1. 利用MakeTree函数</h5><h5 id="利用先序中序唯一的构造一棵二叉树">2.利用先序、中序唯一的构造一棵二叉树</h5><ul><li><h5 id="先序abdcegfhi">先序：ABDCEGFHI</h5></li><li><h5 id="中序dbaegchfi-a-b-c-d-e-f-g-h-i">中序：DBAEGCHFI A B C D E FG H I</h5></li></ul><h5id="利用二叉树的广义表表示来构造一棵二叉树-abd-ce-g-fhi-a-b-c-d-e-f-g-h-i">3.利用二叉树的广义表表示来构造一棵二叉树 A(B(D), C(E( ,G), F(H,I))) A B CD E F G H I</h5><h5 id="利用二叉树的后缀表示来构造一棵二叉树-abc-abc-c-a-b">4.利用二叉树的后缀表示来构造一棵二叉树 (a+b)<em>c ab+c</em> * + c a b</h5><h3 id="thread-binary-tree">3. Thread Binary Tree</h3><h4 id="一个平凡的想法">3.1. 一个平凡的想法</h4><p><span class="math inline">\(n\)</span> 个结点的二叉树有 <spanclass="math inline">\(2n\)</span> 个<ahref="https://blog.csdn.net/weixin_38233103/article/details/117674582">链域</a>，其中真正有用的是 <span class="math inline">\(n – 1\)</span> 个（因为<span class="math inline">\(|E|=|V|-1\)</span>），其它 <spanclass="math inline">\(n + 1\)</span>个都是空域。为了充分利用结点中的空域，使得对某些运算更快，如前驱或后继等运算</p><h4 id="section">3.2.</h4><h4 id="section-1">3.3.</h4><h3 id="huffman-tree">4. Huffman Tree</h3><blockquote><p>Huffman Tree 是一种特殊类型的 Binary Tree</p></blockquote><h4 id="一些概念">4.1. 一些概念</h4><ul><li><p>增长树</p><ul><li><p>对原二叉树中度为 1 的结点，增加一个空树叶</p></li><li><p>对原二叉树中的树叶，增加两个空树叶</p></li></ul></li><li><p>外通路长度（外路径）<span class="math inline">\(E\)</span>：根到每个外结点 (增长树的叶子) 的路径长度的总和</p></li><li><p>内通路长度（内路径）<span class="math inline">\(I\)</span>：根到每个内结点 (非叶子) 的路径长度的总和</p></li><li><p>结点的带权路径长度：一个结点的权值与结点的路径长度的乘积。</p></li><li><p>带权的外路径长度： 各叶结点的带权路径长度之和。</p></li><li><p>带权的内路径长度：各非叶结点的带权路径长度之和。</p></li></ul><p><strong>Huffman Tree</strong></p><p>给出 <span class="math inline">\(m\)</span> 个实数 <spanclass="math inline">\(w_1，w_2，…，w_m （m\geq 2）\)</span> 作为 <spanclass="math inline">\(m\)</span> 个外结点的权构造一棵增长树，使得<strong>带权外路径长度</strong>: <span class="math display">\[\displaystyle \sum_{i=1}^m w_iI_i\]</span> 最小，这样的树叫做Huffman树。其中 <spanclass="math inline">\(I_i\)</span> 为从根结点出发到具有权为 <spanclass="math inline">\(w_i\)</span> 的外结点的通路长</p><h4 id="huffman-算法">4.2. Huffman 算法</h4><blockquote><p>思想： 权大的外结点靠近根， 权小的远离根。</p></blockquote><p>算法： 从 <span class="math inline">\(m\)</span>个权值中找出两个最小值 <span class="math inline">\(w_1，w_2\)</span>构成 （其中，<span class="math inline">\(w = w_1 +w_2\)</span>表示通过该结点的频度）</p><pre><code class=" mermaid">graph TDw--&gt;w1((w1))w((w))--&gt;w2((w2))</code></pre><p>然后对 <span class="math inline">\(m-1\)</span> 个权值 <spanclass="math inline">\(w， w_3，w_4, …, w_m\)</span>经由小到大排序，求解这个问题</p><p><strong>注意</strong>: 当内结点的权值与外结点的权值相等的情况下，内结点应排在外结点之后。除了保证Wi l i最小外，还保证 <spanclass="math inline">\(\max I_j\)</span> 和 $ _{j=1}^mI_j$ 也有最小值</p><h4 id="huffman-编码">4.3. Huffman 编码</h4><blockquote><p>Huffman 编码是 Huffman Tree 在通信的二进制编码中一种应用。</p></blockquote><p>设一电文出现的字符为 <span class="math inline">\(D=\{M，S，T，A，Q，K\}\)</span> ， 每个字符出现的频率为 <spanclass="math inline">\(W=\{10，29，4，8，15，7\}\)</span> ，如何对上面的诸字符进行二进制编码， 使得</p><ul><li><p>该电文的总长度最短。</p></li><li><p>为了译码，任一字符的编码不应是另一字符的编码的前缀</p></li></ul><p>算法： 利用 Huffman 算法， 把 <spanclass="math inline">\(\{10，29，4，8，15，7\}\)</span>作为外部结点的权，构造具有最小带权外路径长度的扩充二叉树，把每个结点的左子女的边标上0，右子女标上1。 这样从根到每个 叶子的路径上的号码连接起来，就是外结点的字符编码。</p><h3 id="general-lists">5. General Lists</h3>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Java</tag>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Physics Layer</title>
    <link href="/2022/10/20/Computer%20Networking/OSI%20Model/OSI%20Physics%20Layer/"/>
    <url>/2022/10/20/Computer%20Networking/OSI%20Model/OSI%20Physics%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次物理层">OSI层次：物理层</h1><blockquote><p>关键词：信号和介质</p><p>物理层定义了在系统之间为了链路所需的电气的、功能的特征 (包括介质)</p><p>也定义了电压级别、电压变化时机、物理数据速率、最大传输距离、物理连接器，以及其他相似性质</p></blockquote><h2 id="网络连接类型">1. 网络连接类型</h2><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgs1.png" alt="两种网络连接类型的图示" style="zoom:50%;" /></p><ol type="1"><li><p>多路复用共享介质</p><ul><li>多个主机可以访问同一介质</li><li>这意味着它们都共享相同的介质 —— 即是"wire"</li></ul></li><li><p>点对点 (Point To Point) 网络</p><ul><li>一个设备通过链路连接到另一个设备</li><li>最广泛地应用于拨号网络连接（使用电信号来完成传输），也是大家最熟悉的一种。</li></ul></li></ol><h2 id="局域网介质">2. 局域网介质</h2><blockquote><p><strong>什么是局域网</strong></p><p>局域网是一种网络种类，覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。局域网可以实现<ahref="https://baike.baidu.com/item/文件管理/1452357?fromModule=lemma_inlink">文件管理</a>、应用软件共享、<ahref="https://baike.baidu.com/item/打印机共享/1979511?fromModule=lemma_inlink">打印机共享</a>等功能，在使用过程当中，通过维护局域网网络安全，能够有效地保护资料安全，保证局域网网络能够正常稳定的运行。</p></blockquote><p>常见的<strong>局域网介质</strong>包括<strong>双绞线</strong>（无屏蔽双绞线和屏蔽双绞线），<strong>同轴电缆</strong>，<strong>光缆</strong>，以及一些<strong>无线通信</strong>手段（激光，红外线，收音机）</p><h3 id="屏蔽双绞线">2.1. 屏蔽双绞线</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimage-20221227160918351.png" alt="STP的图示" style="zoom:50%;" /></p><blockquote><p>什么是<ahref="https://zh.wikipedia.org/wiki/屏蔽双绞线">屏蔽双绞线</a> (ShieldedTwisted Pair, STP)</p><p>STP是一种通信<strong>电缆</strong></p><p>P.S. <ahref="https://zhuanlan.zhihu.com/p/149618137">电缆、光缆、光纤的区别</a></p></blockquote><h3 id="无屏蔽双绞线">2.2. 无屏蔽双绞线</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgs3.png" alt="UTP的图示" style="zoom:70%;" /></p><blockquote><p>什么是<strong><ahref="https://zh.wikipedia.org/wiki/非屏蔽雙絞線">无屏蔽双绞线</a></strong>(Unshielded Twisted Pair, UTP)</p><p>UTP是一种通信电缆。UTP的妙处在于，利用四对不同颜色的传输线相互缠绕所组成，每对相同颜色的线传递者来回两个方向的电脉冲，利用电磁感应相互抵消的原理来屏蔽电磁干扰</p><p>一般认为 UTP 的有效范围是100米</p></blockquote><h4 id="双绞线的的分类">2.2.1. 双绞线的的分类</h4><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimage-20221227162926871.png" alt="维基百科给出的UTP种类" style="zoom:50%;" /></p><blockquote><p>一般地，我们认为目前投入使用的双绞线包括三类，四类，五类，超五类，六类，七类线</p></blockquote><ul><li><p><strong>一类线</strong>：主要用于语音传输，不用于数据传输</p></li><li><p><strong>二类线</strong>：传输频率 1 MHz，用于语音和最高 4 Mbps的数据传输，常见于令牌网</p></li><li><p><strong>三类线</strong>：EIA / TIA568 标准指定电缆，传输频率 16MHz ，用于语音传输及最高传输速率为 10 Mbps的数据传输，主要用于10BASE-T</p></li><li><p><strong>四类线</strong>：传输频率为 20 MHz，用于语音传输和最高传输速率 16 Mbps的数据传输，主要用于令牌网和10BASE-T/100BASE-T</p></li><li><p><strong>五类线</strong>：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆</p></li><li><p><strong>超五类线</strong>：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</p></li><li><p><strong>六类线</strong>：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</p></li><li><p><strong>七类线</strong>：带宽为600MHz，可能用于今后的10G比特以太网。</p></li></ul><h4 id="utp的特点">2.2.2. UTP的特点</h4><ul><li>优点<ul><li>易于安装，成本低</li><li>每米的成本要低于其他任何类型的局域网线</li><li>体积小，不易于迅速阻塞布线管道</li><li>使用 <a href="">RJ-45接头</a>(也就是所谓的水晶头)，大大减少潜在的网络噪声源，也能确保优质可靠的连接</li></ul></li><li>缺点<ul><li>电缆的普遍缺点：与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声</strong>和<strong>干扰</strong></li><li>双绞线的<strong>信号增强距离</strong>比同轴电缆和光缆更短</li></ul></li></ul><h3 id="同轴电缆">2.3. 同轴电缆</h3><blockquote><p>什么是<strong>同轴电缆</strong> (Coaxial Cable)</p></blockquote><p><ahref="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec02/5.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210290929399.png"alt="img" /></a></p><ol type="1"><li>薄/厚</li><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，无论如何比双绞线传输更加远，成本也要高一点</li><li>内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。</li></ol><h3 id="光缆">2.4. 光缆</h3><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgsimgs6.png" alt="光缆" style="zoom:67%;" /></p><ol type="1"><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ol><h3 id="section"></h3><h3 id="光缆模式mode-type">光缆模式(Mode Type)</h3><ol type="1"><li>单模式：单个光传输<ul><li>也称为轴(axial)：光沿着电缆的轴传播</li><li>由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快</li><li>通常用于广域网</li><li>直径小于多模(色散较小)</li><li>最常使用ILD，但也使用LED</li><li>光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网</li></ul></li><li>多模式 多根光不同角度传输 Multimode Multimode<ul><li>光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射</li><li>大于单光模式，最常用于局域网</li><li>易受更大分散性的影响</li><li>光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射)</li></ul></li><li>都需要用注入式激光二极管或者发光二极管进行发射</li></ol><h2 id="section-1"></h2><h3 id="无线通信">2.5. 无线通信</h3><blockquote><p>什么是无线通信 (Wireless Communication)</p></blockquote><h2 id="网线的分类">3. 网线的分类</h2><p>a.直通线</p><p>在所有末端使用T568A或者T568B</p><p>用于连接<strong>PC和交换机</strong>以及连接<strong>交换机和路由器</strong></p><p>b.反转线（控制线）</p><p>用于把PC连接到交换机或者路由器</p><p>一端的插脚1连接另一端的插脚8；然后插脚2连接到插脚7、插脚3连接到插脚6，以此类推</p><p>c.交叉线</p><p>一端是T568A，另一端是T568B</p><p>可用于PC与路由器直连，也可用于连接两个或多个集线器或交换机</p><p>连接两个独立的工作站以创建迷你局域网</p><h2 id="数据通信基本知识">4.数据通信基本知识</h2><h3 id="基本术语">4.1. 基本术语</h3><p>信号：数据的电气或者电磁的表现</p><p>码元：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="信号处理">4.2. 信号处理</h3><p>模拟信号可以被分为简单信号和复合信号</p><p>简单信号（正弦波）不能被分解为更简单的模拟信号</p><p>复合信号可以被分解为多个<strong>正弦波</strong></p><p>复合模拟信号的分解：<strong>傅立叶分析</strong></p><p>任何一个周期为T的有理周期性函数 g(t)可分解为若干项（可能无限多项）正弦和余弦函数之和： <span class="math display">\[g(t) = \frac12c+\sum_{i = 1}^{\infty}a_n\sin(2\pi nft)+\sum_{i =1}^{\infty}b_n\cos(2\pi nft)\]</span> 数字信号一般是非周期性的，通常在传输介质上表现为方波</p><p>一个数字信号可以分解为无穷多个被称为谐波的简单正弦波，每个谐波都具有不同的频率与相位</p><p>在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号畸变</p><p>由于介质本身的限制，信号畸变是难以完全避免的</p><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p><p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重</p><h3 id="理论基础">4.3. 理论基础</h3><p>a.波特率和比特率</p><p>波特率（调制速率）：信号每秒钟变化的次数</p><p>比特率：每秒钟传送的二进制位数。</p><p>b.波特率与比特率的关系取决于信号值与比特位的关系</p><p>例：每个信号值表示为３位，则比特率是波特率的３倍；每个信号值表示为１位，则比特率和波特率相同</p><p>对于比特率为a bps的信道，发送８位所需的时间为8/a秒，若８位为一个周期Ｔ，则一次谐波的频率是： f = a/8 Hz</p><h3 id="数据通信技术编码方式">4.4. 数据通信技术：编码方式)</h3>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
      <tag>Network</tag>
      
      <tag>OSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存分配——从类的初始化开始</title>
    <link href="/2022/10/19/C++%20Basic/Notes/C++%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E4%BB%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%20/"/>
    <url>/2022/10/19/C++%20Basic/Notes/C++%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E4%BB%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%20/</url>
    
    <content type="html"><![CDATA[<h4 id="起因">1. 起因</h4><p>事情是这样：在最近的一次C++作业中，我需要用<strong>链表</strong>实现一个<strong>双向队列</strong>。</p><p>我对链表节点的实现如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">    Node</span> *next;<br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">*prev</span>;<br>    int val;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> val, <span class="hljs-keyword">Node</span> <span class="hljs-title">*prev</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>)；<br>&#125;;<br><br>CRMSH<br></code></pre></td></tr></table></figure><p>我对双向队列的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Deque</span>&#123;<br>    <span class="hljs-type">int</span> size;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * front 和 rear 分别为虚拟头指针和尾指针</span><br><span class="hljs-comment">  */</span><br>    Node *front;<br>    Node *rear;<br>    <span class="hljs-built_in">Deque</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br>    <span class="hljs-type">void</span> pop_front;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ~<span class="hljs-built_in">Deque</span>() = deafult;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>当我试图利用 <code>Deque::push_back(int value)</code>函数向队列中添加元素时，我起初的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @param value 新节点的值</span><br><span class="hljs-comment">  * @param prev 新节点的前一个节点</span><br><span class="hljs-comment">  * @param next 新节点的下一个节点</span><br><span class="hljs-comment">  * @return 一个船新节点</span><br><span class="hljs-comment">  */</span><br>    Node node = *<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = &amp;node;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是程序每次运行到这里都会中断，debug 显示无论我 new 多少个新的node，它们的地址都是一样的，因此所有新节点都连着它本身，于是爆栈了。但是如果我把写法改成如下这样，程序就恢复了正常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @param value 新节点的值</span><br><span class="hljs-comment">  * @param prev 新节点的前一个节点</span><br><span class="hljs-comment">  * @param next 新节点的下一个节点</span><br><span class="hljs-comment">  * @return 一个船新节点</span><br><span class="hljs-comment">  */</span><br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = node;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="一个合理的解释">2. 一个合理的解释</h4><p>首先我们需要了解 C++ 的内存分配</p><table><thead><tr class="header"><th>名称</th><th>特性</th></tr></thead><tbody><tr class="odd"><td><strong>栈</strong></td><td>由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等。</td></tr><tr class="even"><td><strong>堆</strong></td><td>由 new 分配的内存块，由程序员释放（编译器不管），一般一个 new 与一个delete 对应，一个 new[] 与一个 delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。</td></tr><tr class="odd"><td><strong>自由存储区</strong></td><td>由 malloc等分配的内存块，和堆十分相似，用free来释放。（实际上和堆是同一块区域）</td></tr><tr class="even"><td><strong>全局/静态存储区</strong></td><td>全局变量和静态变量被分配到同一块内存中（在 C语言中，全局变量又分为初始化的和未初始化的，C++ 中没有这一区分）。</td></tr><tr class="odd"><td><strong>常量存储区</strong></td><td>这是一块特殊存储区，里边存放常量，不允许修改。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br></code></pre></td></tr></table></figure><p>我们知道，由 <code>new</code>建立的变量存储在堆中。因此上述代码在堆区新建一个对象，并且返回该对象的地址，由<code>Node</code> 类型指针 <code>node</code> 存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node node = *<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br></code></pre></td></tr></table></figure><p>上述代码同样新建一个 <code>Node</code> 对象，并将这个 Node对象的值存储到一个 <code>Node</code> 类型的变量 <code>node</code>中，相当于如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node *np = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>Node node = *np;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* node 只是值传递</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>因此，在下一步的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">rear-&gt;prev-&gt;next = &amp;node;<br></code></pre></td></tr></table></figure><p>中，<code>&amp;node</code> 根本就不是那个指向新节点的指针<code>np</code>，而是一个临时栈变量 <code>node</code> 的地址。这里相当于<code>np-&gt;prev-&gt;next = &amp;node</code>。</p><pre><code class=" mermaid">graph LRrear_prev---&gt;rear---&gt;rear_prevnp---&gt;new_Node&amp;node---&gt;somewhere</code></pre><p>转变成了</p><pre><code class=" mermaid">graph LRnp--&gt;rearnp--&gt;rear_prev--&gt;&amp;node--&gt;rear_prev&amp;node--&gt;rear</code></pre><p>再经过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">rear-&gt;prev = &amp;node<br></code></pre></td></tr></table></figure><p>这一步后，转变为</p><pre><code class=" mermaid">graph LRnp--&gt;rearnp--&gt;&amp;node--&gt;rear&amp;node--&gt;&amp;node--&gt;&amp;node</code></pre><p>在 <code>node</code>这里出现了死循环，导致内存爆了</p><h3 id="源码">3. 源码</h3><p>在这里贴上我所有成员函数的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> val, Node *prev, Node *next)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;val = val;<br>    <span class="hljs-keyword">this</span>-&gt;next = next;<br>    <span class="hljs-keyword">this</span>-&gt;prev = prev;<br>&#125;<br><br><br>Deque::<span class="hljs-built_in">Deque</span>()&#123;<br>    <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>    front = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, front, <span class="hljs-literal">nullptr</span>);<br>    front-&gt;next = rear;<br>    front-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>    rear-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    rear-&gt;prev = front;<br>&#125;<br><br>Deque::<span class="hljs-built_in">push_front</span>(<span class="hljs-type">int</span> value)&#123;<br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, front, front-&gt;next);<br>    node-&gt;next-&gt;prev = node;<br>    front-&gt;next = node;<br>    <span class="hljs-keyword">this</span>-&gt;size++;<br>&#125;<br><br>Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = node;<br>    rear-&gt;prev = node;<br>    <span class="hljs-keyword">this</span>-&gt;size++;<br>&#125;<br><br>Deque::<span class="hljs-built_in">get_size</span>() <span class="hljs-type">const</span>&#123;<br>    cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;size &lt;&lt; endl;<br>&#125;<br><br>Deque::<span class="hljs-built_in">pop_front</span>()&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;size &lt;= <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; (*(front-&gt;next)).val &lt;&lt; endl;<br>        front-&gt;next = front-&gt;next-&gt;next;<br>        front-&gt;next-&gt;prev = front;<br>        <span class="hljs-keyword">this</span>-&gt;size--;<br>    &#125;<br>&#125;<br><br>Deque::<span class="hljs-built_in">pop_back</span>()&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;size &lt;= <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; (*(rear-&gt;prev)).val &lt;&lt; endl;<br>        rear-&gt;prev = rear-&gt;prev-&gt;prev;<br>        rear-&gt;prev-&gt;next = rear;<br>        <span class="hljs-keyword">this</span>-&gt;size--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="参考文章">4. 参考文章</h4><ol type="1"><li>http://t.csdn.cn/5QbW0</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object Oriented</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2022/10/16/Java%20Basic/Java%20IO/"/>
    <url>/2022/10/16/Java%20Basic/Java%20IO/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的字符串处理</title>
    <link href="/2022/10/16/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/16/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串拼接concat">1. 字符串拼接<code>(concat())</code></h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nim">/**<br>* java.lang.<span class="hljs-type">String</span><br>*/<br>public <span class="hljs-type">String</span> concat(<span class="hljs-type">String</span> str)<span class="hljs-meta">&#123;...&#125;</span><br><br>/**<br>* example<br>*/<br><br>private <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> getBCDString_4(<span class="hljs-type">int</span> val) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++, val = val / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (val % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;1&quot;</span>.concat(<span class="hljs-built_in">result</span>);<br>        &#125;    <br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;0&quot;</span>.concat(<span class="hljs-built_in">result</span>);<br>        &#125;<br>                <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br><br><span class="hljs-type">JAVA</span><br></code></pre></td></tr></table></figure><h4 id="字符串转任意不同进制的整数parseint">2.字符串转任意不同进制的整数<code>(parseInt())</code></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* java.lang.Integer</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> throws NumberFormatException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(s,<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">int</span> radix)</span> throws NumberFormatException </span>&#123;...&#125;<br><span class="hljs-comment">//其中radix表示进制</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* example</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">NBCDTrueValue</span><span class="hljs-params">(<span class="hljs-type">String</span> operand)</span> </span>&#123;<br>    StringBuilder ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>    <span class="hljs-keyword">if</span> (operand.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;1101&quot;</span>)) &#123;<br>        ans.<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    operand = operand.<span class="hljs-built_in">substring</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; operand.<span class="hljs-built_in">length</span>() &amp;&amp; i &lt; <span class="hljs-number">28</span>; i += <span class="hljs-number">4</span>) &#123;<br>        ans.<span class="hljs-built_in">append</span>(Integer.<span class="hljs-built_in">valueOf</span>(operand.<span class="hljs-built_in">substring</span>(i, i + <span class="hljs-number">4</span>), <span class="hljs-number">2</span>));        <br>    &#125;<br>    <span class="hljs-keyword">return</span> Integer.<span class="hljs-built_in">parseInt</span>(ans.<span class="hljs-built_in">toString</span>());<br>&#125;<br><br>JAVA<br></code></pre></td></tr></table></figure><h4 id="和上一点类似的还有long.parselong-double.parsedouble">3.和上一点类似的，还有<code>Long.parseLong()</code>,<code>Double.parseDouble()</code></h4><h4 id="整数转字符串">4. 整数转字符串</h4><ol type="1"><li></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ stack</title>
    <link href="/2022/10/10/C++%20Basic/STL%20Containers/C++%20stack/"/>
    <url>/2022/10/10/C++%20Basic/STL%20Containers/C++%20stack/</url>
    
    <content type="html"><![CDATA[<p><code>stack</code> 容器有广泛的应用。例如，编辑器中的<code>undo</code>(撤销)机制就是用堆栈来记录连续的变化。撤销操作可以取消最后一个操作，这也是发生在堆栈顶部的操作。编译器使用堆栈来解析算术表达式，当然也可以用堆栈来记录 C++ 代码的函数调用。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="初始化">2. 初始化</h4><p>下面展示了如何定义一个用来存放字符串对象的 stack 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;std::string&gt; words;<br></code></pre></td></tr></table></figure><p>stack容器适配器的模板有两个参数。第一个参数是存储对象的类型，第二个参数是底层容器的类型。<code>stack&lt;T&gt;</code>的底层容器默认是 <code>deque&lt;T&gt;</code>容器，因此模板类型其实是<code>stack&lt;typename T, typename Container=deque&lt;T&gt;&gt;</code>。通过指定第二个模板类型参数，可以使用任意类型的底层容器，只要它们支持<code>back()、push_back()、pop_back()、empty()、size()</code>这些操作。</p><p>下面展示了如何定义一个使用 <code>list&lt;T&gt;</code> 的堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;std::string,std::list&lt;std::string&gt;&gt; fruit;<br></code></pre></td></tr></table></figure><p><code>stack&lt;T&gt;</code>模板定义了拷贝构造函数，因而可以复制现有的 <code>stack</code> 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">double</span>,std::list&lt;<span class="hljs-type">double</span>&gt;&gt;copy_stack &#123;my_stack&#125;<br></code></pre></td></tr></table></figure><p><code>copy_stack</code> 是 <code>my_stack</code>的副本。在使用拷贝构造函数时，既可以用初始化列表，也可以用圆括号。</p><h4 id="常用函数和操作">3. 常用函数和操作</h4><ol type="1"><li>和其他序列容器相比，<code>stack</code>是一类存储机制简单、所提供操作较少的容器。下面是 <code>stack</code>容器可以提供的一套完整操作：</li></ol><ul><li><code>top()</code>：返回一个栈顶元素的引用，类型为<code>T&amp;</code>。如果栈为空，返回值未定义。</li><li><code>push(const T&amp; obj)</code>：可以将对象副本压入栈顶。这是通过调用底层容器的<code>push_back()</code> 函数完成的。</li><li><code>push(T&amp;&amp; obj)</code>：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的push_back() 函数完成的。</li><li><code>pop()</code>：弹出栈顶元素。</li><li><code>size()</code>：返回栈中元素的个数。</li><li><code>empty()</code>：在栈中没有元素的情况下返回<code>true</code>。</li><li><code>emplace()</code>：用传入的参数调用构造函数，在栈顶生成对象。</li><li><code>swap(stack&lt;T&gt; &amp; other_stack)</code>：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于stack 对象有一个特例化的全局函数 swap() 可以使用</li></ul><ol type="1"><li><code>stack&lt;T&gt;</code> 模板也定义了复制和移动版的<code>operator=()</code> 函数，因此可以将一个 <code>stack</code>对象赋值给另一个 <code>stack</code> 对象。<code>stack</code>对象有一整套比较运算符。比较运算通过字典的方式来比较底层容器中相应的元素。字典比较是一种用来对字典中的单词进行排序的方式。依次比较对应元素的值，直到遇到两个不相等的元素。第一个不匹配的元素会作为字典比较的结果。如果一个<code>stack</code> 的元素比另一个 <code>stack</code>的多，但是所匹配的元素都相等，那么元素多的那个 <code>stack</code>容器大于元素少的 <code>stack</code> 容器。</li><li>下面用 <code>stack</code> 实现一个表达式求值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A simple calculator using stack containers</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>                                          <span class="hljs-comment">// For pow() function</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                       <span class="hljs-comment">// For standard streams</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span>                                          <span class="hljs-comment">// For stack&lt;T&gt; container</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>                                      <span class="hljs-comment">// For remove()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>                                      <span class="hljs-comment">// For runtime_error exception</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                                         <span class="hljs-comment">// For string class</span></span><br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// Returns value for operator precedence</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">precedence</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> op)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">throw</span> std::runtime_error &#123;string &#123;<span class="hljs-string">&quot;invalid operator in precedence() function: &quot;</span>&#125; + op&#125;;<br>&#125;<br><br><span class="hljs-comment">// Execute an operation</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">execute</span><span class="hljs-params">(std::stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops, std::stack&lt;<span class="hljs-type">double</span>&gt;&amp; operands)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> result &#123;&#125;;<br>    <span class="hljs-type">double</span> rhs &#123;operands.<span class="hljs-built_in">top</span>()&#125;;                            <span class="hljs-comment">// Get rhs...</span><br>    operands.<span class="hljs-built_in">pop</span>();                                         <span class="hljs-comment">// ...and delete from stack</span><br>    <span class="hljs-type">double</span> lhs &#123;operands.<span class="hljs-built_in">top</span>()&#125;;                            <span class="hljs-comment">// Get lhs...</span><br>    operands.<span class="hljs-built_in">pop</span>();                                         <span class="hljs-comment">// ...and delete from stack</span><br><br>    <span class="hljs-keyword">switch</span> (ops.<span class="hljs-built_in">top</span>())                                      <span class="hljs-comment">// Execute current op</span><br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            result = lhs + rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            result = lhs - rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            result = lhs * rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            result = lhs / rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>            result = std::<span class="hljs-built_in">pow</span>(lhs, rhs);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> std::runtime_error &#123;string&#123;<span class="hljs-string">&quot;invalid operator: &quot;</span>&#125; + ops.<span class="hljs-built_in">top</span>()&#125;;<br>    &#125;<br>    ops.<span class="hljs-built_in">pop</span>();                                              <span class="hljs-comment">// Delete op just executed</span><br>    operands.<span class="hljs-built_in">push</span>(result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::stack&lt;<span class="hljs-type">double</span>&gt; operands;                            <span class="hljs-comment">// Push-down stack of operands</span><br>    std::stack&lt;<span class="hljs-type">char</span>&gt; operators;                             <span class="hljs-comment">// Push-down stack of operators</span><br>    string exp;                                             <span class="hljs-comment">// Expression to be evaluated</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;An arithmetic expression can include the operators +, -, *, /, and ^ for exponentiation.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Enter an arithmetic expression and press Enter - enter an empty line to end:&quot;</span> &lt;&lt; std::endl;<br>            std::<span class="hljs-built_in">getline</span>(std::cin, exp, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (exp.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>          <br>            <span class="hljs-comment">// Remove spaces</span><br>            exp.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(std::<span class="hljs-built_in">begin</span>(exp), std::<span class="hljs-built_in">end</span>(exp), <span class="hljs-string">&#x27; &#x27;</span>), std::<span class="hljs-built_in">end</span>(exp));<br><br>            <span class="hljs-type">size_t</span> index &#123;&#125;;                                    <span class="hljs-comment">// Index to expression string</span><br><br>            <span class="hljs-comment">// Every expression must start with a numerical operand</span><br>            operands.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stod</span>(exp, &amp;index));              <span class="hljs-comment">// Push the first (lhs) operand on the stack</span><br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                operators.<span class="hljs-built_in">push</span>(exp[index++]);                     <span class="hljs-comment">// Push the operator on to the stack</span><br><br>                <span class="hljs-comment">// Get rhs operand</span><br>                <span class="hljs-type">size_t</span> i &#123;&#125;;                                      <span class="hljs-comment">// Index to substring</span><br>                operands.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stod</span>(exp.<span class="hljs-built_in">substr</span>(index), &amp;i));  <span class="hljs-comment">// Push rhs operand</span><br>                index += i;                                       <span class="hljs-comment">// Increment expression index</span><br><br>                <span class="hljs-keyword">if</span> (index == exp.<span class="hljs-built_in">length</span>())                        <span class="hljs-comment">// If we are at end of exp...</span><br>                &#123;<br>                    <span class="hljs-keyword">while</span> (!operators.<span class="hljs-built_in">empty</span>())                      <span class="hljs-comment">// ...execute outstanding ops</span><br>                        <span class="hljs-built_in">execute</span>(operators, operands);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// If we reach here, there&#x27;s another op...</span><br>                <span class="hljs-comment">// If there&#x27;s a previous op of equal or higher precedence execute it</span><br>                <span class="hljs-keyword">while</span> (!operators.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">precedence</span>(exp[index]) &lt;= <span class="hljs-built_in">precedence</span>(operators.<span class="hljs-built_in">top</span>()))<br>                    <span class="hljs-built_in">execute</span>(operators, operands);                   <span class="hljs-comment">//  Execute previous op.</span><br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; operands.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e)<br>    &#123;<br>        std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Calculator ending...&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>C++<br></code></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/180.html">while循环</a>包含在一个 try 代码块中，这样就可以捕获抛出的任何异常。在<code>catch</code> 代码块中，调用异常对象的成员函数 <code>what()</code>会将错误信息输出到标准错误流中。在一个死循环中执行输入操作，当输入一个空字符串时，循环结束。可以使用<code>remove()</code> 算法消除非空字符串中的空格。<code>remove()</code>不能移除元素，而只能通过移动元素的方式来覆盖要移除的元素。</p><p>为了移除 <code>exp</code>字符串中剩下的多余元素，可以用两个迭代器作为参数调用<code>erase()</code>。其中第一个迭代器由 <code>remove()</code>返回，指向字符串的最后一个有效元素的后面位置。第二个迭代器是字符串原始状态的结束迭代器。这两个迭代器指定范围的元素会被删除。</p><p>每个浮点操作数的值都是用定义在头文件 <code>string</code> 中的<code>stod()</code> 函数获取的。这会将第一个字符串参数中的字符序列转换为<code>double</code>值。函数会从第一个表示有效浮点数的字符串的第一个字符开始，获取最长字符序列。第二个参数是一个整型<ahref="http://c.biancheng.net/c/80/">指针</a>，保存的是字符串中非数字部分第一个字符的索引。<code>string</code>头文件中定义了 <code>stod()</code> 函数，它可以返回一个<code>float</code> 值。 <code>stod()</code>会返回一个<code>long double</code> 值。</p><p>因为所有的运算符都需要两个操作数，所以有效的输入字符串格式总是为<code>operand op operand op operand</code>，等等。序列的第一个和最后一个元素都是操作数，每对操作数之间有一个运算符。因为有效表达式总是以操作数开头，所以第一个操作数在分析表达式的嵌套循环之前被提取出来。在循环中，输入字符串的运算符会被压入<code>operators</code> 栈。在确认没有到达字符串末尾后，再从<code>exp</code> 提取第二个操作数。这时，<code>stod()</code>的第一个参数是从 <code>index</code> 开始的 <code>exp</code>字符串，它是被压入 <code>operators</code>栈的运算符后的字符。非数字字符串的第一个索引保存在 <code>i</code>中。因为 <code>i</code> 是相对于 <code>index</code>的，所以我们会将<code>index</code> 加上<code>i</code>的值，使它指向操作数后的一个运算符(如果是 <code>exp</code>中的最后一个操作数，它会指向字符串末尾的下一个位置)。</p><p>当 <code>index</code> 的值超过 <code>exp</code>的最后一个字符时，会执行<code>operators</code>容器中剩下的运算符。如果没有到达字符串末尾，<code>operators</code>容器也不为空，我们会比较 <code>operators</code> 栈顶运算符和<code>exp</code>中下一个运算符的优先级。如果栈顶运算符的优先级高于下一个运算符，就先执行栈顶的运算符。否则，就不执行栈顶运算符，在下一次循环开始时，将下一个运算符压入<code>operators</code>栈。通过这种方式，就可以正确计算出带优先级的表达式的值。</p><h4 id="参考文章-视频">4. 参考文章 &amp; 视频</h4><ol type="1"><li><a href="http://c.biancheng.net/view/478.html">C++ stack(STLstack)用法详解</a></li><li><ahref="https://b23.tv/hIdZ8ul">【数据结构】《编程实现》(栈的应用)（表达式的求值）-哔哩哔哩</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 常用手写函数</title>
    <link href="/2022/10/10/C++%20Basic/Notes/C++%20%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/10/C++%20Basic/Notes/C++%20%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="大数加法">1. 大数加法</h3><h4 id="string不方便">1.1. string(不方便)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//需要用到其中的 reverse(T&amp; begin, )</span></span><br><span class="hljs-function">string <span class="hljs-title">addStr</span><span class="hljs-params">(string src, string dest)</span></span>&#123;<br>  string ans;<br>  <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; src.<span class="hljs-built_in">size</span>() || i &lt; dest.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector方便">1.2. vector（方便）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">addVec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v1, vector&lt;<span class="hljs-type">int</span>&gt; v2)</span></span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 注意这里的vector将原有的大数倒序存储</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(max(v1.size(), v2.size()), <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()); i++)&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; v1.<span class="hljs-built_in">size</span>())&#123;<br>      ans[i] += v1[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &lt; v2.<span class="hljs-built_in">size</span>())&#123;<br>      ans[i] += v2[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">while</span>(ans[i] &gt;= <span class="hljs-number">10</span>)&#123;<br>      ans[i] -= <span class="hljs-number">10</span>;<br>      ans[i + <span class="hljs-number">1</span>]++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">10</span>)&#123;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span>(ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] &gt;= <span class="hljs-number">10</span>)&#123;<br>    ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] -= <span class="hljs-number">10</span>;<br>    ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="string-vector-方便">1.3 string &amp; vector (方便)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string s1, string s2)</span></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; vec1, vec2, ansVec;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    vec1.<span class="hljs-built_in">push_back</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    vec2.<span class="hljs-built_in">push_back</span>(s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  ansVec = <span class="hljs-built_in">addVec</span>(vec1, vec2);<br>  <span class="hljs-built_in">reverse</span>(ansVec.<span class="hljs-built_in">begin</span>(), ansVec.<span class="hljs-built_in">end</span>());<br>  string ansStr;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ansVec.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    ansStr += (ansVec[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ansStr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="连续输入模版">2. 连续输入模版</h3><h4 id="允许使用-containers">2.1. 允许使用 Containers</h4><h3 id="字符串分割">3. 字符串分割</h3><h4 id="用-vector">3.1. 用 vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str, <span class="hljs-type">char</span> sep)</span> </span>&#123;<br>  <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>  vector&lt;string&gt; res;<br>  string temp;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, temp, sep)) &#123;<br>    res.<span class="hljs-built_in">push_back</span>(temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="strtok-与-strtok_s">3.2. strtok 与 strtok_s</h4><ul><li><p>strtok()</p><ul><li><p>头文件在string.h中，用法：strtok(char <em>str, char</em>delimiters)，str是一个字符串，delimiters是用于分隔的字符串，其中任意一个都可以用作分隔的参考，但是这是一种不安全的函数，会改变原来的字符串，所以尽量不要使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;- Hi Gou Hua! How -are u?&quot;</span>;<br>    <span class="hljs-type">char</span> *pch;<br>    pch = <span class="hljs-built_in">strtok</span>(str,<span class="hljs-string">&quot; -!?&quot;</span>);<br>    <span class="hljs-keyword">while</span>(pch != <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; pch &lt;&lt; endl;<br>        pch = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot; -!?&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-comment">//Hi</span><br><span class="hljs-comment">//Gou</span><br><span class="hljs-comment">//Hua</span><br><span class="hljs-comment">//How</span><br><span class="hljs-comment">//are</span><br><span class="hljs-comment">//u</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>strtok_s()</p><ul><li>用法：strtok_s(char <em>str, char </em>delimiters, char**tmp)，该函数保证了安全，不会改变原来的字符串</li></ul></li></ul><h3 id="二维线性表初始化">4. 二维线性表初始化</h3><h4 id="s">4.1. s</h4>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Proficiency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Routing &amp; Routers</title>
    <link href="/2022/10/10/Computer%20Networking/OSI%20Model/Routing%20&amp;%20Router/"/>
    <url>/2022/10/10/Computer%20Networking/OSI%20Model/Routing%20&amp;%20Router/</url>
    
    <content type="html"><![CDATA[<h1 id="路由和路由器">路由和路由器</h1><h2 id="路由器基础">1. 路由器基础</h2><h3 id="路由器">1.1. 路由器</h3><h3 id="内部组成">1.2. 内部组成</h3><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311044379.png"alt="pic80" /><figcaption aria-hidden="true">pic80</figcaption></figure><h4 id="ram">1.1.1. RAM</h4><ul><li>暂时存储路由器配置文件</li><li>一旦失去动力或重启，RAM的内容就丢失了</li><li>存储的内容<ul><li>路由表</li><li>ARP地址解析协议缓存</li><li>快速交换缓存</li><li>包缓存</li><li>包保留队列</li></ul></li></ul><h4 id="nvram">1.1.2. NVRAM</h4><ul><li>非易失性RAM</li><li>存储备份/启动配置文件</li><li>在路由器关闭或者重启时，内容不会丢失（可做文件恢复）</li></ul><h4 id="flash">1.1.3. FLASH</h4><ul><li>EEPROM (Electronically Erasable Programmable Read-Only Memory)</li><li>保存思科IOS (Internet Operating System)</li><li>允许不替换闪存芯片的软件更新</li><li>可以保存多种IOS版本</li><li>关闭时也可以保存</li></ul><h4 id="rom">1.1.4. ROM</h4><ul><li>包含POST(Power On Self Test)</li><li>一个引导程序(加载思科IOS)</li><li>运行系统软件<ul><li>备份，削减IOS的版本</li><li>更新需要安装的新芯片组</li></ul></li></ul><h4 id="interfaces接口">1.1.5. Interfaces接口</h4><ul><li>通过网络连接，包进入或离开路由器</li><li>连到底板上，或作为单独的模块</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311044784.png"title="fig:" alt="pic81" /></li></ul><h2 id="路由器启动流程">2. 路由器启动流程</h2><h3 id="系统启动流程">2.1. 系统启动流程</h3><ul><li>进行一个自身通电测试(POST):在这个测试期间，路由器执行来自所有硬件模块的ROM的诊断程序</li><li>验证CPU，存储器和网络连接端口的基础操作</li><li>软件初始化</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311044616.png"title="fig:" alt="pic82" /></li></ul><h3 id="软件启动流程">2.2. 软件启动流程</h3><ul><li>步骤1 – ROM里的通用引导程序在CPU芯片上执行</li><li>步骤2 – 操作系统(CiscoIOS)可以在几个地方之一，位置在配置寄存器的引导区域显示</li><li>步骤3 – 加载操作系统的镜像</li><li>步骤4 –保存在NVRAM里的配置文件被加载到主存，并且一次执行一行</li><li>步骤5 –如果NVRAM里没有有效的配置文件，那么执行一个问题导向的初始配置程序，即系统配置对话，也被称为setupmode设置模式.</li></ul><h3 id="路由器启动流程-1">2.3. 路由器启动流程</h3><ul><li>设置模式并不应该进入有着复杂协议的路由器</li><li>应该用设置来生成最小的配置，然后用各种各样的配置模式命令，而不是设置，来完成大部分路由器配置任务</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045399.png"title="fig:" alt="pic83" /></li></ul><h3 id="基本的路由配置">2.4. 基本的路由配置</h3><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045973.png"alt="pic84" /><figcaption aria-hidden="true">pic84</figcaption></figure><h3 id="执行基本的编址方案">2.5. 执行基本的编址方案</h3><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045495.png"alt="pic85" /><figcaption aria-hidden="true">pic85</figcaption></figure><h3 id="检验基本的路由配置">2.6. 检验基本的路由配置</h3><ul><li>使用 show running-config 命令</li><li>存储路由器基本配置 copy running-config startup-config</li><li>其他检验路由器的命令:<ul><li>Show running-config – 显示当前随机访问存储器中的配置</li><li>Show startup-config – 显示NVRAM中的配置文件</li><li>Show IP route – 现实路由表</li><li>Show interfaces – 显示所有接口的配置信息</li><li>Show IP int brief -显示接口的简要信息</li></ul></li></ul><h2 id="路由">3. 路由</h2><h3 id="基本概念">3.1. 基本概念</h3><ul><li><p>路由器通常使用pathdetermination路径选择和switching转换，两个基础功能，将包从一个数据链路转发到另一个</p></li><li><p>Switching转换功能允许一个路由器接受来自接口的包然后将它通过第二个接口转发出去</p></li><li><p>pathdetermination路径选择功能使得路由器可以选择最合适的接口来转发包</p></li><li><p>路由器使用地址的网络部分来选择转发包到下一个路由器的路径</p></li><li><p>路由器直接使用地址的节点部分来连接目的网络，来发送包到正确的主机</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045913.png"alt="pic86" /><figcaption aria-hidden="true">pic86</figcaption></figure></li></ul><h3 id="静态和动态">3.2. 静态和动态</h3><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045135.png"alt="pic87" /><figcaption aria-hidden="true">pic87</figcaption></figure><ul><li><p>为了安全的原因，你可能想要隐藏部分网络，然而动态路由想要显示所有关于网络的信息</p></li><li><p>当一个网络只能被一条路径连接时，静态路由就足够了</p></li><li><p>这种类型的分割被称为桩网络stub network.</p></li><li><p>静态路由</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311045256.png"alt="pic88" /><figcaption aria-hidden="true">pic88</figcaption></figure><ul><li>静态路由配置<ul><li><p>静态路由允许手动配置路由表</p></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046227.png"alt="pic90" /><figcaption aria-hidden="true">pic90</figcaption></figure></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046156.png"alt="pic89" /><figcaption aria-hidden="true">pic89</figcaption></figure></li></ul></li><li>管理距离<ul><li>管理距离是一个对于路由信息来源的信任度等级，表示为一个从0到255的数值</li><li>数值越高，信任度等级越低</li><li>所以静态路由的管理距离通常较低（1是默认值）</li></ul></li></ul></li><li><p>动态路由</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046486.png"alt="pic91" /><figcaption aria-hidden="true">pic91</figcaption></figure></li><li><p>动态路由协议在网络不同路径之间重定向（loadshare荷载分配）通信量</p></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046342.png"alt="pic92" /><figcaption aria-hidden="true">pic92</figcaption></figure></li><li><p>动态路由依赖路由协议来在路由器间共享信息</p></li><li><p>动态路由依赖两个基础的路由器功能：</p><ul><li>保持路由表</li><li>把信息分发给其它路由器</li></ul></li><li><p>收敛发生时间</p></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046674.png"alt="pic93" /><figcaption aria-hidden="true">pic93</figcaption></figure></li></ul></li></ul><h3 id="路由协议的分类">3.3. 路由协议的分类</h3><ul><li><p>Distance-Vector Protocol 距离矢量协议</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311046502.png"alt="pic94" /><figcaption aria-hidden="true">pic94</figcaption></figure></li><li><p>距离矢量算法不允许路由器了解网络拓扑的确切结构</p></li><li><p>基于距离矢量的路由算法 (也被称为Bellman-Ford algorithms)将路由表的周期性副本从路由器转发到另一个路由器</p></li><li><p>问题：</p><ul><li><p>问题1：路由成环</p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047638.png"alt="pic95" /><figcaption aria-hidden="true">pic95</figcaption></figure></li><li><p>问题2：无限计数</p></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047664.png"alt="pic96" /><figcaption aria-hidden="true">pic96</figcaption></figure></li><li><p>问题描述：</p><ul><li>无效的网络1更新会持续循环直到其它进程停止这个循环</li><li>这种情况称为无限计数count toinfinity，尽管基础事实是目的网络1已经关闭，包仍旧被不停地在网络中循环</li><li>尽管路由器不停地计数，无效信息允许一个路由循环退出</li></ul></li><li><p>解决方案：</p><ul><li>方案一：定义最大<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047046.png"title="fig:" alt="pic97" /></li></ul></li><li>方案二：路由中毒<ul><li>当网络5停止，路由器E通过给网络5添加一个表条目16或不可达，</li><li>当路由器C收到来自路由器E的路由中毒，它反过来发送一个称为毒性逆转的更新给路由器。这保证了段上所有路由器都收到了有毒的路由信息</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047373.png"title="fig:" alt="pic98" /></li></ul></li><li>方案三：水平分割<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047100.png"title="fig:" alt="pic99" /></li></ul></li><li>方案四：挂起计数器<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047808.png"title="fig:" alt="pic100" /></li></ul></li></ul></li></ul></li><li><p>阻断发送路由更新</p><ul><li>为了阻止接口发送任何路由更新信息，使用以下命令行：<ul><li>Router(config-router)#Passive-interface f0/0</li></ul></li><li>它只在使用距离矢量协议的时候有效，因为链路状态路由协议并不直接从邻居的路由表中获得拓扑信息</li></ul></li></ul></li><li><p>链路状态协议</p><ul><li>基于路由算法，也被称为SPF (最短路径优先)算法的链路状态维持了一个复杂的拓扑信息数据库 链路状态路由使用了：<ul><li>link-state advertisements(LSAs)链路状态广播</li><li>一个拓扑数据库</li><li>SPF算法，和基于SPF算法生成的树</li><li>一个到各个网络的路径和端口的路由表</li></ul></li><li>RFC 1583包括OSPF链路状态概念和操作的描述</li><li>具体描述<ul><li>路由器互相交换LSAs 。每个路由器由直连网络开始</li><li>每个并行路由器建立一个拓扑数据库，由互联网中所有LSAs组成 router inparallel with the other</li><li>SPF算法计算网络可达性.路由器把这个逻辑拓扑建立成树，以自己为根，由链路状态协议互联网中所有可能到达每个网络的路径组成。接着，它按照SPF给路径分类</li><li>路由器在路由表中，列出它的最佳路径，和通往这些目的网络的端口。它也维持其它拓扑元素和状态细节的数据库</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311047169.png"title="fig:" alt="pic101" /></li></ul></li><li>链路状态涉及方面<ul><li>处理和内存需求<ul><li>大多数情况下，运行链路状态路由协议，比用距离矢量路由协议，需要路由器使用更多内存、处理更多事务</li></ul></li><li>带宽需求<ul><li>在最初的链路状态包洪泛flood的时候，所有路由器使用链路状态路由协议来发送LSA包到其它路由器。当路由器需要带宽时，这个行为像洪水一般冲刷了互联网，并且暂时减少了给携带用户数据的路由通信，可用的路由带宽。</li></ul></li></ul></li><li>问题：链路状态更新<ul><li>链路状态路由必须保证所有路由器获得了需要的LSA包</li><li>有不同LASs集合的路由器，基于不同的拓扑数据，计算路由</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048951.png"title="fig:" alt="pic102" /></li></ul></li><li>比较：链路状态和矢量协议<ul><li>距离矢量：<ul><li>从邻居的视角来看网络拓扑</li><li>从路由器到路由器，增加距离矢量</li><li>周期性、频繁的更新，汇聚慢</li><li>向相邻的路由器发送路由表的副本</li></ul></li><li>链路状态：<ul><li>获得整个网络拓扑的整体构造</li><li>计算到达其它路由的最短路径</li><li>事件触发更新，汇聚快</li><li>把链路状态更新的部分发给其它路由器</li></ul></li></ul></li></ul></li><li><p>混合协议</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048791.png"alt="pic103" /><figcaption aria-hidden="true">pic103</figcaption></figure></li><li><p>混合协议的实例：</p><ul><li>OSI’s IS-IS 中间系统到中间系统协议</li><li>Cisco’s EIGRP增强内部网关路由协议</li></ul></li></ul></li><li><p>路由routing协议</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048979.png"alt="pic104" /><figcaption aria-hidden="true">pic104</figcaption></figure></li><li><p>IP路由协议包括:</p><ul><li>RIP – 一个距离矢量路由协议</li><li>IGRP – 思科的路由矢量路由协议</li><li>OSPF – 一个链路状态路由协议</li><li>EIGRP – 一个平衡的混合路由协议</li></ul></li><li><p>路由routing协议的主要目标</p><ul><li>最优路径—选择最好的路由</li><li>高效性—最小化带宽和路由器处理器资源的使用</li><li>快速汇聚Convergence—更快，更好。有些比其他汇聚更快</li><li>灵活性—可以处理大多数情况，如高频率使用和失效路由</li></ul></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048020.png"alt="pic105" /><figcaption aria-hidden="true">pic105</figcaption></figure></li><li><p>定义默认路由</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048322.png"alt="pic106" /><figcaption aria-hidden="true">pic106</figcaption></figure></li><li><p>默认路由使得路由表更短</p></li><li><p>当一个目的网络条目不在路由表中的时候，包就被发往默认网络</p><ul><li>定义默认路由(1)<ul><li>定义一个默认路由，使用动态路由协议</li><li>Router(config)# ip default-network [network-number]</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311048286.png"title="fig:" alt="pic107" /></li></ul></li><li>定义默认路由(2)<ul><li>定义一个默认路由为静态路由：</li><li>Router(config)# ip route 0.0.0.0 0.0.0.0 [next-hop-ip-address|exit-interface]</li><li>在配置默认路由后，使用show ip route 会显示： (172.16.1.2 is thedefault next-hop address)<ul><li>0.0.0.0网络的最后一个网关是172.16.1.2</li></ul></li></ul></li></ul></li></ul></li><li><p>RIP历史</p><ul><li>RIP v1被看做是经典的内部网关协议<ul><li>RIPv1是一个距离矢量协议，在已经决定好的时间间隔里，把它整个路由表广播给每一个相邻路由器。默认时间间隔为30s</li><li>RIP 使用跳数作为度量标准，最大跳数为15</li><li>RIPv1 有以下限制：<ul><li>更新中不发送子网掩码信息</li><li>它在255.255.255.255上广播更新</li><li>它不支持鉴别authentication</li><li>它不能支持VLSM或CIDR.</li></ul></li><li>RIP v1配置<ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049116.png"alt="pic108" /><figcaption aria-hidden="true">pic108</figcaption></figure><ul><li>路由器的“rip”命令选择RIP作为路由协议</li><li>“network”命令分配一个基于网卡的网络地址，就是被直连的网络</li></ul></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049706.png"alt="pic109" /><figcaption aria-hidden="true">pic109</figcaption></figure><ul><li>router rip<ul><li>network 1.0.0.0</li><li>network 2.0.0.0</li></ul></li></ul></li></ul></li></ul></li><li>RIP v2 是 RIP v1的进阶版，共享以下优点：<ul><li><p>它是一个距离矢量协议，使用跳数作为度量标准</p></li><li><p>它用挂起计数器来防止路由循环 – 默认180s</p></li><li><p>它用水平分割来防止路由循环</p></li><li><p>它用16跳来表示无限距离</p></li><li><p>RIP v2配置</p><ul><li>“router”命令开始路由过程</li><li>“network”命令实现以下三个功能：<ul><li>路由更新通过一个接口多播出去</li><li>如果路由更新进入同一个接口，它进入队列</li><li>子网直接连到通知的接口</li></ul></li></ul></li><li><p>RIP v2配置示例</p><ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049120.png"title="fig:" alt="pic111" /></li></ul></li><li><p>核查&amp;解决纷争</p><ul><li>核查 RIP v2<ul><li>Router# show ip protocols<ul><li>核查RIP配置</li></ul></li><li>Router# show ip route<ul><li>展示IP路由表</li></ul></li></ul></li><li>解决纷争RIP v2<ul><li>Router# debug ip rip<ul><li>展示RIP发送和收到的路由更新</li></ul></li><li>Router# undebug all (/no debug all)<ul><li>Router# 关闭所有调试</li></ul></li></ul></li></ul></li></ul></li><li>对比RIP v2和RIP v1<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049571.png"title="fig:" alt="pic110" /></li></ul></li></ul></li><li><p>OSPF概览</p><ul><li>最短路径优先(OSPF) 是一个基于开放标准的链路状态路由协议</li><li>它在IETF的多个标准中被描述<ul><li>最近的描述是RFC 2328</li></ul></li><li>当和RIP v1 and RIPv2相比时，OSPF正在变成最好的IGP协议，因为它可扩展</li></ul></li><li><p>路由信息</p><ul><li>链路状态用于描述接口和到相邻路由器之间的关系</li><li>链路状态的集合形成了一个链路状态数据库，有时叫拓扑数据库</li><li>路由器以它们自己为根，实行Dijkstra shortest path first (SPF)算法，来建立SPF树 tree</li><li>路由器通过SPF树计算最佳路径，然后选择最佳路径存入路由表</li></ul></li><li><p>OSPF vs RIP</p><ul><li></li><li><table><thead><tr class="header"><th>OSPF</th><th>RIP</th></tr></thead><tbody><tr class="odd"><td>使用带宽作为度量衡</td><td></td></tr><tr class="even"><td>适用于大型网络</td><td></td></tr><tr class="odd"><td>可以进一步划分网络</td><td></td></tr><tr class="even"><td>支持 VLSM</td><td></td></tr><tr class="odd"><td>快速汇聚</td><td></td></tr><tr class="even"><td>支持等耗的多种路径</td><td>使用跳数来计数</td></tr><tr class="odd"><td>适用于小型网络 (15跳)</td><td></td></tr><tr class="even"><td>宽等级设计</td><td></td></tr><tr class="odd"><td>不支持 VLSM (RIP v1)</td><td></td></tr></tbody></table></li><li><p>A到B的最佳路径是什么？</p></li><li><p><img src="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049775.png" alt="pic128" style="zoom:67%;" /></p></li></ul></li><li><p>OSPF好处</p><ul><li>OSPF 克服以下限制：<ul><li>更强健</li><li>更可扩展</li></ul></li><li>大型OSPF网络使用层级设计<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311049759.png"title="fig:" alt="pic129" /></li></ul></li></ul></li><li><p>OSPF术语</p><ul><li>链路：两个网络设备之间的物理连接</li><li>链路状态：两个路由器之间链路的状态，包括关于路由器接口和它与相邻路由器之间关系的信息。</li><li>开销cost：每个链路被分配的值，链路状态协议基于链路带宽，而不是跳数，分配给链路一个开销</li><li>区域：有着同样区域ID的网络/路由器集合，在同一个区域的每个路由器有着同样的链路状态信息</li><li>自治系统<ul><li>邻居关系数据库邻居列表：一个有着所有，和本路由器建立双向通讯的，邻居的列表</li><li>拓扑数据库所有路由的列表：一个关于互联网中其他所有路由器信息的列表，它展示了互联网的拓扑</li><li>路由表最佳路径列表：优势叫做转发数据库，每个路由器的路由表都是独特的</li></ul></li><li>指定路由器(DR)：一个在OSPF多路访问网络中的路由器，被选中代表网络中所有路由器</li><li>备份指定路由器(BDR)：一个备用的路由器，如果DR挂了，它就成DR了</li></ul></li><li><p>OSPF地区</p><ul><li>地区被定义为32位数<ul><li>要么IP形式，要么单独十进制值</li><li>Area 0 or Area 0.0.0.0</li></ul></li><li>Area 0：一个单独地区，地区号为0</li><li>OSPF使用2级分层模型</li><li>在多地区OSPF网络中，所有地区需要连接到area 0(backbone)</li><li>示例<ul><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311050455.png"title="fig:" alt="pic130" /></li></ul></li></ul></li><li><p>OSPF操作</p><ul><li>OSPF使用邻居邻接来获得对于整个网络的认知</li><li>OSPF操作有5步：<ul><li>Step1: 开始邻接关系</li><li>Step2: 选择DR和BDR （如果需要）</li><li>Step3: 发现路由</li><li>Step4: 选择合适路由</li><li>Step5: 维持路由信息</li></ul></li><li>OSPF有7种状态，它们是：<ul><li>Init, 2Way, Ex Start, Exchange, Loading, Full</li></ul></li></ul></li><li><p>最短路径算法</p><ul><li>最短路径算法计算了一个没有循环的拓扑，把当前节点作为开始点来检查返回的关于邻接节点的信息</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311050983.png"title="fig:" alt="pic131" /></li></ul></li><li><p>选择DR和BDR</p><ul><li><p>OSPF网络类型</p><ul><li>广播多路访问，如以太网</li><li>点对点网路</li><li>无广播多路访问（NBMA）</li></ul></li><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311050052.png"alt="pic132" /><figcaption aria-hidden="true">pic132</figcaption></figure></li><li><p>DR&amp;BDR</p><ul><li><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311050132.png"alt="pic133" /><figcaption aria-hidden="true">pic133</figcaption></figure></li><li><p>然后每个路由器与DR和BDR建立邻接</p></li><li><p>DR 发送链路状态信息到网段上其它所有路由器，用多播地址224.0.0.5给所有OSPF路由器</p></li><li><p>为了保证DR/BDR看见网端上所有路由器发送的链路状态，给所有DR/BDR的多播地址是224.0.0.6</p></li></ul></li></ul></li><li><p>OSPF在多路访问介质中</p><ul><li>Giga/Fast/Ethernet, FDDI, Token Ring</li><li><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210311050239.png"title="fig:" alt="pic134" /></li></ul></li><li><p>基本OSPF配置</p><ul><li>允许路由器使用OSPF<ul><li><em>Router (config) # router ospf process-id</em><ul><li>process-id<ul><li>值：1 ~ 65535</li><li>识别路由器上的多个OSPF进程</li><li>通常整个AS保持同样的进程ID</li></ul></li></ul></li></ul></li><li>识别路由器上的IP<ul><li><em>Router (config-router) # network address wildcard-mask areaarea-id</em></li><li>网络地址可以是一整个网络、子网、或接口地址</li></ul></li></ul></li><li><p>OSPF开销=度量单位</p><ul><li>开销应用与所有路由器链路</li><li>16位数(1 – 65,535)</li><li>低开销 = 更令人满意</li><li>路由选择是基于路径总开销制定的</li><li>度量源自带宽</li><li><imgsrc="/Users/wuchentian/NJULearning/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F/Computer%20Networking/notes/%E6%88%AA%E5%9B%BE/pic135.png"title="fig:" alt="pic135" /></li></ul></li><li><p>OSPF路径开销</p><ul><li>连接到同一个链路的接口必须有一致的开销，否则，链路要被挂起<ul><li>思科路由器对一个链路的默认开销是1784 ( 56Kbps 带宽 )<ul><li><em>Router (config-if) # ip ospf cost number</em>（1-65535）</li></ul></li><li>如果链路由更低的速度，你必须指明实际链路速度<ul><li><em>Router (config-if) # bandwidth number</em>（kbps）</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hardware</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList</title>
    <link href="/2022/10/10/Data%20Structure/LinkedList/"/>
    <url>/2022/10/10/Data%20Structure/LinkedList/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
