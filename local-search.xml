<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第十一章 信息与熵</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%86%B5/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%86%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="第十一章-信息与熵">第十一章 信息与熵</h2><h3 id="信息熵">11.1 信息熵</h3><h4 id="信息与熵">11.1.1信息与熵</h4><p>奈奎斯特，哈特利和香农研究了一类特殊的通信，即技术系统里的通信，他们假设通信的唯一目的是在接受后重新产生输出数据样式——即，信息是为了消除不确定性。香农给出的定义是，当我破门收到一条消息<span class="math inline">\(m\)</span> 时，假设最初有 <spanclass="math inline">\(n\)</span> 个事件 <spanclass="math inline">\(E_1,E_2,…,E_n\)</span> 是等可能的，<spanclass="math inline">\(E\)</span>表示他们当中的一个，这些事件有对应的概率 <spanclass="math inline">\(p_1,p_2,…,p_n\)</span>，那么消息 <spanclass="math inline">\(m\)</span> 的熵为 <span class="math display">\[H(m) = H(p_1,p_2,…,p_n)=-\sum_{i=1}^np_i\log_2p_i\]</span> 其中，对数的底是随机的，如果以 <spanclass="math inline">\(2\)</span> 为底，则单位为 <spanclass="math inline">\(bit\)</span>，如果以自然对数的底数 <spanclass="math inline">\(e\)</span> 为底，则单位为 <spanclass="math inline">\(nat\)</span></p><h4 id="信息熵性质">11.1.2 信息熵性质</h4><p>香农描述了信息度量的三个性质：单调性，非负性和可加性</p><p>​ &lt;1&gt; 单调性：非确定性越高的事件，其信息量越高</p><p>​ &lt;2&gt; 非负性：信息是非负的，可以看作是概率延伸的必然</p><p>​ &lt;3&gt;可加性：总信息量可拆解为各部分的信息量累加，这是广度量的一种表现</p><p>​香农从数学上证明了满足上述三个条件的随机变量不确定性度量函数具有唯一形式：<span class="math display">\[H(X)=-C\sum_{x\in X}p(x)\log x\]</span> 其中 <span class="math inline">\(C\)</span>为常数，我们不妨归一化，令 <span class="math inline">\(C = 1\)</span>就得到了信息熵公式</p><h3 id="信息熵计算">11.2 信息熵计算</h3><h4 id="联合熵">11.2.1 联合熵</h4><p>联合熵是一个集合中变量之间不确定性的衡量手段</p><h5 id="定义-11.1联合熵">定义 11.1：联合熵</h5><p>对于俩个和离散的随机变量 <spanclass="math inline">\(X,Y\)</span>，联合熵的定义为： <spanclass="math display">\[H(X,Y)=-\sum_x\sum_yp(x,y)\log_2P(x,y)\]</span> 其中 <span class="math inline">\(x,y\)</span> 是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的特定值，相应地，<spanclass="math inline">\(P(x,y)\)</span> 是这些值一起出现的联合概率。如果<span class="math inline">\(P(x,y) = 0\)</span>，则定义 <spanclass="math display">\[P(x,y)\log_2p(x,y)\]</span> 对于两个以上的随机变量 <spanclass="math inline">\(X_1,X_2,…,X_n\)</span>，联合熵的定义为： <spanclass="math display">\[H(X_1,X_2,…,X_n)=-\sum_{x_1}\sum_{x_2}…\sum_{x_n}p(x_1,x_2,…,x_n)\log_2p(x_1,x_2…,x_n)\]</span></p><h5 id="section"></h5><h5 id="联合熵的常用性质">联合熵的常用性质</h5><p><span class="math display">\[\max_{X_i\in X}\{H(X_i)\}\leq H(X)\leq \sum_{i=1}^nH(X_i)\\X=\{X_1,X_2,…,X_n\}\]</span></p><h4 id="条件熵">11.2.2 条件熵</h4><p>条件熵量化了在一直一个随机变量 <span class="math inline">\(X\)</span>的条件下，描述为值得随机变量 <span class="math inline">\(Y\)</span>所需的信息量。基于 <span class="math inline">\(X\)</span> 条件下 <spanclass="math inline">\(Y\)</span> 的信息熵，用 <spanclass="math inline">\(H(Y|X)\)</span> 表示，也就是 <spanclass="math inline">\(H(Y|X=x)\)</span> 在 <spanclass="math inline">\(X\)</span> 取遍所有可能的 <spanclass="math inline">\(x\)</span> 之后平均的结果。</p><p>设给定随机变量 <span class="math inline">\(X,Y\)</span>，我们有：<span class="math display">\[\begin{equation*}\begin{split}H(Y|X)&amp;=-\sum_xp(x)H(Y|X=x)\\&amp;=\sum_x-p(x)\sum_yp(y|x)\log p(y|x)\\&amp;=-\sum_{x,y}p(x,y)\log\frac{p(x,y)}{p(x)}\end{split}\end{equation*}\]</span></p><h5 id="条件熵的常用性质">条件熵的常用性质</h5><p>​ &lt;1&gt; 条件熵 <span class="math inline">\(H(Y|X)\)</span>完全等于 <span class="math inline">\(0\)</span> 当且仅当 <spanclass="math inline">\(Y\)</span> 的值完全取决于 <spanclass="math inline">\(X\)</span></p><p>​ &lt;2&gt; 条件熵 <span class="math inline">\(H(Y|X)=H(X)\)</span>当且仅当 <span class="math inline">\(Y\)</span> 和 <spanclass="math inline">\(X\)</span> 相互独立</p><p>​ &lt;3&gt; 条件熵链式法则： <span class="math display">\[H(Y|X)=H(XY)-H(X)\]</span> ​ &lt;4&gt; 条件熵的 <span class="math inline">\(Bayes\)</span>规则 <span class="math display">\[H(Y|X)+H(X)=H(X|Y)+H(Y)\]</span></p><h4 id="相对熵">11.2.3 相对熵</h4><h5 id="定义-11.2相对熵">定义 11.2：相对熵</h5><p>相对熵（Relative Entropy）又称为 <spanclass="math inline">\(KL\)</span> 散度（<spanclass="math inline">\(Kullback-Leibler\ Divergence\)</span>），简称为<span class="math inline">\(KLD\)</span> 或 信息散度，信息增益。设 <spanclass="math inline">\(P(x),Q(X)\)</span> 为随机变量 <spanclass="math inline">\(X\)</span>上的两个概率分布，相对熵的定义为如下</p><p>对于离散型随机变量： <span class="math display">\[D_{KL}(P||Q)=-\sum_{i}P(i)\ln\frac{Q(i)}{P(i)}\]</span></p><p>对于连续型随机变量： <span class="math display">\[D_{KL}(P||Q)=\int_{-\infty}^{+\infty}p(x)\ln\frac{p(x)}{q(x)}\]</span> <span class="math inline">\(KL\)</span> 散度是两个概率分布<span class="math inline">\(P\)</span> 和 <spanclass="math inline">\(Q\)</span> 的非对称性的度量，可以用来度量基于<span class="math inline">\(Q\)</span> 的编码来编码来自 <spanclass="math inline">\(P\)</span> 的样本所需要的额外的位元数。</p><h5 id="相对熵的基本性质">相对熵的基本性质</h5><p>​ &lt;1&gt; 非负性：由于对数函数是上凸函数，所以根据相对熵的定义，有(吉布斯不等式) <span class="math display">\[\begin{equation*}\begin{split}D_{KL}(P||Q)&amp;=\sum_{x\in X}\log\frac{P(x)}{Q(x)}\\&amp;=-E\bigg[\log\frac{Q(x)}{P(x)}\bigg]\\&amp;\geq -\log E(\frac{Q(x)}{P(x)})\\&amp;=-\log\sum_{x\in X}P(x)\frac{Q(x)}{P(x)}\\&amp;=-\log \bigg[\sum_{x\in X}Q(x)\bigg]\\&amp;=0\end{split}\end{equation*}\]</span> ​ &lt;2&gt;不对称性：相对熵是两个概率分布的不对称性的度量，即： <spanclass="math display">\[D_{KL}(P||Q)\not =D_{KL}(Q||P)\]</span> ​ 我们常使用熵的均值来进行规约: <span class="math display">\[let\ D(P,Q)=\frac{[D_{KL}(P||Q)+D_{KL}(Q||P)]}{2}\]</span></p><h4 id="交叉熵">11.2.4 交叉熵</h4><h5 id="交叉熵的定义">交叉熵的定义</h5><p>在信息论中，基于相同事件测度的两个概率分布 <spanclass="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span>的交叉熵指的是，当基于一个“非自然”（相对于“真实的”分布 <spanclass="math inline">\(p\)</span> 而言）的概率分布 <spanclass="math inline">\(q\)</span>进行编码时，在事件集合中唯一地标识一个事件所需的平均 <spanclass="math inline">\(bit\)</span> 数，基于概率分布 <spanclass="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span> 的交叉熵定义为： <spanclass="math display">\[H(p,q)=-\int_{X}p(x)\log q(x)dr(x)=E_P(-\log q)=H(p)+D_{KL}(p||q)\]</span></p><h5 id="交叉熵的基本性质">交叉熵的基本性质</h5><p>​ &lt;1&gt; 不对称性： <span class="math display">\[H(A,B)\not =H(B,A)\]</span></p><h3 id="信息变化">11.3 信息变化</h3><h4 id="互信息">11.3.1 互信息</h4><h5 id="定义-11.3互信息mutual-information">定义 11.3：互信息（MutualInformation）</h5><p>对两个离散随机事件集 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>，事件 <spanclass="math inline">\(y_i\)</span> 的出现给出关于 <spanclass="math inline">\(x_i\)</span> 的信息量，即为互信息量。</p><p>两个离散随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的互信息定义为： <spanclass="math display">\[I(X;Y):=\sum_{x\in X}\sum_{y\inY}p(x,y)\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)\]</span> 两个连续随机变量 <span class="math inline">\(X\)</span> 和<span class="math inline">\(Y\)</span> 的互信息定义为： <spanclass="math display">\[I(X;Y):=\int_X\int_Yp(x,y)\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)dxdy\]</span> 其中 <span class="math inline">\(p(x,y)\)</span> 是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的联合密度函数，<spanclass="math inline">\(p(x),p(y)\)</span> 分别是 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的边缘概率密度函数</p><h5 id="互信息的基本性质">互信息的基本性质</h5><p>​ &lt;1&gt; 如果 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 互相独立，则显然地： <spanclass="math display">\[\log\bigg(\frac{p(x,y)}{p(x)p(y)}\bigg)=0\]</span> ​ 也即他们的互信息为 <span class="math inline">\(0\)</span></p><p>​ &lt;2&gt; 互信息是非负的</p><p>​ &lt;3&gt; 互信息是对称的： <span class="math display">\[I(X;Y)=I(Y;X)\]</span> ​ &lt;4&gt; 互信息的等价表示： <span class="math display">\[\begin{equation*}\begin{split}I(X;Y)&amp;=H(X)-H(X|Y)\\&amp;=H(Y)-H(Y|X)\\&amp;=H(X)+H(Y)-H(X,Y)\\&amp;=H(X,Y)-H(X|Y)-H(Y|X)\end{split}\end{equation*}\]</span> ​ 其中 <span class="math inline">\(H(X)\)</span> 和 <spanclass="math inline">\(H(Y)\)</span> 是边缘熵，<spanclass="math inline">\(H(X|Y)\)</span> 和 <spanclass="math inline">\(H(Y|X)\)</span> 是条件熵，<spanclass="math inline">\(H(X,Y)\)</span> 是联合熵</p><h4 id="信息增量">11.3.2 信息增量</h4><p>如果 <span class="math inline">\(P\)</span> 为数据的真实分布，<spanclass="math inline">\(Q\)</span>为数据的理论分布，根据相对熵的性质，对于离散型随机变量，我们有： <spanclass="math display">\[Gain(P,Q)=-\sum P(i)\ln \frac{Q(i)}{P(i)}\]</span> 对于连续型随机变量，我们有： <span class="math display">\[Gain(P,Q)=\int_{-\infty}^{+\infty}p(x)\ln\frac{p(x)}{q(x)}dx\]</span> 更一般地，如果 <span class="math inline">\(P\)</span> 和 <spanclass="math inline">\(Q\)</span> 是集合 <spanclass="math inline">\(X\)</span> 上的测度函数，<spanclass="math inline">\(Q\)</span> 关于 <spanclass="math inline">\(P\)</span> 绝对连续，从 <spanclass="math inline">\(P\)</span> 到 <spanclass="math inline">\(Q\)</span> 的信息增益定义为 <spanclass="math display">\[Gain(P,Q)=-\int_X\ln\frac{dQ}{dP}dP\]</span></p><h4 id="信息增益率">11.3.3 信息增益率</h4><p>信息增益率指的是属性的信息增益两相对于该属性熵值的比值 <spanclass="math display">\[GainRatio(T,P)=\frac{Gain(T,P)}{Entropy(T,P)}\]</span></p><h4 id="gini-系数">11.3.4 Gini 系数</h4><p><span class="math inline">\(Gini\)</span>系数指的是另外一种数据不纯度的测量方法，其定义如下 <spanclass="math display">\[Gini(D):=1-\sum_{i=1}^mp_i^2\]</span> 其中的 <span class="math inline">\(m\)</span> 表示数据集 <spanclass="math inline">\(D\)</span> 中类别 <spanclass="math inline">\(C\)</span> 的个数，<spanclass="math inline">\(p_i\)</span> 表示 <spanclass="math inline">\(D\)</span> 中任意一个记录属于 <spanclass="math inline">\(C_i\)</span> 的概率</p><h3 id="最大熵">11.4 最大熵</h3><h4 id="最大熵模型的定义">11.4.1 最大熵模型的定义</h4><h5 id="定义-11.6最大熵原理">定义 11.6：最大熵原理</h5><p>一个正确的概率分布该满足下面的两个条件：</p><p>​ &lt;1&gt; 服从样本数据中的一直统计证据</p><p>​ &lt;2&gt; 使熵最大化 <span class="math display">\[p^*=arg\max_{p\in P} H(p)\]</span> 其中，<span class="math inline">\(P\)</span>表示所有可能的概率分布</p><h5 id="定义-11.7最大熵模型的学习">定义 11.7：最大熵模型的学习</h5><p>设特征函数 <span class="math inline">\(f(x,y)\)</span> 满足 <spanclass="math display">\[f(x,y)=\left\{\begin{array}{**lr**}1,\ iff …\\0,\ else\end{array}\right.\]</span></p><p>特征函数 <span class="math inline">\(f(x,y)\)</span> 关于经验分布<span class="math inline">\(\overline P(X,Y)\)</span> 的期望值，用 <spanclass="math inline">\(E_{\overline P}(f)\)</span> 表示为 <spanclass="math display">\[E_{\overline P}(f)=\sum_{x,y}\overline P(x,y)f(x,y)\]</span></p><p>特征函数 <span class="math inline">\(f(x,y)\)</span> 关于条件分布<span class="math inline">\(P(X|Y)\)</span> 和经验分布 <spanclass="math inline">\(\overline P(X)\)</span> 的期望值，用 <spanclass="math inline">\(EP(f)\)</span> 表示为 <spanclass="math display">\[E_{\overline P}(f)=\sum_{x,y}\overline P(x)\overline P(y|x)f(x,y)\]</span></p><p>如果模型可以从训练集中学习，我呢吧就可以假设这两个期望相等，即：<span class="math display">\[E_{\overline P}(f)=EP(f)\]</span></p><h5 id="定义-11.7最大熵模型">定义 11.7：最大熵模型</h5><p>设满足所有约束条件的模型集合为 <span class="math display">\[E_{\overline P}(f_i)=EP(f_i)\\\]</span> 定义在条件概率分布 <span class="math inline">\(P(X|Y)\)</span>上的条件熵为 <span class="math display">\[H(P)=\sum_{x,y}\overline P(x)\overline P(y|x)f(x,y)\]</span></p><h5 id="定义-11.4.2-最大熵模型的学习">定义 11.4.2 最大熵模型的学习</h5>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息熵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十章 回归分析</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="第十章-回归分析">第十章 回归分析</h2><h3 id="一元线性回归分析">10.1 一元线性回归分析</h3><h4 id="基本步骤">10.1.1 基本步骤</h4><p>​ &lt;1&gt; 采集样本</p><p>​ &lt;2&gt; 回归分析</p><p>​ &lt;3&gt; 对回归方程显著性检验</p><p>​ &lt;4&gt; 预测与控制</p><h4 id="最小二乘估计">10.1.2 最小二乘估计</h4><p>称 <span class="math inline">\(y = a+bx+e\)</span>为一元线性回归方程，其中 <span class="math inline">\(a+bx\)</span> 表示<span class="math inline">\(y\)</span> 随 <spanclass="math inline">\(x\)</span> 线性变化的部分，<spanclass="math inline">\(e\)</span>是一切随机因素的总和，要使得这一误差最小，考察 <spanclass="math display">\[y_i=a+bx_i+e_i\]</span></p><p>令 <span class="math display">\[Q(a,b)=\sum_{i=1}^ne_i^2=\sum_{i=1}^n(a+bx_i-y_i)^2\]</span></p><p>根据微分方程极值原理，令 <span class="math display">\[\left\{\begin{array}{**lr}\frac{\partial Q}{\partial a}=-2\sum_{i=1}^n(y_i-a-bx_i)=0\\\frac{\partial Q}{\partial b}=-2\sum_{i=1}^nx_i(y_i-a-bx_i)=0\\\end{array}\right.\]</span></p><p>解得</p><p><span class="math display">\[\left\{\begin{array}{**lr}\hat a=\overline y-\hat b\\\hat b=\frac{l_{xy}}{l_{xx}}\end{array}\right.\]</span></p><p>其中 <span class="math display">\[\left\{\begin{array}{**lr}l_{xy}=\displaystyle \sum_{i=1}^n(x_i-\overline x)(y_i-\overliney)=\sum_{i=1}^nx_iy_i-\frac{1}{n}(\sum_{i=1}^ny_i)(\sum_{i=1}^nx_i)\\l_{xx}=\displaystyle \sum_{i=1}^n(x_i-\overlinex)^2=\sum_{i=1}^nx_i^2-\frac{1}{n}(\sum_{i=1}^nx_i)^2\end{array}\right.\]</span></p><p>同时，我们用 <span class="math display">\[r^2=\frac{S_R}{S_T}\]</span></p><p>表示回归直线对样本的拟合程度（<spanclass="math inline">\(|r|\)</span> 越接近1，拟合程度越高），或者可以用残差（开根号后为标准残差）来表示偏差累计<span class="math display">\[S_y^2=\frac{S_e}{n-2}=\frac{\displaystyle \sum_i(y_i-\hat y_i)^2}{n-2}\]</span></p><h4 id="显著性检验">10.1.3 显著性检验</h4><h5 id="定义">定义：</h5><p>​ &lt;1&gt; 总偏差平方和 <span class="math inline">\(S_T\)</span>:<span class="math display">\[S_T:=\sum_{i=1}^n(y_i-\overline y)^2\]</span> ​ &lt;2&gt; 回归偏差平方和 <spanclass="math inline">\(S_R\)</span> <span class="math display">\[S_R:=\sum_{i=1}^n(\hat y_i-\overline y)^2\]</span> ​ &lt;3&gt; 随机误差 <span class="math inline">\(S_e\)</span>:<span class="math display">\[S_e:=\sum_{i=1}^n(y_i-\hat y_i)^2\]</span></p><h5 id="定理-10.1">定理 10.1：</h5><p>一元线性回归分析中，总偏差平方和等于回归偏差平方和与随机误差之和，即：<span class="math display">\[S_T=S_R+S_e\]</span></p><h3 id="多元线性回归分析">10.2 多元线性回归分析</h3><h4 id="基本步骤-1">10.2.1 基本步骤</h4><p>​ 考察因变量 <span class="math inline">\(y\)</span> 与 <spanclass="math inline">\(m-1\)</span> 个自变量 <spanclass="math inline">\(x_1,x_2,…,x_{m-1}\)</span>的关系，分析如下的多元线性回归模型，即 <span class="math display">\[y=\beta_0 + \sum_{i=1}^{m-1}\beta_ix_i + e\]</span> ​ 为了方便，采用以下记号： <span class="math display">\[Y=\left[\begin{array}{}y_1\\y_2\\\ \vdots\\y_n\end{array}\right],\beta=\left[\begin{array}{}\beta_0\\\beta_1\\\ \vdots\\\beta_{m-1}\end{array}\right],e=\left[\begin{array}{}e_1\\e_2\\\ \vdots\\e_n\end{array}\right],X=\left[\begin{array}{}1 &amp; x_{11} &amp; \cdots &amp; x_{1(m-1)}\\1 &amp; x_{21} &amp; \cdots &amp; x_{2(m-1)}\\\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\\1 &amp; x_{n1} &amp; \cdots &amp; x_{n(m-1)}\end{array}\right]\]</span> 则多元线性模型可简化为 <span class="math display">\[\left\{\begin{array}{**lr}Y= X\beta + e\\e\sim\mathbb{N}(0,\sigma^2I_n)\end{array}\right.\]</span> 则相应地， <span class="math display">\[\begin{align}\hat\beta &amp;=(X^TX)^{-1}X^TY\\e &amp;=Y-\hat Y=(I-H)Y\\S_T &amp;=Y^TY-\frac{1}{n}Y^TJY\\S_e &amp;=Y^TY-\hat\beta X^TY\\S_R &amp;=S_T-S_e\\r^2 &amp;=\frac{S_R}{S_T}\end{align}\]</span></p><h4 id="偏回归系数分析">10.2.2 偏回归系数分析</h4><p>​ 回归关系显著并不意味着每个自变量 <spanclass="math inline">\(x_j\)</span> 对 <spanclass="math inline">\(y\)</span> 的影响都显著。若 <spanclass="math inline">\(x_j\)</span> 对 <spanclass="math inline">\(y\)</span> 无影响，那么线性方程中对应的 <spanclass="math inline">\(\beta_j=0\)</span>。我们对每个自变量进行以下假设检验：<span class="math display">\[H_0: \beta_j=0\\H_1:\beta_j\not =0\]</span> 我们需要计算检验统计量： <span class="math display">\[\frac{\hat\beta_j-\beta_j}{S(\hat\beta_j)}\sim t(n-m)\]</span> 所以，<span class="math inline">\(\beta_j\)</span> 的 <spanclass="math inline">\(1-\alpha\)</span> 置信区间为 <spanclass="math display">\[\hat\beta_j\pm t_{\alpha\over 2}(n-m)S(\hat\beta_j)\]</span></p><h3 id="非线性回归分析">10.3 非线性回归分析</h3><h4 id="基本步骤-2">10.3.1 基本步骤</h4><p>​ &lt;1&gt; 进行变量变换实现线性化</p><p>​ &lt;2&gt; 进行线性回归预测</p><p>​ &lt;3&gt; 进行反变换实现数据还原</p><h4 id="非线性函数">10.3.2 非线性函数</h4><h5 id="双曲线模型">双曲线模型</h5><p><span class="math display">\[\frac{1}{y}=a+\frac{b}{x}\]</span></p><h5 id="指数模型">指数模型</h5><p><span class="math display">\[y=ae^{bx}\]</span></p><h5 id="对数模型">对数模型</h5><p><span class="math display">\[y=a+blnx\]</span></p><h5 id="幂函数模型">幂函数模型</h5><p><span class="math display">\[y=ax^b\]</span></p><h4 id="线性化变换">10.3.3 线性化变换</h4><p>​ &lt;1&gt; 转化</p><p>​ &lt;2&gt; 分割</p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回归分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九章 高维数据处理</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="第九章-高维数据处理">第九章 高维数据处理</h2><h3 id="数据几何学维度">9.1数据几何学——维度</h3><h4 id="维度灾难">9.1.1 维度灾难</h4><h4 id="gauss-环定理">9.1.2 Gauss 环定理</h4><p>​ 一个均值为 <span class="math inline">\(0\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span> 的 <spanclass="math inline">\(d\)</span> 维 <spanclass="math inline">\(Gauss\)</span> 分布的密度函数为： <spanclass="math display">\[p(x) = \frac{1}{(2\pi)^{\frac{d}{2}}\sigma^d}exp(-\frac{||x||^2}{2\sigma^2})\]</span></p><h5 id="定理-9.1gauss环定理">定理 9.1：Gauss环定理</h5><p>​ 在任意方向上都有单位方差的 <span class="math inline">\(d\)</span>维球面 <span class="math inline">\(Gauss\)</span> 分布，<spanclass="math inline">\(\forall\beta\leq\sqrt d\)</span>，除了最多 <spanclass="math inline">\(3e^{-c\beta^2}\)</span> 的概率质量外，其余质量都在<span class="math display">\[\sqrt d -\beta \leq||x||\leq \sqrt d + \beta\]</span> 的环里，其中 <span class="math inline">\(c\)</span>为正常数</p><h4 id="j-l-引理">9.1.3 <span class="math inline">\(J-L\)</span>引理</h4><p><span class="math inline">\(Johnson-Lindenstrauss \ Lemma\)</span>与1984年由 <span class="math inline">\(William\ Johnson\)</span> 和<span class="math inline">\(Joram\ Lindenstrauss\)</span> 提出</p><h5 id="引理-9.1j-l-引理">引理 9.1：<spanclass="math inline">\(J-L\)</span> 引理</h5><p>​ 对给定的 <span class="math inline">\(\varepsilon \in (0,1)\)</span>以及 <span class="math inline">\(N\)</span> 维 <spanclass="math inline">\(Euclid\)</span> 空间的 <spanclass="math inline">\(m\)</span> 个点 <span class="math inline">\(\{x_1,x_2, …,x_n\}\)</span>，对于任意满足条件的 <spanclass="math inline">\(n\in \mathbb N\)</span> 且 <spanclass="math inline">\(n &gt; \frac{lnm}{ {\varepsilon^2\over 2} -{\varepsilon^3\over 3} }\)</span>，存在一个线性映射 <spanclass="math inline">\(f:\mathbb{R}^N\to\mathbb{R}^n\)</span>，将这 <spanclass="math inline">\(m\)</span> 个点，从 <spanclass="math inline">\(\mathbb{R}^N\)</span> 中映射到 <spanclass="math inline">\(\mathbb{R}^n\)</span>，同时“基本上”保持了点集成员两两之间的距离，即：<span class="math display">\[\forall x_i,x_j:(1-\varepsilon)||x_i-x_j||^2_2\leq||f(x_i)-f(x_j)||^2_2\leq (1+\varepsilon)||x_i-x_j||^2_2\\(1\leqi&lt;j\leq m)\]</span> ​ 更进一步地，这个线性映射 <spanclass="math inline">\(f\)</span> 还可以在多项式时间内给出</p><h3 id="相关性分析">9.2 相关性分析</h3><h4 id="pearson-相关系数">9.2.1 Pearson 相关系数</h4><h5 id="定义-9.1pearson相关系数pearson-r">定义9.1：Pearson相关系数（Pearson-<spanclass="math inline">\(r\)</span>）</h5><p>​ 两个样本 <span class="math inline">\(X,Y\)</span> 的 <spanclass="math inline">\(Pearson\)</span>相关系数可以用来描述两个统计样本之间的线性关系（当然也可能存在良好的非线性关系使得该系数为0），是两个容量为 <span class="math inline">\(n\)</span>的样本值的标准偏差之积的累加和除以自由度 <spanclass="math inline">\(n-1\)</span>，即 <span class="math display">\[r_{XY}:=\frac{1}{n-1}\sum_{i=1}^n(\frac{X_i-\overlineX}{s_X})(\frac{Y_i-\overline Y}{s_Y})\]</span></p><h5 id="定理-9.2pearson-r-计算公式">定理 9.2：Pearson-<spanclass="math inline">\(r\)</span> 计算公式</h5><p><span class="math display">\[r_{XY}=\frac{n\displaystyle\sum_iX_iY_i-\displaystyle\sum_iX_i\displaystyle\sum_iY_i}{\sqrt{n\displaystyle\sum_iX_i^2-(\displaystyle\sum_iX_i)^2}\sqrt {{n\displaystyle\sum_iY_i}-(\displaystyle\sum_iY_i)^2} }\]</span></p><h3 id="数据降维">9.3 数据降维</h3><h4 id="数据降维概述">9.3.1 数据降维概述</h4><p>​研究表明，当维数越来越多时，分析和处理多维数据的复杂度和成本成指数级增长；与此同时，在分析高维数据时，所需的空间样本数会随维数的增加成指数增长</p><h4 id="主成分分析-pca">9.3.2 主成分分析 PCA</h4><h5 id="定义-9.2主成分分析">定义 9.2：主成分分析</h5><p>​ 主成分分析(Principal components analysis, PCA)是线代数据分析中的标准工具，它是一种简单的非参数方法，用于从混乱的数据集中提取相关信息</p><p>​ 设有随机变量 <spanclass="math inline">\(X_1,X_2,…,X_p\)</span>，样本标准差记为 <spanclass="math inline">\(S_1,S_2,…,S_p\)</span>。首先做标准化变换： <spanclass="math display">\[C_j = \sum_{i = 1}^pa_{ji}x_i\\(j = 1,2,…,p)\]</span></p><h5 id="定义-9.3第一主成分">定义 9.3：第一主成分</h5><p>​ 若 <span class="math inline">\(C_1 = \displaystyle\sum_{i =1}^pa_{1j}x_j\)</span>，且使 <spanclass="math inline">\(Var(C_1)\)</span> 最大，则称 <spanclass="math inline">\(C_1\)</span> 为第一主成分</p><h5 id="定义-9.4第二主成分">定义 9.4：第二主成分</h5><p>​ 若 <span class="math inline">\(C_2 = \displaystyle\sum_{i =1}^pa_{2j}x_j\)</span>，<spanclass="math inline">\((a_{21},a_{22},…,a_{2p})\)</span> 与 <spanclass="math inline">\((a_{11},a_{12},…,a_{1p})\)</span> 垂直且使 <spanclass="math inline">\(Var(C_2)\)</span> 次大，则称 <spanclass="math inline">\(C_2\)</span> 为第二主成分</p><h5 id="意">意：</h5><p>​ &lt;1&gt; 各成分间互不相关，即 <span class="math display">\[Corr(C_i,C_j) = 0\\(i\not = j)\]</span> ​ &lt;2&gt; 组合系数构成的向量 <spanclass="math inline">\((a_{i1},a_{i2},…,a_{ip})\)</span> 为单位向量</p><p>​ &lt;3&gt; 主成分的方差是依次递减的，即 <span class="math display">\[Var(C_1)\geq Var(C_2)\geq …\geq Var(C_p)\]</span></p><p>​ &lt;4&gt; 总方差不增不减（主成分只是原变量的线性组合），即 <spanclass="math display">\[\sum_{i = 1}^pVar(C_i)=\sum_{i=1}^pVar(x_i)=p\]</span> ​ &lt;5&gt; 主成分与原变量的相关系数满足 <spanclass="math display">\[Corr(C_i,x_j) = a_{ij}\]</span> ​ &lt;6&gt; 令 <spanclass="math inline">\(X_1,X_2,…,X_p\)</span> 的相关矩阵为 <spanclass="math inline">\(R\)</span>，<spanclass="math inline">\((a_{i1},a_{i2}.…,a_{ip})\)</span> 则是相关矩阵<span class="math inline">\(R\)</span> 的第 <spanclass="math inline">\(i\)</span> 个特征向量。且特征值 <spanclass="math inline">\(l_i\)</span> 就是第 <spanclass="math inline">\(i\)</span> 主成分的方差</p><h4 id="线性判别分析-lda">9.3.3 线性判别分析 LDA</h4><p>​ 判别分析是一种统计技术，其中，线性判别分析 （Linear DiscriminantAnalysis）是对 <span class="math inline">\(Fisher\)</span>线性鉴别方法的归纳</p><h5 id="定义-9.5线性判别分析">定义 9.5：线性判别分析</h5><p>​线性判别分析是一种找到最佳分离两个或者多个类的变量的线性组合的方法</p><h4 id="局部线性嵌入-lle">9.3.4 局部线性嵌入 LLE</h4><h5 id="定义-9.6局部线性嵌入">定义 9.6：局部线性嵌入</h5><p>局部线性嵌入（Locally LinearEmbedding，LLE）消除了估计广泛分析的数据点之间成对距离的需要，从局部线性拟合中恢复全局非线性结构</p><h4 id="t-分布邻域嵌入-t-sne">9.3.5 t 分布邻域嵌入 t-SNE</h4><h5 id="定义-9.7t-分布邻域嵌入">定义 9.7：t-分布邻域嵌入</h5><p>​ t-分布邻域嵌入（t-distributed stochastic neighborembedding，t-SNE）将数据点间的距离转化为概率分布并且以此来表达点与点之间的相似度，算法使得高低维数据分布尽可能接近为目标</p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纬度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章 多维概率分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%A4%9A%E7%BB%B4%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E5%A4%9A%E7%BB%B4%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第八章-多维概率分布">第八章 多维概率分布</h2><h3 id="多维概率分布">8.1 多维概率分布</h3><h4 id="联合分布">8.1.1 联合分布</h4><ol type="1"><li><p>二维随机变量</p><p>设样本空间为 <span class="math inline">\(\Omega = e\)</span>，<spanclass="math inline">\(X = X(e)\)</span>，和 <spanclass="math inline">\(Y = Y(e)\)</span>，是定义在 <spanclass="math inline">\(\Omega\)</span> 上的随机变量，由他们构成的一个变量<span class="math inline">\((X,Y)\)</span>叫做二维随机变量或二维随机向量</p></li></ol><h5 id="定义-8.1联合分布">定义 8.1：联合分布</h5><p>设 <span class="math inline">\((X,Y)\)</span> 是二维随机变量， <spanclass="math inline">\(x,y\)</span> 是任意实数，称二元函数 <spanclass="math display">\[F(x,y) = P(X\leq x\cap Y\leq y) = P(X\leq x,Y\leq y)\]</span> 为二元随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布函数</p><h5 id="定义-8.2二维离散随机变量概率分布律">定义8.2：二维离散随机变量概率分布律</h5><p>若二维随机变量的可能取值只有有限个或者可列无穷个，则称二维随机变量为离散型随机变量。二维离散型随机变量<span class="math inline">\((X,Y)\)</span> 的所有可能取值为 <spanclass="math inline">\((x_i,y_i),(i=1,2,…,n)\)</span>，则称 <spanclass="math display">\[P\{X = x_i,Y = y_i\} = p_{ij}\]</span> 为二维离散行随机变量 <spanclass="math inline">\((X,Y)\)</span> 的概率分布律，简称分布律</p><p>注意，二维离散随机变量的概率分布仍然满足概率的公理化定义：非负性，规范性，可列可加性（级数）</p><h5 id="定义-8.3二位连续随机变量的概率密度">定义8.3：二位连续随机变量的概率密度</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span>的分布函数为 <spanclass="math inline">\(F(x,y)\)</span>，如果存在非负函数 <spanclass="math inline">\(f(x,y)\)</span>，使得 <spanclass="math inline">\(\forall x,y\in\mathbb{R}\)</span>，都有 <spanclass="math display">\[F(x,y) = \int_{-\infty}^{x}\int_{-\infty}^{y}f(s,t)dsdt\]</span> 则称 <span class="math inline">\((X,Y)\)</span>为二位连续随机变量，并称非负函数 <spanclass="math inline">\(f(x,y)\)</span> 为 <spanclass="math inline">\((X,Y)\)</span> 的概率密度函数，或称 <spanclass="math inline">\(f(x,y)\)</span> 为 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的联合概率密度</p><p>注意，二维连续随机变量的概率分布仍然满足概率的公理化定义：非负性，规范性，可列可加性（级数），在此基础上，我们还有<span class="math display">\[f(x,y) = \frac{\partial^2F(x,y)}{\partial x\partial y}\]</span></p><h4 id="边缘分布">8.1.2 边缘分布</h4><h5 id="定义-8.4二维随机变量的边缘分布">定义8.4：二维随机变量的边缘分布</h5><p>设 <span class="math inline">\((X,Y)\)</span>为二维随机变量，称一维随机变量 <span class="math inline">\(X\)</span> 或<span class="math inline">\(Y\)</span> 的概率分布为二维随机变量 <spanclass="math inline">\((X,Y)\)</span> 关于 <spanclass="math inline">\(X\)</span> 或 <spanclass="math inline">\(Y\)</span> 对应的边缘分布，分别记作 <spanclass="math inline">\(F_X(x), F_Y(y)\)</span></p><h5 id="定义-8.5二维离散随机变量的边缘分布律">定义8.5：二维离散随机变量的边缘分布律</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span> 的分布律为<span class="math inline">\(p_{ij}\)</span>，那么对于随机变量 <spanclass="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>其各自的分布律对于固定的 <span class="math inline">\(i,j =1,2,…\)</span>， 满足 <span class="math display">\[P\{X=x_i\} = \sum_jp_{ij}=p_i\]</span> 则称 <span class="math inline">\(p_i\)</span> 为随机变量 <spanclass="math inline">\((X,Y)\)</span> 的边缘分布律。</p><h5 id="定义-8.6二维连续随机变量的边缘概率密度">定义8.6：二维连续随机变量的边缘概率密度</h5><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span>的概率密度为 <span class="math inline">\(f(x,y)\)</span>，边缘概率密度<span class="math inline">\(f_X(x)\)</span> 和 <spanclass="math inline">\(f_Y(y)\)</span> 定义为 <spanclass="math display">\[\begin{align}&amp;f_X(x) = \int_{-\infty}^{+\infty}f(x,y)dy\\&amp;f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx\end{align}\]</span></p><h4 id="条件分布">8.1.3 条件分布</h4><h5 id="定义-8.7离散型随机变量的条件概率">定义8.7：离散型随机变量的条件概率</h5><p>设 <span class="math inline">\((X,Y)\)</span>是二维离散型随机变量，其分布律为 <spanclass="math inline">\(P\{X=x_i,Y=y_i\}=p_{ij}\)</span>，其边缘概率分别为<span class="math inline">\(p_{i\cdot}\ p_{\cdotj}\)</span>，则条件概率定义为 <span class="math display">\[\begin{align}&amp;P\{X=x_i|Y=y_i\}=\frac{P\{X=x_i,Y=y_i\}}{P\{Y=y_i\}} =\frac{p_{ij}}{p_{\cdot j}}\\&amp;P\{Y=y_i|X=x_i\}=\frac{P\{X=x_i,Y=y_i\}}{P\{X=x_i\}} =\frac{p_{ij}}{p_{i \cdot}}\end{align}\]</span></p><h5 id="定义-8.8连续型随机变量的条件概率">定义8.8：连续型随机变量的条件概率</h5><p>设 <span class="math inline">\((X,Y)\)</span>是二维连续型随机变量，其概率密度为 <spanclass="math inline">\(f(x,y)\)</span>，其边缘改率分别为 <spanclass="math inline">\(f_X(x), f_Y(y)\)</span>，则条件概率定义为 <spanclass="math display">\[\begin{align}&amp;f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)}\\&amp;f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)}\\\end{align}\]</span> 连续型随机变量的条件概率分布定义为 <spanclass="math display">\[\begin{align}&amp;F_{X|Y}(x|y) = P\{X\leqx|Y=y\}=\int_{-\infty}^{x}\frac{f(x,y)}{f_Y(y)}dx\\&amp;F_{Y|X}(y|x) = P\{Y\leqy|X=x\}=\int_{-\infty}^{y}\frac{f(x,y)}{f_X(x)}dy\\\end{align}\]</span></p><h4 id="独立性">8.1.4 独立性</h4><h5 id="定义-8.9独立性">定义 8.9：独立性</h5><p>二维随机变量 <span class="math inline">\((X,Y)\)</span>的分布函数及其边缘分布函数分别设为 <spanclass="math inline">\(F(x,y)\)</span> 和 <spanclass="math inline">\(F_X(x),\ F_Y(y)\)</span>，若 <spanclass="math display">\[\forall (x,y):F(x,y) = F_X(x)F_Y(y)\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h5 id="定义-8.10离散随机变量的独立性">定义8.10：离散随机变量的独立性</h5><p>离散二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布律和边缘分布律分别设为 <spanclass="math inline">\(p_{ij}\)</span> 和 <spanclass="math inline">\(p_{i\cdot},\ p_{\cdot j}\)</span>，若 <spanclass="math display">\[\forall (i，j):p_{ij} = p_{i\cdot}\times p_{\cdot j}\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h5 id="定义-8.11连续随机变量的独立性">定义8.11：连续随机变量的独立性</h5><p>连续二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布律和边缘分布律分别设为 <spanclass="math inline">\(f(x,y)\)</span> 和 <spanclass="math inline">\(f_X(x),\ f_Y(y)\)</span>，若 <spanclass="math display">\[\forall (x,y):f(x,y) = f_X(x)\times f_Y(y)\]</span> 则称随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 是相互独立的</p><h3 id="多维分布的矩">8.2 多维分布的矩</h3><h4 id="独立性的多维矩">8.2.1 独立性的多维矩</h4><h5 id="定理-8.1">定理 8.1：</h5><p>已知 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则有： <spanclass="math display">\[E(XY) = E(X)E(Y)\]</span></p><h5 id="定理-8.2">定理 8.2：</h5><p>已知 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则有： <spanclass="math display">\[D(X+Y) = D(X) + D(Y)\]</span></p><h4 id="相关性的多维矩">8.2.2 相关性的多维矩</h4><h5 id="定义-8.12协方差">定义 8.12：协方差</h5><p>随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的协方差定义为 <spanclass="math display">\[Cov(X,Y)\triangleq E(X-E(X))E(Y-E(Y))\]</span></p><h5 id="定理-8.3协方差计算">定理 8.3：协方差计算</h5><p><span class="math display">\[Cov(X,Y) = E(XY)-E(X)E(Y)\]</span></p><h5 id="推论-8.1">推论 8.1：</h5><p>对于任意随机变量 <spanclass="math inline">\(X,Y,Z\)</span>，不难得出： <spanclass="math display">\[\begin{align}&amp;Cov(X,Y)=Cov(Y,X)\\&amp;Cov(a,a)=0\\&amp;Cov(aX,bY)=abCov(X,Y)\\&amp;Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\end{align}\]</span></p><h5 id="推论-8.2">推论 8.2：</h5><p>对于任意随机变量 <span class="math inline">\(X,Y:\)</span> <spanclass="math display">\[D(X\pm Y)=D(X)+D(Y)\pm 2Cov(X,Y)\]</span></p><h5 id="推论-8.3">推论 8.3：</h5><p>若 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 相互独立，则： <spanclass="math display">\[Cov(X,Y) = 0\]</span></p><h5 id="定义-8.13相关系数">定义 8.13：相关系数</h5><p>协方差的数值会收到 <span class="math inline">\(X,Y\)</span>的量纲的影响，为了更加客观地度量变量之间的关系，我们将协方差归一化，定义为相关系数。若随机变量<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的数学期望和方差都存在，则称： <spanclass="math display">\[\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\\\]</span> 为随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的相关系数</p><h5 id="定理-8.4schwarz不等式">定理 8.4：Schwarz不等式</h5><p><span class="math display">\[Cov^2(X,Y)\leq \sigma^2_X\sigma^2_Y\\\]</span></p><h5 id="推论-8.4相关系数归一性">推论 8.4：相关系数归一性</h5><p><span class="math display">\[|\rho_{XY}|\leq 1\\\]</span></p><h5 id="定理-8.5线性相关定理">定理 8.5：线性相关定理</h5><p><span class="math inline">\(|\rho_{XY}|=1\)</span> 的充要条件是 <spanclass="math inline">\(X,Y\)</span> 几乎处处线性相关</p><h3 id="常用二维分布">8.3 常用二维分布</h3><h4 id="二维均匀分布">8.3.1 二维均匀分布</h4><h5 id="定义-8.14二维均匀分布">定义 8.14：二维均匀分布</h5><p>设 <span class="math inline">\(G\)</span>是平面上的有界闭区域，其面积为 <spanclass="math inline">\(A\)</span>，若二维随机变量 <spanclass="math inline">\((X,Y)\)</span> 具有概率密度 <spanclass="math display">\[\begin{align}&amp;\forall(x,y)\in G:f(x,y)=\frac{1}{A}\\&amp;\forall(x,y)\not \in G:f(x,y) = 0\\\end{align}\]</span> 则称 <span class="math inline">\((X,Y)\)</span> 在 <spanclass="math inline">\(G\)</span> 上二维均匀分布</p><h4 id="二维正态分布">8.3.2 二维正态分布</h4><p>如果随机变量 <span class="math inline">\((X,Y)\)</span> 的概率密度为<span class="math display">\[\begin{gather}&amp;f(x,y) =\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho)^2}\bigg[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}\bigg]}\\&amp;(-\infty&lt;x,y&lt;+\infty)\\\end{gather}\]</span> 则称 <span class="math inline">\((X,Y)\)</span> 服从参数为<span class="math inline">\(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho\)</span>的二维正态分布，记为 <span class="math display">\[(X,Y)\sim \mathbb{N}(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\\\]</span></p><h3 id="函数的概率分布">8.4 函数的概率分布</h3><h4 id="离散函数的分布">8.4.1 离散函数的分布</h4><h4 id="连续函数的分布">8.4.2 连续函数的分布</h4><h5 id="定理-8.6函数的分布定理">定理 8.6：函数的分布定理</h5><p><span class="math inline">\(X\)</span> 的密度函数为 <spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infty&lt;x&lt;+\infty\)</span>，<spanclass="math inline">\(Y = g(X)\)</span> 严格单调，即 $g'(x)&gt;0 $ 或 $g'(x)&lt;0$，则 <span class="math inline">\(Y\)</span> 的密度函数为：<span class="math display">\[f_Y(x) = f_X(h(y))|h&#39;(y)|\ \ \ (a&lt;y&lt;b)\\\]</span> 其中 <span class="math display">\[\begin{align}&amp;a = min(g(-\infty),g(+\infty))\\ &amp;b = max(g(-\infty),\g(+\infty))\\ &amp;h(y) = g^{-1}(x)\end{align}\]</span></p><h4 id="极值函数的分布">8.4.3 极值函数的分布</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩</tag>
      
      <tag>概率分布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章 假设检验</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="第七章-假设检验">第七章 假设检验</h2><h3 id="假设检验概述">7.1 假设检验概述</h3><h4 id="基本概念">7.1.1 基本概念</h4><ol type="1"><li><p>原假设 (Null Hypothesis) <spanclass="math inline">\(H_0\)</span>: <span class="math inline">\(\mu =\mu_0\)</span></p></li><li><p>备择假设（Alternative Hypothesis）<spanclass="math inline">\(H_1\)</span>：<span class="math inline">\(\mu\not= \mu_0\)</span></p></li><li><p>显著性水平（Significance Level）<spanclass="math inline">\(\alpha\)</span>：小概率水平</p></li><li><p>确定假设的界限 <spanclass="math inline">\(\mathcal{K}\)</span></p></li></ol><p>​ 5. 假设检验的拒绝域 <span class="math inline">\(\mathscr{D}\subseteq \mathbb{X}^n\)</span></p><h4 id="两种错误">7.1.2 两种错误</h4><h5 id="第一类错误">1. 第一类错误</h5><h5 id="第二类错误">2. 第二类错误</h5><h4 id="显著性水平与p值">7.1.3 显著性水平与p值</h4><h5 id="使用p值进行假设检验的基本法则是">1.使用p值进行假设检验的基本法则是：</h5><p>​ 若 <span class="math inline">\(p\)</span> 值小于 $$ , 则拒绝 <spanclass="math inline">\(H_0\)</span>，否则就不拒绝 <spanclass="math inline">\(H_0\)</span> (<spanclass="math inline">\(\alpha\)</span> 决定是否显著，<spanclass="math inline">\(p\)</span> 表现有多显著)</p><p>​ <span class="math inline">\(p\)</span>值越小，则认为拒绝原假设的理由越充分</p><h4 id="单边与双边检验">7.1.4 单边与双边检验</h4><h5 id="双边two-tail检验">1. 双边（Two-Tail）检验</h5><p><span class="math display">\[H_0:\mu=\mu_0,\ H_1:\mu=\mu_1\]</span></p><h5 id="单边one-tail假设">2. 单边（One-Tail）假设</h5><p><span class="math display">\[H_0:\mu\leq\mu_0,\ H_1:\mu&gt;\mu_0\]</span></p><h4 id="基本步骤">7.1.5 基本步骤</h4><ol type="1"><li><p>建立原假设和备选假设，选择合适的 <spanclass="math inline">\(p\)</span> 值</p></li><li><p>对总体抽样，获取总体样本值</p></li><li><p>选取统计量（其抽样分布要明确，不含参数）</p></li><li><p>分两种（或同时）方法进行决策判断</p></li></ol><p>​ &lt;1&gt; 利用 <span class="math inline">\(\alpha\)</span>决定什么是拒绝域</p><p>​ &lt;2&gt; 利用样本数据计算 <span class="math inline">\(p\)</span>值，将其与 <span class="math inline">\(\alpha\)</span> 比较</p><h3 id="参数假设检验-先假定分布形式再来估计参数">7.2 参数假设检验(先假定分布形式，再来估计参数)</h3><h4 id="z-检验-大样本或方差已知">7.2.1 Z 检验 (大样本或方差已知)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(Z\sim \mathbb{N}(0,\1)\)</span>，计算统计量数值 <spanclass="math inline">\(z\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="t-检验-小样本且-sigma2-未知">7.2.2 t 检验 (小样本且 <spanclass="math inline">\(\sigma^2\)</span> 未知)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(t\simt(n&#39;)\)</span>，计算统计量数值 <spanclass="math inline">\(t\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="chi2检验-判断方差变化是否显著">7.2.3 <spanclass="math inline">\(\chi^2\)</span>检验 (判断方差变化是否显著)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(\chi^2\sim\chi^2(n&#39;)\)</span>，计算统计量数值 <spanclass="math inline">\(\chi^2\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h4 id="f检验-判断方差比变化是否显著">7.2.4 F检验(判断方差比变化是否显著)</h4><ol type="1"><li><p>建立有关均值的备择假设和原假设，选择合适的显著性水平 <spanclass="math inline">\(\alpha\)</span></p></li><li><p>建立统计量 <span class="math inline">\(F\sim F(n_1,\n_2)\)</span>，计算统计量数值 <spanclass="math inline">\(F\)</span></p></li><li><p>根据统计量数值和显著性水平 <spanclass="math inline">\(\alpha\)</span> 决定拒绝域</p></li><li><p>判断是否落入拒绝域，有需要的话再考察 <spanclass="math inline">\(p\)</span> 值</p></li></ol><h3 id="非参数假设检验对总体分布形式未知">7.3非参数假设检验（对总体分布形式未知）</h3><h4 id="符号检验sign-test">7.3.1 符号检验（Sign Test）</h4><h4 id="秩和检验wilcoxon-rank-sum">7.3.2 秩和检验（WilcoxonRank-Sum）</h4><h5 id="秩rank指的是两组数据混合排序后的序号均值">1.秩（Rank）指的是两组数据混合排序后的序号均值</h5><h5 id="定理7.1大样本逼近">定理7.1：大样本逼近</h5><p>当两样本容量较大时（经验要求 <spanclass="math inline">\(n_1\)</span>, <span class="math inline">\(n_2 &gt;10\)</span> ），秩和统计检验量 <span class="math inline">\(T\)</span>近似服从 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>，其中： <spanclass="math display">\[\mu=\frac{n_1(n_1+n_2+1)}{2}\\\sigma^2=\frac{n_1n_2(n_1+n_2+1)}{12}\]</span> 则： <span class="math display">\[U=\frac{T-\mu}{\sigma}\sim\mathbb{N}(0,\ 1)\]</span> 所以秩和检验的拒绝域为 <spanclass="math inline">\(|U|&gt;z_{\frac{\alpha}{2}}\)</span></p><h4 id="偏度峰度检验">7.3.3 偏度峰度检验</h4><h5 id="偏度与峰度">1. 偏度与峰度</h5><p>偏度： <span class="math display">\[\nu_1\triangleq\frac{E((X-E(X))^3)}{(Var(X))^{\frac{3}{2}}}=E[(\frac{X-E(X)}{\sqrt{Var(X)}})^{3}]\\\]</span> 峰度： <span class="math display">\[\nu_1\triangleq\frac{E((X-E(X))^4)}{(Var(X))^{2}}=E[(\frac{X-E(X)}{\sqrt{Var(X)}})^{4}]\\\]</span></p><h5 id="section">2.</h5><h4 id="chi2拟合优度检验">7.3.4 <spanclass="math inline">\(\chi^{2}\)</span>拟合优度检验</h4><h5 id="定理7.2pearson定理">定理7.2：Pearson定理</h5><h4 id="chi2独立性检验">7.3.5 <spanclass="math inline">\(\chi^{2}\)</span>独立性检验</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>假设检验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 参数估计</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="第六章">第六章</h2><h3 id="点估计">6.1 点估计</h3><h4 id="矩估计">6.1.1 矩估计</h4><h5 id="定义6.1矩估计">定义6.1：矩估计</h5><p>随机变量 <span class="math inline">\(X\)</span>服从某总体分布，其中包含 <span class="math inline">\(k\)</span>个未知参数，<span class="math inline">\(θ_i(i = 1, 2, … , k), \ μ_l =E(X^l)\)</span> 为总体的 <span class="math inline">\(l\)</span>阶矩。<span class="math inline">\(X_i(i = 1, 2, … , n)\)</span> 是来自于<span class="math inline">\(X\)</span>的样本，那么求解以下方程组得到的估计值 <span class="math inline">\(θ_i(i= 1, 2, …, k)\)</span> 的方法称为矩估计法。 <spanclass="math display">\[μ_i = A_i(i = 1, 2, …， k)\]</span></p><h5 id="定理6.1-矩估计定理">定理6.1 矩估计定理</h5><p>设随机变量 <span class="math inline">\(X\)</span> 的数学期望和 <spanclass="math inline">\(μ\)</span> 和方差 <spanclass="math inline">\(σ^2\)</span> 都存在，且有估计量 <spanclass="math inline">\(σ^2&gt;0\)</span>。<spanclass="math inline">\(μ\)</span> 和 <spanclass="math inline">\(σ^2\)</span> 均未知。<spanclass="math inline">\(X_i(i = 1, 2, …， n)\)</span> 为来自 <spanclass="math inline">\(X\)</span> 的样本。则 <spanclass="math inline">\(μ\)</span> 和 <spanclass="math inline">\({σ}^2\)</span> 的估计量分别为 <spanclass="math display">\[\hat{μ} = \overline{X}\\\hat{σ}^2 = \frac{1}{n}\sum_{i = 1}^{n}(X_i - \overline{X})^2\]</span></p><h4 id="极大似然估计">6.1.2 极大似然估计</h4><h5 id="定义6.2极大似然估计">定义6.2：极大似然估计</h5><p><span class="math inline">\(x\)</span> 是样本值，<spanclass="math inline">\(θ\)</span> 为需要估计的总体参数，<spanclass="math inline">\(L\)</span>为似然函数，极大似然估计的等式定义如下： <span class="math display">\[\hatθ_{MLE}(x) = \underset{θ}{arg\max}L(θ)\]</span> 其中，对于随机变量 <span class="math inline">\(X\)</span>,似然函数 <span class="math inline">\(L(θ) = \displaystyle\prod_{i =1}^nP(X = x)\)</span></p><h5id="定理6.2poisson分布极大似然估计定理">定理6.2：Poisson分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\pi(\lambda)\)</span> , <spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本,则<spanclass="math inline">\(\hat{\lambda} = \overline{X}\)</span></p><h5id="定理6.3exponential分布极大似然估计定理">定理6.3：Exponential分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span> ,<span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本, 则<spanclass="math inline">\(\hat{\lambda} =\frac{1}{\overline{X}}\)</span></p><h5id="定理6.4gauss分布极大似然估计定理">定理6.4：Gauss分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>, <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本, 则 <spanclass="math display">\[\hat{μ} = \overline{X}\\\hat{σ}^2 = \frac{1}{n}\sum_{i = 1}^{n}(X_i - \overline{X})^2\]</span></p><h5id="定理6.5uniform分布极大似然估计定理">定理6.5：Uniform分布极大似然估计定理</h5><p>设 <span class="math inline">\(X\sim\mathbb{U}(a,b)\)</span> , <spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本, 则 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的极大似然估计分别为 <spanclass="math inline">\(min_i{X_i}\)</span> ，<spanclass="math inline">\(max_i{X_i}\)</span></p><h4 id="截尾估计">6.1.3 截尾估计</h4><h4 id="评估分析">6.1.4 评估分析</h4><h5 id="定义6.3估计的无偏性">定义6.3：估计的无偏性</h5><p>无偏估计指的是估计量抽样分布的数学期望等于被估总体参数。即对于 <spanclass="math inline">\(\hat\theta(X_1,\ X_2, …，\ X_n)\)</span>，<spanclass="math inline">\(E(\hat\theta)\)</span> 存在且有 <spanclass="math display">\[E(\hat{\theta}) = \theta\]</span> 则称 <span class="math inline">\(\hat\theta\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的无偏估计</p><h5 id="引理6.1">引理6.1：</h5><p><span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本，<spanclass="math inline">\(g(x)\)</span> 是 <spanclass="math inline">\(x\)</span> 的函数且 <spanclass="math inline">\(E(g(X_i))\)</span> 和 <spanclass="math inline">\(Var(g(X_i))\)</span> 存在，则 <spanclass="math display">\[\begin{align}E(\sum_{i = 1}^ng(X_i)) &amp;= n(E(g(X_1)))\\Var(\sum_{i = 1}^ng(X_i)) &amp;= n(Var(g(X_1)))\end{align}\]</span></p><h5 id="定理6.6">定理6.6:</h5><p>设总体 <span class="math inline">\(X\)</span> 的均值是 <spanclass="math inline">\(\mu\)</span> ，方差为 <spanclass="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span>为 <spanclass="math inline">\(X\)</span> 的一个样本，则：</p><p>（1）<span class="math inline">\(E(\overline{X}) = \mu\)</span> （<span class="math inline">\(\overline X\)</span> 是 <spanclass="math inline">\(\mu\)</span> 的无偏估计）</p><p>（2）<spanclass="math inline">\(Var(\overline{X})=\frac{\sigma^2}{n}\)</span></p><p>（3）<span class="math inline">\(E(S^2)=\sigma^2\)</span> （<spanclass="math inline">\(S^2\)</span> 是 <spanclass="math inline">\(\sigma^2\)</span> 的无偏估计）</p><p>其中，<span class="math inline">\(S^2\)</span>要考虑偏差，有 <spanclass="math inline">\(S^2 = \displaystyle \frac{1}{n -1}\displaystyle\sum_{i = 1}^{n}(X_i - \overline{X})^2\)</span></p><h5 id="定理6.7">定理6.7:</h5><p>设总体 <span class="math inline">\(X\)</span> 的 <spanclass="math inline">\(k\)</span> 阶矩 <span class="math inline">\(\mu_k= E(X^k)\)</span>，<span class="math inline">\(k \geq 1\)</span>存在，无论总体服从什么分布，<span class="math inline">\(k\)</span>阶样本矩<span class="math inline">\(A_k =\frac{1}{n}\displaystyle\sum_{i = 1}^nX_i^k\)</span> 是 <spanclass="math inline">\(k\)</span> 阶总体矩 <spanclass="math inline">\(\mu_k\)</span> 的无偏估计</p><h5 id="定义6.4估计的有效性">定义6.4：估计的有效性</h5><p>对于总体未知参数的两个无偏估计量，相应抽样分布的方差小视为更有效，即，若<span class="math inline">\(\hat\theta_1，\hat\theta_2\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的两个无偏估计，有 <spanclass="math display">\[Var(\hat\theta_1) &lt; Var(\hat\theta_2)\]</span> 则称 <span class="math inline">\(\hat\theta_1\)</span> 比<span class="math inline">\(\hat\theta_2\)</span> 更有效</p><h5id="定义6.5估计的一致性类比于一致收敛">定义6.5：估计的一致性（类比于一致收敛）</h5><p>一致性是指随着样本容量 <span class="math inline">\(n\)</span>增大，估计量越来越接近总体参数。即对于任意 <spanclass="math inline">\(\epsilon &gt; 0\)</span> ，有 <spanclass="math display">\[\lim_{n\rightarrow\infty}P(|\hat\theta - \theta|&lt;\epsilon) = 1\]</span> 则称 <span class="math inline">\(\hat\theta\)</span> 是 <spanclass="math inline">\(\theta\)</span> 的一致性估计量</p><h3 id="区间估计">6.2 区间估计</h3><h5 id="定义6.6置信区间">定义6.6：置信区间</h5><p>设总体 <span class="math inline">\(X\)</span> 的分布<spanclass="math inline">\(\ F(x;\theta)\)</span> 中含有未知参数 <spanclass="math inline">\(\theta\)</span> ，若存在样本的两个估计量 <spanclass="math inline">\(\underline{\theta}(X_i)\)</span> 和 <spanclass="math inline">\(\overline{\theta}(X_i)\)</span> <spanclass="math inline">\((i = 1, \ 2,\ …,\ n)\)</span> 使得对于给定的 <spanclass="math inline">\(\alpha\ (0 &lt; \alpha &lt;1)\)</span> ，有 <spanclass="math display">\[P(\underline\theta&lt;\theta&lt;\overline\theta) = 1 - \alpha\]</span> 则称随机区间 <spanclass="math inline">\((\underline\theta，\overline\theta)\)</span>为总体参数 <span class="math inline">\(\theta\)</span> 的置信水平为<span class="math inline">\(1 - \alpha\)</span>的（双侧）置信区间，<spanclass="math inline">\(\underline\theta\)</span> 和 $ $分别为置信下限和置信上限</p><h4 id="单总体均值区间估计">6.2.1 单总体均值区间估计</h4><h5 id="估计条件-1-xsimmathbbnmusigma2-且-sigma2-已知mu-未知">估计条件 1<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span> 已知，<spanclass="math inline">\(\mu\)</span> 未知</h5><h5 id="估计条件-2.-xsimmathbbnmusigma2-且-sigma2mu-未知">估计条件 2.<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu\)</span> 未知</h5><h5 id="估计条件-3.-x-不服从gauss分布但是样本容量较大大于30">估计条件 3.<span class="math display">\[X\]</span>不服从Gauss分布，但是样本容量较大（大于30）</h5><h4 id="单总体方差区间估计">6.2.2 单总体方差区间估计</h4><h5 id="估计条件-1.-xsimmathbbnmusigma2-且-sigma2mu-未知">估计条件 1.<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu\)</span> 未知</h5><h4 id="双总体均值差区间估计">6.2.3 双总体均值差区间估计</h4><h5id="估计条件-1.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-已知">估计条件1. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu_1,\ \mu_2\)</span> 未知，<spanclass="math inline">\(\sigma_1^2,\ \sigma_2^2\)</span> 已知</h5><h5id="估计条件-2.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-未知但-sigma_12sigma_22">估计条件2. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span><spanclass="math inline">\(，\)</span><span class="math inline">\(\mu_1,\\mu_2\)</span> 未知，<span class="math inline">\(\sigma_1^2,\\sigma_2^2\)</span> 未知，但 <spanclass="math inline">\(\sigma_1^2=\sigma_2^2\)</span></h5><h5id="估计条件3.-x-和-y-不服从gauss分布但是样本容量均较大大于30">估计条件3.<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span>不服从Gauss分布，但是样本容量均较大（大于30）</h5><h4 id="双总体方差比区间估计">6.2.4 双总体方差比区间估计</h4><h5id="估计条件-1.-xsimmathbbnmu_1sigma_12-ysimmathbbnmu_2sigma_22-且-sigma2mu_1-mu_2-未知sigma_12-sigma_22-未知">估计条件1. <spanclass="math inline">\(X\sim\mathbb{N}(\mu_1,\sigma_1^2)\)</span> ，<spanclass="math inline">\(Y\sim\mathbb{N}(\mu_2,\sigma_2^2)\)</span> 且<span class="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(\mu_1,\ \mu_2\)</span> 未知，<spanclass="math inline">\(\sigma_1^2,\ \sigma_2^2\)</span> 未知</h5><h4 id="二项分布区间估计考察bernoulli分布正态逼近定理">6.2.5二项分布区间估计（考察Bernoulli分布正态逼近定理）</h4><h4 id="单侧置信区间">6.2.6 单侧置信区间</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参数估计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 抽样分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-抽样分布">第五章 抽样分布</h2><h3 id="数据抽样">5.1 数据抽样</h3><h4 id="数据分析">5.1.1 数据分析</h4><h5 id="全体数据-rightarrow-整体结论">1. 全体数据 <spanclass="math inline">\(\rightarrow\)</span> 整体结论</h5><h5id="全体数据-rightarrow-样本数据-rightarrow-样本结论-rightarrow-整体结论">1.全体数据 <span class="math inline">\(\rightarrow\)</span> 样本数据 <spanclass="math inline">\(\rightarrow\)</span> 样本结论 <spanclass="math inline">\(\rightarrow\)</span> 整体结论</h5><h4 id="抽样方法">5.1.2 抽样方法</h4><h5 id="简单随机抽样">1. 简单随机抽样</h5><h5 id="系统抽样">2. 系统抽样</h5><h5 id="整群抽样">3. 整群抽样</h5><h5 id="分层抽样">4. 分层抽样</h5><h4 id="抽样应用示例">5.1.3 抽样应用示例</h4><h3 id="矩与抽样分布">5.2 矩与抽样分布</h3><h4 id="矩与统计量">5.2.1 矩与统计量</h4><h5 id="定理5.1统计量抽样收敛定理">定理5.1：统计量抽样收敛定理</h5><p>设总体 <span class="math inline">\(X\)</span> 的均值是 <spanclass="math inline">\(\mu\)</span> ，方差为 <spanclass="math inline">\(\sigma^2\)</span> ，<spanclass="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的一个样本，则：</p><p>（1）<span class="math inline">\(E(\overline{X}) = \mu\)</span> （<span class="math inline">\(\overline X\)</span>是 <spanclass="math inline">\(\mu\)</span> 的无偏估计）</p><p>（2）<spanclass="math inline">\(Var(\overline{X})=\frac{\sigma^2}{n}\)</span></p><p>（3）<span class="math inline">\(E(S^2)=\sigma^2\)</span> （<spanclass="math inline">\(S^2\)</span> 是 <spanclass="math inline">\(\sigma^2\)</span> 的无偏估计）</p><p>其中，<span class="math inline">\(S^2\)</span> 要考虑偏差，有 <spanclass="math inline">\(S^2 = \frac{1}{n - 1}\displaystyle\sum_{i =1}^{n}(X_i - \overline{X})^2\)</span></p><h4 id="抽样分布">5.2.2 抽样分布</h4><h5 id="抽样分布的种类">1. 抽样分布的种类</h5><p>目前已知的抽样分布就多大几十种，但是常见的抽样分布只有四种：<spanclass="math inline">\(Gauss\)</span> 分布，<spanclass="math inline">\(t\)</span> 分布，<spanclass="math inline">\(F\)</span> 分布，<spanclass="math inline">\(\chi^2\)</span> 分布</p><h4 id="抽样分布示例">5.2.3 抽样分布示例</h4><h3 id="极限定理">5.3 极限定理</h3><h4 id="矩的不等式">5.3.1 矩的不等式</h4><h5 id="定理5.2marcov不等式">定理5.2：Marcov不等式</h5><p>设 <span class="math inline">\(X\)</span>是非负随机变量且具有数学期望 <span class="math inline">\(E(X)\)</span>，则 <span class="math inline">\(\forall{\varepsilon} &gt;0\)</span>，有： <span class="math display">\[P(X\geq\varepsilon)\leq\frac{E(X)}{\varepsilon}\]</span></p><h5 id="定理5.3chebyshev不等式">定理5.3：Chebyshev不等式</h5><p>设随机变量 <span class="math inline">\(X\)</span> 具有数学期望 <spanclass="math inline">\(E(X)=\mu\)</span> ，<spanclass="math inline">\(Var(X) = \sigma^2\)</span> ，则 <spanclass="math inline">\(\forall{\varepsilon} &gt; 0\)</span> ，有： <spanclass="math display">\[P(|x-\mu|\geq\varepsilon)\leq\frac{\sigma^2}{\varepsilon^2}\]</span></p><h4 id="大数定律">5.3.2 大数定律</h4><h5 id="定理5.4方差为0的充要条件">定理5.4：方差为0的充要条件</h5><p><span class="math inline">\(Var(X)=0\)</span> <spanclass="math inline">\(iff.\)</span> <spanclass="math inline">\(P(X=E(X)) = 1\)</span></p><h5 id="定理5.5bernoulli大数定律">定理5.5：Bernoulli大数定律</h5><p><span class="math inline">\(X_n\sim\mathbb{B}(n,\ p)\)</span>，<spanclass="math inline">\(\forall\varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{x_n}{n}-p|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.6chebyshev大数定律">定理5.6：Chebyshev大数定律</h5><p>设 <span class="math inline">\(X_i(i =1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <spanclass="math inline">\(E(X) = \mu\)</span> 和有限的方差 <spanclass="math inline">\(Var(X_i) = \sigma_i^2\)</span>，<spanclass="math inline">\(\forall\ \varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{1}{n}\sum_{i=1}^{n}X_i-\frac{1}{n}\sum_{i=1}^{n}EX_i|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.7khinchin大数定律">定理5.7：Khinchin大数定律</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(X\)</span> 的独立同分布随机变量，数学期望 <spanclass="math inline">\(E(X_i) = \mu\)</span> 存在，<spanclass="math inline">\(\forall\ \varepsilon&gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{1}{n}\sum_{i=1}^{n}X_i-\mu|&lt;\varepsilon)=1\]</span></p><h5 id="定理5.8弱大数定律">定理5.8：弱大数定律</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <span class="math inline">\(E(X)\)</span>存在，则 <span class="math inline">\(\overline{X}_n\)</span>依概率收敛于 <span class="math inline">\(EX\)</span> ，即 <spanclass="math inline">\(\forall\ \varepsilon &gt;0\)</span>，有： <spanclass="math display">\[\displaystyle{\lim_{n\rightarrow\infty}}P(|\frac{x_n}{n}-p|&lt;\varepsilon)=1\]</span></p><h4 id="中心极限定理">5.3.3 中心极限定理</h4><h5 id="定理5.9de-moivre-laplace中心极限定理">定理5.9：DeMoivre-Laplace中心极限定理</h5><p><span class="math inline">\(X_n\sim\mathbb{B}(n,\ p)\)</span> ，则：<span class="math display">\[\lim_{n\rightarrow\infty}P(\frac{X_n-np}{\sqrt{np(1-p)}}\leq{x})=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{\frac{-t^2}{2}}dt\]</span></p><h5id="定理5.10独立同分布中心极限定理">定理5.10：独立同分布中心极限定理</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span>为独立同分布随机变量，数学期望 <span class="math inline">\(E(X) =\mu\)</span> 和有限的方差 <span class="math inline">\(Var(X_i) =\sigma_i^2\)</span>，随机变量之和 <spanclass="math inline">\(\displaystyle\sum_{i = 1}^{n}X_i\)</span> ，设：<span class="math display">\[Y_n = \frac{\displaystyle\sum_{i = 1}^{n}X_i-E(\displaystyle\sum_{i =1}^{n}X_i)}{\sqrt{D(\displaystyle\sum_{i =1}^{n}X_i)}}=\frac{\displaystyle\sum_{i =1}^{n}X_i-n\mu}{\sqrt{n}\sigma}\]</span> 则： <span class="math display">\[\lim_{n\rightarrow\infty}P(Y_n\leq{x})=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}e^{\frac{-t^2}{2}}dt=\Phi(x)\]</span></p><h5 id="定理5.11独立同分布正态样本">定理5.11：独立同分布正态样本</h5><p><span class="math inline">\(X_i\)</span> <spanclass="math inline">\((i = 1，2，…，n)\)</span> 是总体 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span> 的样本，<spanclass="math inline">\(\overline{X}\)</span> 是样本均值，则： <spanclass="math display">\[\overline{X}\sim\mathbb{N}(\mu,\frac{\sigma^2}{n})\]</span></p><h3 id="常用抽样分布">5.4 常用抽样分布</h3><h4 id="gamma函数">5.4.1 <spanclass="math inline">\(\Gamma\)</span>函数</h4><h5 id="定义5.1gamma函数">定义5.1：<spanclass="math inline">\(\Gamma\)</span>函数</h5><p>实数域上 <span class="math inline">\(\Gamma\)</span> 函数定义为：<span class="math display">\[\Gamma(x)=\int_{0}^{+\infty}t^{x-1}e^{-t}dt\ (x&gt;0)\]</span> <span class="math inline">\(\Gamma\)</span> 函数的重要性质：<span class="math display">\[\begin{align}&amp;\Gamma(n) = (n-1)!\ \ \ n\in\mathbb{N}\\&amp;\Gamma(1-x)\Gamma(x) =\frac{\pi}{sin\pi{x}}\\&amp;\Gamma(\frac{1}{2}) =\sqrt{\pi}\\&amp;\Gamma(x)\rightarrow\sqrt{2\pi}e^{-x}x^{x-\frac{1}{2}}\ \ \x\rightarrow+\infty\end{align}\]</span></p><h4 id="chi2-分布-karl-pearson">5.4.2 <spanclass="math inline">\(\chi^{2}\)</span> 分布 (Karl Pearson)</h4><h5 id="定理5.2chi2分布">定理5.2：<spanclass="math inline">\(\chi^{2}\)</span>分布</h5><p>设 <span class="math inline">\(X_i(i = 1,2,…,n)\)</span> 为 <spanclass="math inline">\(\mathbb{N}(0,1)\)</span>的独立同分布随机变量，则称随机变量： <span class="math display">\[\chi^2 = \sum_{i=1}^{n}X_i^2\]</span> 为服从自由度为 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(\chi^2\)</span> 分布，记为 <spanclass="math inline">\(\chi^2(n)\)</span></p><h5 id="定理5.12chi2分布可加性">定理5.12：<spanclass="math inline">\(\chi^{2}\)</span>分布可加性</h5><p>设 <span class="math inline">\(X_1 \sim \chi^2(n_1)\)</span>，<spanclass="math inline">\(X_2 \sim\chi^2(n_2)\)</span>，且 <spanclass="math inline">\(X_1\)</span> 和 <spanclass="math inline">\(X_2\)</span> 相互独立，则： <spanclass="math display">\[X_1+X_2\sim\chi^2(n_1+n_2)\]</span></p><h5 id="定理5.13chi2分布的概率密度">定理5.13：<spanclass="math inline">\(\chi^{2}\)</span>分布的概率密度</h5><p><span class="math inline">\(\chi^2(n)\)</span> 分布的概率密度函数为：<span class="math display">\[f(x)=\frac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\frac{n}{2}-1}e^{-\frac{x}{2}}\]</span></p><h5 id="定理5.14chi2分布的是数字特征">定理5.14：<spanclass="math inline">\(\chi^{2}\)</span>分布的是数字特征</h5><p>若 <span class="math inline">\(X \sim \chi^2(n)\)</span>，则 <spanclass="math inline">\(E(X)=n\)</span>，<spanclass="math inline">\(Var(X)=2n\)</span></p><h5 id="定理5.15均值抽样分布定理">定理5.15：均值抽样分布定理</h5><p><span class="math inline">\(X_i\)</span> <spanclass="math inline">\((i = 1，2，…，n)\)</span> 是总体 <spanclass="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span> 的样本，<spanclass="math inline">\(\overline{X}\)</span> 是样本均值，则： <spanclass="math display">\[\overline{X}\sim\mathbb{N}(\mu,\frac{\sigma^2}{n})\]</span></p><h5 id="定理5.16方差抽样分布定理">定理5.16：方差抽样分布定理</h5><p><span class="math inline">\(X_i\)</span> (i = 1，2，…，n) 是总体<span class="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>的样本，<span class="math inline">\(S^2\)</span> 是样本方差，则有：<span class="math display">\[\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\]</span></p><h4 id="t-分布-gosset">5.4.3 <span class="math inline">\(t\)</span> 分布(Gosset)</h4><h5 id="定义5.3t-分布">定义5.3：<span class="math inline">\(t\)</span>分布</h5><p>设 <span class="math inline">\(X\sim\mathbb{N}(0,1)\)</span>，<spanclass="math inline">\(Y\sim\chi^2(n)\)</span>，且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则随机变量 <spanclass="math display">\[t=\frac{X}{\sqrt{\frac{Y}{n}}}\]</span> 称为服从自由度为 <span class="math inline">\(n\)</span> 的<span class="math inline">\(t\)</span> 分布，记为 <spanclass="math inline">\(t(n)\)</span></p><h5 id="定理5.17预备定理">定理5.17：预备定理</h5><p>设 <span class="math inline">\((X_1\)</span>，<spanclass="math inline">\(X_{2})\)</span> 是二维随机变量，其分布密度函数为<span class="math inline">\(f(x_1,\ x_2)\)</span>，且 <spanclass="math inline">\(X_1\)</span> 和 <spanclass="math inline">\(X_2\)</span> 相互独立，则 <spanclass="math inline">\(X\)</span> 的分布密度函数为： <spanclass="math display">\[f_X(x)=f_{x_1}(xx_2)f_{x_2}(x_2)|x_2|dx_2\]</span></p><h5 id="定理5.18t-分布密度函数">定理5.18：<spanclass="math inline">\(t\)</span> 分布密度函数</h5><p><span class="math inline">\(t(n)\)</span> 的密度函数为: <spanclass="math display">\[f(x)=\frac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\frac{x^2}{n})^{-\frac{n+1}{2}}\]</span></p><h5 id="定理5.19t-分布数字特征">定理5.19：<spanclass="math inline">\(t\)</span> 分布数字特征</h5><p><span class="math inline">\(X\sim t(n)\)</span> ，则：</p><p><span class="math display">\[\begin{align}E(X) &amp;= 0\\Var(X)&amp;=\frac{n}{n-2}\end{align}\]</span></p><h5 id="定理5.20t-分布对称性">定理5.20：<spanclass="math inline">\(t\)</span> 分布对称性</h5><p>对于给定的正数 <span class="math inline">\(\alpha\(0&lt;\alpha&lt;1)\)</span>，称满足条件 <spanclass="math inline">\(P(t&gt;t_{\alpha}(n))=\int_{t_{\alpha}(n)}^{+\infty}f(x)dx=\alpha\)</span>的点 <span class="math inline">\(t_{\alpha}(n)\)</span> 称为 <spanclass="math inline">\(t(n)\)</span> 上的 <spanclass="math inline">\(\alpha\)</span> 分位点。则： <spanclass="math display">\[t_{1-\alpha}(n)=-t_{\alpha}{(n)}\]</span></p><h5 id="定理5.21t-分布的正态收敛性">定理5.21：<spanclass="math inline">\(t\)</span> 分布的正态收敛性</h5><p><span class="math inline">\(t_(n)\)</span> 分布的概率密度 <spanclass="math inline">\(f(x)\)</span> 趋向于标准正态分布的概率密度，即：<span class="math display">\[\lim_{n\rightarrow\infty}f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}，(-\infty&lt;x&lt;+\infty)\]</span></p><h5 id="定理5.22均值抽样分布定理">定理5.22：均值抽样分布定理</h5><p><span class="math display">\[X_i\ (i = 1，2，…，n)\]</span> 是总体<span class="math inline">\(\mathbb{N}(\mu,\sigma^2)\)</span>的样本，总体方差未知，样本均值和样本方差分别为 <spanclass="math inline">\(\overline{X}\)</span> 和 <spanclass="math inline">\(S^2\)</span> ，则： <span class="math display">\[\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\sim t(n-1)\]</span></p><h4 id="f-分布-fisher">5.4.4 <span class="math inline">\(F\)</span> 分布(Fisher)</h4><h5 id="定义5.4f-分布">定义5.4：<span class="math inline">\(F\)</span>分布</h5><p>设 <span class="math inline">\(X\sim\chi^2(n_1)\)</span>，<spanclass="math inline">\(Y\sim\chi^2(n_2)\)</span>，且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 相互独立，则随机变量 <spanclass="math display">\[F=\frac{\frac{X}{n_1}}{\frac{Y}{n_2}}=\frac{n_2}{n_1}\frac{X}{Y}\]</span> 称为服从自由度为 <span class="math inline">\(n_1，n_2\)</span>的 <span class="math inline">\(F\)</span> 分布，记为 <spanclass="math inline">\(F(n_1，n_2)\)</span>，其中 <spanclass="math inline">\(n_1\)</span> 称为第一自由度，<spanclass="math inline">\(n_2\)</span> 称为第二自由度。</p><h5 id="定理5.23f-分布的倒数对称性">定理5.23：<spanclass="math inline">\(F\)</span> 分布的倒数对称性</h5><p><span class="math display">\[F_{1-\alpha}(n_1,\ n_2)=\frac{1}{F_{\alpha}(n_1, \ n_2)}\]</span></p><h5 id="定理5.24f-分布密度函数">定理5.24：<spanclass="math inline">\(F\)</span> 分布密度函数</h5><p><span class="math inline">\(F(n_1, \ n_2)\)</span>分布的概率密度函数为： <span class="math display">\[f(x;\ n_1,\ n_2) =\frac{\Gamma(\frac{n_1+n_2}{2})}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})}(\frac{n_1}{n_2})^{\frac{n_1}{2}}\frac{x^{\frac{n_1-2}{2}}}{(1+\frac{n_1}{n_2}x)^{\frac{n_1+n_2}{2}}}，\x&gt;0\]</span></p><h5 id="定理5.25f-分布数学期望">定理5.25：<spanclass="math inline">\(F\)</span> 分布数学期望</h5><p>若 <span class="math inline">\(X\sim F(n_1，n_2)\)</span>，则： <spanclass="math display">\[E(X)=\frac{n_2}{n_2-2}，\ n_2&gt;2\\Var(X)=\frac{n_2^2(2n_1+2n_2-4)}{n_1(n_2-2)^2(n_2-4)}，\ n_2&gt;4\]</span></p><h5 id="定理5.26正态分布逼近定理">定理5.26：正态分布逼近定理</h5><p>设 <span class="math inline">\(X_{i}\ (i=1，2，…，n_1)\)</span> ，<span class="math inline">\(Y_{i}\ (i=1，2，…，n_2)\)</span>，是分别来自两正态总体 <spanclass="math inline">\(\mathbb{N}(\mu_1,\sigma_1^2)\)</span>， <spanclass="math inline">\(\mathbb{N}(\mu_2,\sigma_2^2)\)</span>，则： <spanclass="math display">\[\frac{(\overline X-\overlineY)-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\sim\mathbb{N}(0,\ 1)\]</span></p><h5 id="定理5.27方差抽样分布定理">定理5.27：方差抽样分布定理</h5><p>设 <span class="math inline">\(X_{i}\ (i=1，2，…，n_1)\)</span> ，<span class="math inline">\(Y_{i}\ (i=1，2，…，n_2)\)</span>，是分别来自两正态总体 <spanclass="math inline">\(\mathbb{N}(\mu_1,\sigma_1^2)\)</span>， <spanclass="math inline">\(\mathbb{N}(\mu_2,\sigma_2^2)\)</span>，$S_1<sup>2, S_2</sup>2$ 分别为两样本方差，则： <span class="math display">\[\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\sim F(n_1-1,\ n_2-1)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽样分布</tag>
      
      <tag>极限定理</tag>
      
      <tag>大数定律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 常用概率分布</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h2 id="第四章-常用概率分布">第四章 常用概率分布</h2><h3 id="离散概率分布">4.1 离散概率分布</h3><h4 id="bernoulli-分布">4.1.1 Bernoulli 分布</h4><h5 id="定义4.1-bernoulli-分布">定义4.1 Bernoulli 分布</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数 <spanclass="math inline">\(p\)</span> 的伯努利分布，若： <spanclass="math display">\[P\{X = k\} = p^k(1-p)^{1-k}\\k \in \{0,\ 1\}\]</span> 记作 <span class="math display">\[X\sim Bern(p)\]</span></p><h5 id="定理4.1-bernoulli-分布矩生成函数">定理4.1 Bernoulli分布矩生成函数</h5><p><span class="math inline">\(X\)</span> 为伯努利分布随机变量，则 <spanclass="math display">\[M_X(s) = (1-p)+pe^s\]</span></p><h4 id="binomial-分布">4.1.2 Binomial 分布</h4><h5 id="定义4.2-binomial-分布">定义4.2 Binomial 分布</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数 <spanclass="math inline">\(n,\ p\)</span> 的二项分布，若 <spanclass="math display">\[P\{X = k\} = \binom{n}{k}p^k(1-p)^{n-k}\\k = 1,\ 2,…,n\]</span> 其中 <span class="math inline">\(n,\ p\)</span> 为参数，记为<span class="math inline">\(X\sim \mathbb{B}(n,\ p)\)</span>.特别地，利用微分恒等式可以得到二项分布的数字特征 <spanclass="math display">\[E(X) = np\\V(X) = np(1-p)\]</span></p><h5 id="定理4.2-binomial-分布矩生成函数">定理4.2 Binomial分布矩生成函数</h5><p><span class="math inline">\(X\sim \mathbb{B}(n,\ p)\)</span>，则<span class="math display">\[M_X(s) = (pe^s+1-p)^n\]</span></p><h5 id="定理4.3-binomial-分布可加性">定理4.3 Binomial 分布可加性</h5><p>两二项分布随机变量 <span class="math inline">\(X\sim \mathbb{B}(m,\p), Y\sim\mathbb{B}(n,\ p)\)</span> 相互独立，则有 <spanclass="math display">\[X+Y\sim\mathbb{B}(m+n,\ p)\]</span></p><h4 id="poisson-分布">4.1.3 Poisson 分布</h4><h5 id="定义4.3-poisson-分布">定义4.3 Poisson 分布</h5><p>泊松分布的概率分布律为 <span class="math display">\[P\{X = k\} = \frac{\lambda^k}{k!}e^{-\lambda}\\k= 0,\ 1,\ 2,\ …\]</span> 其中 <span class="math inline">\(\lambda\)</span> 为参数，记作<span class="math inline">\(X\sim \pi(\lambda)\)</span>.利用简单的变形可得泊松分布的数字特征 <span class="math display">\[E(X) = \lambda\\V(X) = \lambda\]</span></p><h5 id="定理4.4-poisson-分布矩生成函数">定理4.4 Poisson分布矩生成函数</h5><p><span class="math inline">\(X\sim\pi(\lambda)\)</span>，则 <spanclass="math display">\[M_X(s) = e^{\lambda(e^s - 1)}\]</span></p><h5 id="定理4.5-binomial-分布-poisson-逼近定理">定理4.5 Binomial 分布Poisson 逼近定理</h5><p>设 <span class="math inline">\(\lambda&gt;0\)</span>是一个常数，<span class="math inline">\(n\)</span> 为正整数，若 <spanclass="math inline">\(np_n\)</span> 近似为 <spanclass="math inline">\(\lambda\)</span> ，则对于任意固定的非负整数 <spanclass="math inline">\(k\)</span>，有 <span class="math display">\[\lim_{n\rightarrow\infty}\binom{n}{k}p_n^k(1-p_n)^{n-k}=\frac{\lambda^k}{k!}e^{-\lambda}\]</span></p><h4 id="geometric-分布">4.1.4 Geometric 分布</h4><h5 id="定义4.4-geometric-分布">定义4.4 Geometric 分布</h5><p>几何分布的概率分布律为 <span class="math display">\[P\{X=k\}=(1-p)^{k-1}p\\k = 1,\ 2,\ …,\ n\]</span> 其中 <span class="math inline">\(p\)</span> 为参数，记作 <spanclass="math inline">\(X\sim\mathbb{G}(p)\)</span>.利用等比数列求和错位相减得到几何分布的数字特征 <spanclass="math display">\[E(X) = \frac{1}{p}\\V(x) = \frac{1-p}{p^2}\]</span></p><h5 id="定理4.6-geometric-分布无记忆性">定理4.6 Geometric分布无记忆性</h5><p>取值为正整数的随机变量 <span class="math inline">\(X\)</span>服从几何分布，当且仅当 <span class="math inline">\(X\)</span> 有无记忆性<span class="math display">\[P\{X&gt;m+n\ |\ X&gt;m\} = P\{X&gt;n\}\\ \forall m,\ n\geq0\]</span></p><h5 id="定理4.7-geometric-分布矩生成函数">定理4.7 Geometric分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{G}(p)\)</span> ，则 <spanclass="math display">\[M_X(s) = \frac{pe^s}{1-(1-p)e^s}\]</span></p><h4 id="negative-binomial-pascal-分布">4.1.5 Negative-Binomial (Pascal)分布</h4><h5 id="定义4.5-negative-binomial-分布一般化的几何分布">定义4.5Negative-Binomial 分布(一般化的几何分布)</h5><p>随机变量 <span class="math inline">\(X\)</span> 服从参数为 <spanclass="math inline">\(r\)</span> 和 <spanclass="math inline">\(p\)</span> 的负二项分布，其概率分布律为 <spanclass="math display">\[\mathbb{NB}(k;r,p) = \binom{k-1}{n-r}(1-p)^{k-r}p^r\\k = r,\ r+1,\ ……\]</span> 记作 <span class="math inline">\(X\sim\mathbb{NB}(r,\p)\)</span>. 特别地，利用组合恒等式不难求出负二项分布的数字特征 <spanclass="math display">\[E(X) = \frac{r}{p}\\V(X) = \frac{r(1-p)}{p^2}\]</span></p><h5 id="定理4.8-negative-binomial-分布-poisson-逼近定理">定理4.8Negative-Binomial 分布 Poisson 逼近定理</h5><p>令 <span class="math inline">\(p = \frac{r}{\lambda+r}\)</span>，则<span class="math display">\[\lim_{r\rightarrow\infty}\mathbb{NB}(k&#39;;r,p) =\lim_{r\rightarrow\infty}\binom{k&#39;+r-1}{k&#39;}(1-p)^{k&#39;}p^r =\pi(k&#39;;\lambda)\]</span></p><h4 id="hyper-geometric-分布">4.1.6 Hyper-Geometric 分布</h4><h5 id="定义4.6-hyper-geometric分布">定义4.6 Hyper-Geometric分布</h5><p>超几何分布的概率分布律为 <span class="math display">\[P(X=i) = \frac{\binom{m}{i}\binom{N-m}{n-i}}{\binom{N}{n}}\\i = 1,\ 2,\ …,\ n\]</span> 其中参数 <span class="math inline">\(n,\ N,\ m\)</span>均为正整数且 <span class="math inline">\(m\le N,\ n\le N\)</span>，记作<span class="math inline">\(X\sim\mathbb{H}(N,n,m)\)</span>.特别地，利用极大似然估计不难得到超几何分布的数字特征 <spanclass="math display">\[E(X) = \frac{nm}{N}\\V(X) =\frac{nm}{N}\bigg(\frac{(n-1)(m-1)}{N-1}+1-\frac{nm}{N}\bigg)\]</span></p><h5 id="定理4.9-hyper-geometric-分布-binomial-逼近定理">定理4.9Hyper-Geometric 分布 Binomial 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\mathbb{H}(N,M,n)=\mathbb{B}(n,p)\]</span></p><p>其中 <span class="math inline">\(\frac{M}{N}=p\)</span></p><h3 id="连续概率分布">4.2 连续概率分布</h3><h4 id="uniform-分布">4.2.1 Uniform 分布</h4><h5 id="定义4.7-uniform-分布">定义4.7 Uniform 分布</h5><p>均匀分布的概率密度函数为 <span class="math display">\[f(x)= \frac{1}{b-a}\\a&lt;x&lt;b\]</span> 其中 <span class="math inline">\(a,\ b\)</span> 为参数，记作<spanclass="math inline">\(X\sim\mathbb{U}(a,b)\)</span>，利用定义不难求出均匀分布的数字特征<span class="math display">\[E(X) = \frac{a+b}{2}\\V(X) = \frac{(b-a)^2}{12}\]</span></p><h5 id="定理4.10-uniform-分布矩生成函数">定理4.10 Uniform分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{U}(a,b)\)</span>，则 <spanclass="math display">\[M_X(s) = \frac{e^{sb}-e^{sa}}{s(b-a)}\]</span></p><h4 id="exponential-分布">4.2.2 Exponential 分布</h4><h5 id="定义4.8-exponential-分布">定义4.8 Exponential 分布</h5><p>指数分布的概率密度为 <span class="math display">\[f(x) = \lambda e^{-\lambda x}\\x&gt;0\]</span> 其中 <span class="math inline">\(\lambda &gt; 0\)</span>为参数，称 <span class="math inline">\(X\)</span> 服从参数为 <spanclass="math inline">\(\lambda\)</span> 的指数分布，记作 <spanclass="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>.利用矩生成函数不难算出指数分布的数字特征 <span class="math display">\[E(X) = \frac{1}{\lambda}\\V(X) = \frac{1}{\lambda^2}\]</span></p><h5 id="定理4.11-exponential-分布的无记忆性">定理4.11 Exponential分布的无记忆性</h5><p><span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>，则<span class="math display">\[\forall s.\ t&gt;0:P\{X&gt;s+t\ |\ X&gt;s\}=P\{X&gt;t\}\]</span></p><h5 id="定理4.12-exponential-分布矩生成函数">定理4.12 Exponential分布矩生成函数</h5><p><span class="math inline">\(X\sim\mathbb{E}(\lambda)\)</span>，则<span class="math display">\[M_X(s) = \frac{\lambda}{\lambda-s}\\s&lt;\lambda\]</span></p><h5 id="定理4.13-geometric-分布连续化定理">定理4.13 Geometric分布连续化定理</h5><p><span class="math inline">\(X_n\sim\mathbb{G}(x_n;p)\)</span>，令<span class="math inline">\(p = \frac{\lambda}{n}\)</span>，则对于 <spanclass="math inline">\(t&gt;0,\ n\geq1\)</span>，有 <spanclass="math display">\[\lim_{n\rightarrow\infty}P\{X_n&lt;nt\} = 1-e^{-\lambda t}\]</span></p><h4 id="normal-分布">4.2.3 Normal 分布</h4><h5 id="定义4.9-normal-分布">定义4.9 Normal 分布</h5><p>正态分布的概率密度为 <span class="math display">\[f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\\-\infty&lt;x&lt;+\infty\]</span></p><p>其中，<span class="math inline">\(\mu,\sigma\)</span> 为参数，记作<span class="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>.利用二重积分不难得到正态分布的数字特征 <span class="math display">\[E(X) = \mu\\V(X) = \sigma^2\]</span></p><h5 id="定理4.14-standard-normal-分布的对称性">定理4.14 Standard Normal分布的对称性</h5><p>为了方便，记标准正态分布的概率密度函数和分布函数分别为 <spanclass="math inline">\(\phi(x)\)</span> 和 <spanclass="math inline">\(\Phi(x)\)</span> <span class="math display">\[\phi(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\\\Phi(x) = \int_{-\infty}^{x}\phi(x)dx\]</span> 则有 <span class="math display">\[\Phi(x) + \Phi(-x) = 1\]</span></p><h5 id="定理4.15-normal-分布标准化">定理4.15 Normal 分布标准化</h5><p>若 <spanclass="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>，则 <spanclass="math display">\[Z = \frac{X-\mu}{\sigma}\sim\mathbb{N}(0,1)\]</span></p><h5 id="定理4.16-normal-分布矩生成函数">定理4.16 Normal分布矩生成函数</h5><p>若 <spanclass="math inline">\(X\sim\mathbb{N}(\mu,\sigma^2)\)</span>，则 <spanclass="math display">\[M_X(s) = exp\{\mu t + \frac{\sigma^2t^2}{2}\}\]</span></p><h5 id="定理4.17-binomial-分布-normal-逼近定理">定理4.17 Binomial 分布Normal 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\mathbb{B}(n,p) = \mathbb{N}(\mu,\sigma^2)\]</span></p><p>其中，<span class="math inline">\(\mu = np,\ \sigma^2 =np(1-p)\)</span></p><h5 id="定理4.18-poisson-分布-normal-逼近定理">定理4.18 Poisson 分布Normal 逼近定理</h5><p><span class="math display">\[\lim_{n\rightarrow\infty}\pi(\lambda) = \mathbb{N}(\mu,\sigma^2)\]</span></p><p>其中 <span class="math inline">\(\sigma^2 = \lambda\)</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率分布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 随机变量</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-随机变量">第三章 随机变量</h2><h3 id="数据分布与概率分布">3.1 数据分布与概率分布</h3><h4 id="数据分布">3.1.1 数据分布</h4><h5 id="一般性定义">1. 一般性定义</h5><p>数据分布的一般性定义：从特定数据到一般规律的抽象。</p><h4 id="随机变量">3.1.2 随机变量</h4><h5 id="定义-3.1随机变量">定义 3.1：随机变量</h5><p>给定的样本空间为 <span class="math inline">\(\Omega =\{\omega\}\)</span>，若对于每一个样本点 <spanclass="math inline">\(\omega \in\Omega\)</span>，都有唯一确定的 <spanclass="math inline">\(X(\omega)\)</span> 与之对应，则称 <spanclass="math inline">\(X(\omega)\)</span> 是一个随机变量，简记为 <spanclass="math inline">\(X\)</span>, 即： <span class="math display">\[X: \Omega\rightarrow X(\Omega)\]</span></p><h5 id="定义-3.2分布函数">定义 3.2：分布函数</h5><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数定义为<span class="math display">\[F(x) = P(X\leq x) \  \ \ (x\in\mathbb{R})\]</span></p><h5 id="引理-3.1分布函数基本性质">引理 3.1：分布函数基本性质</h5><p>对于任意随机变量 <span class="math inline">\(X\)</span>，其分布函数<span class="math inline">\(F(x)\)</span> 具有以下的性质： <spanclass="math display">\[\begin{align*}&amp;1.\ \forall x\in \mathbb{R},0\le F(x)\le 1 \\ &amp;2.\ \forallx_1\leq x_2,F(x_1)\leq F(x_2)\\ &amp;3.\ \forall x_0\in\mathbb{R},F(x_0)= \lim_{x\rightarrow x_0^{+}} F(x)\\ &amp;4.\ F(-\infty) =\lim_{x\rightarrow - \infty}F(x) = 0,\ F(+\infty) = \lim_{x\rightarrow +\infty}F(x) = 1\end{align*}\]</span></p><h4 id="离散随机变量">3.1.3 离散随机变量</h4><h5 id="定义3.3离散型随机变量">定义3.3：离散型随机变量</h5><p>一个随机变量的可能（概率非零）取值至多可列个，则称它为离散型随机变量。<spanclass="math inline">\(X=x_i\)</span> 的概率标记为 <spanclass="math display">\[P(X = x_i) = p_i\\(i = 1,2,3,…)\]</span></p><h4 id="连续随机变量">3.1.4 连续随机变量</h4><h5 id="定义-3.4连续随机变量">定义 3.4：连续随机变量</h5><p>对于随机变量 <span class="math inline">\(X\)</span> 及其分布函数<span class="math inline">\(F(x)\)</span>，如存在非负可积函数 <spanclass="math inline">\(f(x)\)</span>，满足 <spanclass="math inline">\(\forall x:F(x) =\int_{-\infty}^{+\infty}f(t)dt\)</span> ，则称 <spanclass="math inline">\(X\)</span> 为连续随机变量，<spanclass="math inline">\(f(x)\)</span> 称为 <spanclass="math inline">\(X\)</span> 的概率密度函数</p><h5 id="定理-3.1连续随机变量性质">定理 3.1：连续随机变量性质</h5><ol type="1"><li><p>若 <span class="math inline">\(F\)</span> 在点 <spanclass="math inline">\(x\)</span> 处连续，则 <spanclass="math inline">\(F&#39;(x) = f(x)\)</span></p></li><li><p>连续随机变量 <span class="math inline">\(X\)</span>的任意一点概率为 <span class="math inline">\(0\)</span> , 即有 <spanclass="math display">\[\forall x:P(X=x)=0\]</span></p></li></ol><h4 id="随机变量的函数的分布">3.1.5 随机变量的函数的分布</h4><h5 id="定理-3.2函数的分布定理">定理 3.2：函数的分布定理</h5><p><span class="math inline">\(X\)</span> 的密度函数为 <spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infty&lt;x&lt;+\infty\)</span>，<spanclass="math inline">\(Y = g(X)\)</span> 严格单调，即 <spanclass="math inline">\(g&#39;(x)&gt;0\)</span> 或 <spanclass="math inline">\(g&#39;(x)&lt;0\)</span>，则 <spanclass="math inline">\(Y\)</span> 的密度函数为： <spanclass="math display">\[f_Y(x) = f_X(h(y))|h&#39;(y)|\ \ \ (a&lt;y&lt;b)\]</span> 其中 <span class="math display">\[\begin{align}&amp;a = min(g(-\infty),g(+\infty))\\&amp;b = max(g(-\infty),\ g(+\infty))\\&amp;h(y) = g^{-1}(x)\end{align}\]</span></p><h3 id="期望与矩">3.2 期望与矩</h3><h4 id="原点矩">3.2.1 原点矩</h4><h5 id="原点矩-1">1. 原点矩</h5><p>给定一批数据 <spanclass="math inline">\(x_1,x_2,x_3,…,x_n\)</span>，其 <spanclass="math inline">\(k\)</span> 阶原点矩 <spanclass="math inline">\(A_k \triangleq \frac{1}{n}\displaystyle{\sum_{i =1}^{n}x_i^k}\)</span></p><h5 id="定义-3.5">定义 3.5：</h5><p>离散随机变量 <span class="math inline">\(X\)</span> 的数学期望定义为<span class="math display">\[E(X)= \displaystyle{\sum_{i = 1}^\infty}x_ip_i\]</span> 连续随机变量 <span class="math inline">\(X\)</span>的数学期望定义为 <span class="math display">\[E(X) = \int_{-\infty}^{+\infty}xf(x)dx\]</span> 这里要求 <span class="math inline">\(\displaystyle{\sum_{i =1}^\infty}x_ip_i\)</span> 和 <spanclass="math inline">\(\int_{-\infty}^{+\infty}xf(x)dx\)</span>绝对收敛</p><h5 id="定理-3.3数学期望性质">定理 3.3：数学期望性质</h5><p>随机变量的数学期望有如下性质</p><ol type="1"><li><span class="math inline">\(E(C) = C \ (C\in\mathbb{R})\)</span></li><li><span class="math inline">\(E(CX) = CE(X)\ (C\in\mathbb{R})\)</span></li><li><span class="math inline">\(E(X\pm Y) = E(X)\pm E(Y)\)</span></li><li><span class="math inline">\(E(XY) = E(X)E(Y) \ iff.X,Y\ are\independent\)</span></li></ol><h4 id="中心矩">3.2.2 中心矩</h4><h5 id="定义-3.6中心矩">定义 3.6：中心矩</h5><p>给定随机变量 <span class="math inline">\(X\)</span>，若 <spanclass="math inline">\(E((X-E(X))^k)\)</span> 存在，则其 <spanclass="math inline">\(k\)</span> 阶中心矩定义为 <spanclass="math inline">\(E((X-E(X))^k)\)</span></p><h5 id="定义-3.7方差与标准差">定义 3.7：方差与标准差</h5><p><span class="math inline">\(X\)</span>随机变量的二姐中心矩为方差，记作 <spanclass="math inline">\(\sigma^2(X)\)</span> 或 <spanclass="math inline">\(Var(X)\)</span> 或 <spanclass="math inline">\(D(X)\)</span> ，而 <spanclass="math inline">\(\sqrt{Var(X)}\)</span> 称为 <spanclass="math inline">\(X\)</span> 的标准差，记为 <spanclass="math inline">\(\sigma(X)\)</span></p><h5 id="定理-3.4方差计算定理">定理 3.4：方差计算定理</h5><p><span class="math display">\[D(X) = E(X^2) - E^2(X)\]</span></p><h5 id="定理-3.5方差的性质">定理 3.5：方差的性质</h5><ol type="1"><li><p>设 <span class="math inline">\(C\)</span> 为常数，则 <spanclass="math inline">\(D(C) = 0\)</span></p></li><li><p>设 <span class="math inline">\(X\)</span> 是随机变量，<spanclass="math inline">\(C\)</span> 是常数，则 <spanclass="math display">\[D(X+C)=D(X)\\D(CX) = C^2D(X)\]</span></p></li><li><p>设随机变量 <span class="math inline">\(X\)</span> 与 <spanclass="math inline">\(Y\)</span> 相互独立，则： <spanclass="math display">\[D(X\pm Y) = D(X) + D(Y)\]</span></p></li></ol><h3 id="矩的数学工具">3.3 矩的数学工具</h3><h4 id="微分恒等式">3.3.1 微分恒等式</h4><h5 id="定义-3.8微分恒等式法">定义 3.8：微分恒等式法</h5><p><span class="math inline">\(\alpha,\beta,\omega\)</span>是一些参数，<span class="math inline">\(\existsc\in\mathbb{N},s.t.n_{min},n_{max}\leq c\)</span>，设 <spanclass="math display">\[\displaystyle{\sum_{n = n_{min}}^{n_{max}}}f(n;\alpha,\beta,…,\omega)=g(\alpha,\beta,…,\omega)\]</span> 其中 <span class="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 是关于 <spanclass="math inline">\(\alpha\)</span> 的可微函数. 如果 <spanclass="math inline">\(f\)</span>退化到足以保证求和和求微分的次序可以交换，则 <spanclass="math display">\[\displaystyle{\sum_{n = n_{min}}^{n_{max}}}\frac{\partialf(n;\alpha,\beta,…,\omega)}{\partial\alpha}= \frac{\partialg(\alpha,\beta,…,\omega)}{\partial\alpha}\]</span></p><h4 id="矩生成函数的定义">3.3.1 矩生成函数的定义</h4><h5 id="定义-3.9矩生成函数">定义 3.9：矩生成函数</h5><p>随机变量 <span class="math inline">\(X\)</span> 的矩生成函数 <spanclass="math display">\[M_X(s) \triangleq E(e^{sX})\]</span> 其中，如果 <spanclass="math inline">\(\exists\delta\in\mathbb{R},s.t. \forall s\in[-\delta,\delta],M_X(s) \ is\ finite\)</span>，则称 <spanclass="math inline">\(M_X(s)\)</span> 存在</p><h4 id="矩生成函数的计算">3.3.3 矩生成函数的计算</h4><h5 id="定理-3.6矩生成定理">定理 3.6：矩生成定理</h5><p>假设随机变量 <span class="math inline">\(X\)</span> 的矩生成函数<span class="math inline">\(M_X(s)\)</span> 存在，则： <spanclass="math display">\[A_k = E(X^k) = {\frac{d^k}{dx^k}M_X(s)}\bigg{|}_{s=0}\]</span></p><h4 id="矩生成函数的性质">3.3.4 矩生成函数的性质</h4><h5 id="定理-3.7矩生成函数唯一性定理">定理3.7：矩生成函数唯一性定理</h5><p>对于两随机变量 <span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> ，假设存在常数 <spanclass="math inline">\(\delta\)</span> ，使得 <spanclass="math inline">\(M_X(s)\)</span> 和 <spanclass="math inline">\(M_Y(s)\)</span> 对于任意 <spanclass="math inline">\(s\in[-\delta,\ \delta]\)</span> 存在且相等，则<span class="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 的分布函数相等，即 <spanclass="math display">\[\forall t\in \mathbb{R} :F_X(t) = F_Y(t)\]</span></p><h5 id="定理-3.8矩生成函数可加性定理">定理3.8：矩生成函数可加性定理</h5><p><span class="math inline">\(X_i(i = 1,\ 2,\ …,\ n)\)</span>为独立随机变量，则 <span class="math display">\[M_{ {\sum_{i =1}^{n} }X_i(s)} = \displaystyle{\prod_{i= 1}^{n}}M_{X_i}(s)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩</tag>
      
      <tag>随机变量</tag>
      
      <tag>数学期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 概率论基础</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-概率论基础">第二章 概率论基础</h2><h3 id="概率定义">2.1 概率定义</h3><h4 id="集合表示">2.1.1 集合表示</h4><h5 id="定义-2.1随机事件">定义 2.1：随机事件</h5><p>样本空间 <span class="math inline">\(\Omega\)</span> 的任意一个子集<span class="math inline">\(\Omega&#39;\)</span>称为随机事件，简称事件。记某次实验结果 <spanclass="math inline">\(\omega\)</span> ，当 <spanclass="math inline">\(\omega\in\Omega&#39;\)</span> 时，我们称这一事件<span class="math inline">\(\Omega&#39;\)</span> 发生</p><h4 id="古典概率">2.1.2 古典概率</h4><h5 id="定义-2.2古典概率">定义 2.2：古典概率</h5><p><span class="math inline">\(\Omega = \{\omega_1,\ \omega_2,\ …,\\omega_n\}\)</span> 有穷且每个样本点等可能，即 <spanclass="math inline">\(P(\{\omega_i\}) =\frac{1}{n}\)</span>，则称这样的概率类型为古典概率</p><h4 id="几何概率">2.1.3 几何概率</h4><p>试验可能结果是欧几里得空间中的点，所有样本点的集合 <spanclass="math inline">\(\Omega\)</span> 是此空间中的一个几何图形，满足条件<span class="math inline">\(0&lt;m(\Omega)&lt;+\infty\)</span> ，这里<span class="math inline">\(m(\Omega)\)</span>表示该集合的勒贝格测度（如长度，面积，体积等）。对 <spanclass="math inline">\(\Omega\)</span> 的任何可测子集 <spanclass="math inline">\(A\)</span> 的几何概率定义为 <spanclass="math display">\[P(A) = \frac{m(A)}{m(\Omega)}\]</span></p><h4 id="概率公理化">2.1.4 概率公理化</h4><h5 id="定义2.4概率公理化定义">定义2.4：概率公理化定义</h5><p>随机试验样本空间为 <span class="math inline">\(\Omega\)</span>，任意事件 <span class="math inline">\(A\)</span> 赋予一实数 <spanclass="math inline">\(P(A)\)</span>，满足下列三个条件</p><ol type="1"><li><p>非负性：<span class="math inline">\(P(A)\geq0\)</span></p></li><li><p>规范性：<span class="math inline">\(P(\Omega) =1\)</span></p></li><li><p>可列可加性：若事件 <span class="math inline">\(A_k(k = 1,\ 2,\…,\infty)\)</span> 两两不相容，则 <span class="math display">\[P(\bigcup_{i = 1}^{\infty}A_i) = \displaystyle\sum_{i = 1}^{n}P(A_i)\]</span></p></li></ol><p>称 <spanclass="math inline">\(P:\mathscr{F}\rightarrow\mathbb{R}\)</span>为概率函数，简称概率</p><h5 id="引理-2.1空集为零">引理 2.1：空集为零</h5><p><span class="math display">\[P(\varnothing) = 0\]</span></p><h5 id="引理-2.2互补性">引理 2.2：互补性</h5><p><span class="math display">\[P(\overline{A}) = 1-P(A)\]</span></p><h5 id="引理-2.3单调性">引理 2.3：单调性</h5><p>设 <span class="math inline">\(A, B\)</span> 是两个事件，则 <spanclass="math display">\[A\subseteq B \implies P(A)\leq P(B)\]</span></p><h5 id="引理-2.4可拆性">引理 2.4：可拆性</h5><p>对于任意两个随机事件 <span class="math inline">\(E_1,\ E_2\)</span><span class="math display">\[P(E_1\cup E_2) = P(E_1)+P(E_2)- P(E_1\cap E_2)\]</span></p><h5 id="引理-2.5事件概率的估计">引理 2.5：事件概率的估计</h5><p>对任意有限或可列无穷的事件序列 <span class="math inline">\(E_1,E_2,…,E_n\)</span>，总有 <span class="math display">\[P\bigg(\bigcup_{i&gt;1}E_i\bigg)\leq\sum_{i\geq1}P(E_i)\]</span></p><h3 id="概率计算">2.2 概率计算</h3><h4 id="条件概率">2.2.1 条件概率</h4><h5 id="定义2.5条件概率">定义2.5：条件概率</h5><p>对于事件 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> , 若 <span class="math inline">\(P(B)\not= 0\)</span>，称 <span class="math display">\[P(A|B) = \frac{P(AB)}{P(B)}\]</span></p><h4 id="乘法公式">2.2.2 乘法公式</h4><h5 id="定理-2.1乘法公式">定理 2.1：乘法公式</h5><p>若 <span class="math inline">\(P(A_1)&gt;0\)</span>，则 <spanclass="math inline">\(P(A_1A_2)= P(A_1)P(A_2|A_1)\)</span>，一般地，我们有 <span class="math display">\[P(\prod_{i = 1}^{n}A_i) =P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2A_3…A_{n-1})\]</span></p><h4 id="全概率公式">2.2.3 全概率公式</h4><p>设 <span class="math inline">\(B_k(k = 1,\ 2,\ …,\ n)\)</span>是样本空间 <span class="math inline">\(\Omega\)</span>的一个完备事件组，且 <span class="math inline">\(P(B_k)&gt;0\ (k = 1,\2,\ …,\ n)\)</span>，则对于任意随机事件 <spanclass="math inline">\(A\)</span> ，有 <span class="math display">\[P(A) = \sum_{i =1}^nP(B_i)P(A|B_i)\]</span></p><h4 id="bayes公式">2.2.4 Bayes公式</h4><p>设 <span class="math inline">\(B_k(k = 1,\ 2,\ …,\ n)\)</span>是样本空间 <span class="math inline">\(\Omega\)</span>的一个完备事件组，且 <span class="math inline">\(P(B_k)&gt;0\ (k = 1,\2,\ …,\ n)\)</span>，则对于任意随机事件 <span class="math inline">\(A,\P(A)&gt;0\)</span> ，有 <span class="math display">\[P(B_i|A) = \frac{P(A|B_i)P(B_i)}{P(A)}\]</span></p><h4 id="独立性">2.2.5 独立性</h4><h5 id="定义2.6独立性">定义2.6：独立性</h5><p>一般地，若事件 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> , 满足 <span class="math display">\[P(AB)=P(A)P(B)\]</span> 则称事件 <span class="math inline">\(A,B\)</span> 相互独立</p><p>一般地，若事件 <span class="math inline">\(A_k(k = 1,\ 2,\ …,\n)\)</span> 对于任意 <span class="math inline">\(I\subset \{1,\ 2,\ …,\n\}\)</span>，有 <span class="math display">\[P(\bigcap_{i\in I}A_i) = \prod_{i\in I}P(A_i)\]</span> 则称 <span class="math inline">\(A_k(k = 1,\ 2,\ …,\n)\)</span> 相互独立</p><h5 id="定理-2.4独立性的另一定义">定理 2.4：独立性的另一定义</h5><p>设 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span> 是两个事件，且 <spanclass="math inline">\(P(A) &gt; 0\)</span> ，则 <spanclass="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>独立当且仅当 <span class="math display">\[P(B|A) = P(B)\]</span></p><h5 id="定理-2.5独立性的推论">定理 2.5：独立性的推论</h5><p>若事件 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(B\)</span> 独立，则对下列各对事件均相互独立 <spanclass="math display">\[A\ \&amp;\ \overline{B}\\ \overline{A}\ \&amp;\ B\\ \overline{A}\\&amp;\ \overline{B}\]</span></p><h3 id="随机测试示例">2.3随机测试示例</h3><h4 id="问题背景">2.3.1 问题背景</h4><h4 id="随机测试初步">2.3.2 随机测试初步</h4><h4 id="随机测试改进">2.3.3 随机测试改进</h4>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率</tag>
      
      <tag>Bayes公式</tag>
      
      <tag>随机测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 数据分析初探</title>
    <link href="/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/10/29/Fundamentals%20of%20Data%20Science/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-数据分析初探">第一章 数据分析初探</h2><h3 id="认识数据">1.1 认识数据</h3><h5 id="定义-1.1数据">定义 1.1：数据</h5><p>数据是自然世界抽象为集合元素的表示。在实际应用中，采用某种数学元素作为数据的抽象表示，数据集作为相应的集合</p><h5 id="定义-1.2信息">定义 1.2：信息</h5><p>数据赋予某种结构获得信息 <spanclass="math inline">\(\mathcal{I=S}(\mathcalD)\)</span>。信息通常能被人类所理解，并被用来消除不确定性。</p><h5 id="定义-1.3偏序结构">定义 1.3：偏序结构</h5><p><span class="math inline">\(A\)</span> 上的关系 <spanclass="math inline">\(R\)</span> 是自反的，反对称的，传递的。则 <spanclass="math inline">\(R\)</span> 是一个偏序，集合 <spanclass="math inline">\(A\)</span> 与 <spanclass="math inline">\(R\)</span>一起称作偏序集，记做 <spanclass="math inline">\((A,\ R)\)</span>，在不引起混淆的情况下，可以简写成<span class="math inline">\(A\)</span></p><h5 id="定义-1.4知识">定义 1.4：知识</h5><p>知识是信息和规则的二元组 <spanclass="math inline">\(\mathcal{K}=&lt;\mathcal{I,R}&gt;\)</span>。信息与规则结合获得知识，并且能够推理出更多的知识</p><h3 id="数据类型">1.2 数据类型</h3><h5 id="定义1.5定类数据norminal">定义1.5：定类数据（Norminal）</h5><p>定类数据是对事物进行分类的结果，表现为类别，是仅仅反映观测对象所属类别的数据</p><h5 id="定义-1.6定序数据original">定义 1.6：定序数据（Original）</h5><p>定序数据是只仅仅反映观测对象等级，顺序关系的数据，是有定序尺度计量而形成的，表现为类别，可以进行排序，属于品质数据</p><h5 id="定义-1.7定距数据interval">定义 1.7：定距数据（Interval）</h5><p>定距数据是指具有顺序和距离属性的数据，室友定距尺度计量形成的，表现为数值，可以进行加、减运算以精确计算的数据</p><h5 id="定义-1.8定比数据ratio">定义 1.8：定比数据（Ratio）</h5><p>定比数据是指具有顺序，距离和比例属性的数据，室友定比尺度计量形成的，表现为数值，可以进行四则运算。没有负数。</p><h3 id="数据汇总">1.3 数据汇总</h3><h5 id="定义-1.9众数">定义 1.9：众数</h5><p>众数是一批数据中出现次数最多的那个数，记为 <spanclass="math inline">\(M_0\)</span></p><h5 id="定义-1.10中位数">定义 1.10：中位数</h5><p>设一批数据经过排序之后为 <span class="math inline">\(X_1,\ X_2,\ …,\X_n\)</span>，则其中位数 <span class="math inline">\(M_e \triangleqM_{[\frac{n+1}{2}]}\)</span></p><h5 id="定义-1.11四分位数">定义 1.11：四分位数</h5><p>一批数据按升序排序后为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其第 <span class="math inline">\(i\)</span> 位的四分位数<span class="math inline">\(Q_i \triangleq \frac{i(n+1)}{4},\ (i = 1,\2,\ 3)\)</span></p><h5 id="定义-1.12算术平均值">定义 1.12：算术平均值</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其算数平均值 <span class="math display">\[\overline{X}\triangleq\frac{1}{n}\sum_{i = 1}^{n}X_i\]</span></p><h5 id="定理-1.1算术平均值归零性">定理 1.1：算术平均值归零性</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，<span class="math inline">\(\overline{X}\)</span>为其算数平均值，则 <span class="math display">\[\sum_{i = 1}^{n}(X_i-\overline{X}) = 0\]</span></p><h5 id="定义-1.13加权算术平均值">定义 1.13：加权算术平均值</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，相应的权重为 <span class="math inline">\(\omega_1,\\omega_2\ ,…,\ \omega_n\)</span>，不失一般性，我们假设权重和为 <spanclass="math inline">\(1\)</span> ，则其加权算术平均值为 <spanclass="math display">\[\overline{X} = \sum_{i = 1}^{n}\omega_iX_i\]</span></p><h5 id="定义-1.14内四分位距">定义 1.14：内四分位距</h5><p>内四分位距 <span class="math inline">\(\triangleqQ_3-Q_1\)</span></p><h5 id="定义-1.15偏差平方和方差和标准差">定义1.15：偏差平方和，方差和标准差</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则数据的偏差平方和为每个数据与平均值偏差平方的和，即 <spanclass="math display">\[d^2\triangleq\sum_{i = 1}^{n}(X_i-\overline X)^2\]</span> 数据的方差 <span class="math inline">\(S^2\)</span>为偏差平方和的平均值 <span class="math display">\[S^2\triangleq {d^2\over n}\]</span> 数据的标准差 <span class="math inline">\(S\)</span>为方差的算术平方根 <span class="math display">\[S \triangleq \sqrt{S^2}\]</span></p><h5 id="定理-1.2偏差平方和计算公式">定理 1.2：偏差平方和计算公式</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，其方差为 <span class="math inline">\(S^2\)</span>，则<span class="math display">\[d^2= \sum_{i = 1}^{n}X_i^2-{(\displaystyle\sum_{i = 1}^nX_i)^2\over n}\]</span></p><h5 id="定义-1.16修正方差和标准差">定义 1.16：修正方差和标准差</h5><p>设一批数据为 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则数据的方差和标准差 <span class="math inline">\(S^2,\S\)</span> 为 <span class="math display">\[S^2 = {d^2\over n -1}\\S = \sqrt{S^2}\]</span></p><h5 id="定义-1.17变异系数">定义 1.17：变异系数</h5><p>样本的变异系数为样本标准差除以样本的均值</p><h5 id="定理-1.3算术平均值偏差极小性">定理1.3：算术平均值偏差极小性</h5><p>设数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，<span class="math inline">\(\overline{X}\)</span>为其算术均值，则算术平均值 <span class="math inline">\(\overlineX\)</span> 的偏差平方和最小，即 <span class="math display">\[\overline{X} = arg\min_{a}\sum_{i = 1}^{n}(X_i - a)^2\]</span></p><h5 id="定义-1.18矩">定义 1.18：矩</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，其 <span class="math inline">\(k\)</span> 阶原点矩定义为<span class="math inline">\((k\in\mathbb{N})\)</span> <spanclass="math display">\[A_k = {1\over n}\sum_{i = 1}^{n}x_i^k\]</span> 其 <span class="math inline">\(k\)</span> 阶中心矩定义为 <spanclass="math inline">\((k\in\mathbb{N})\)</span> <spanclass="math display">\[B_k = {1\over n}\sum_{i = 1}^{n}(X_i - \overline{X})^k\]</span></p><h5 id="定理-1.4矩表示">定理 1.4：矩表示</h5><p><span class="math display">\[B_k = \sum_{i = 0}^{n}C_n^i(-A_1)^iA_{n-i}\]</span></p><h5 id="定义-1.19偏度">定义 1.19：偏度</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其偏度 <span class="math inline">\(s^3\)</span> 为 <spanclass="math display">\[s^3\triangleq {B_3\over B_2^{1.5}}\]</span></p><h5 id="定义-1.20峰度">定义 1.20：峰度</h5><p>设一批数据 <span class="math inline">\(X_1,\ X_2\ ,…,\X_n\)</span>，则其峰度 <span class="math inline">\(s^4\)</span> 为 <spanclass="math display">\[s^4 = {B_4\over B_2^2}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Fundamentals of Data Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data</tag>
      
      <tag>order</tag>
      
      <tag>矩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Network Layer</title>
    <link href="/2022/10/27/Computer%20Networking/OSI%20Model/OSI%20Network%20Layer/"/>
    <url>/2022/10/27/Computer%20Networking/OSI%20Model/OSI%20Network%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次网络层">OSI层次：网络层</h1><blockquote><p>关键词：路径选择、路由、寻址</p><p>当路由发生时，在两个系统之间提供连接和路径选择</p><p>这些存在于地理上分离的网络</p></blockquote><h2 id="网络层概述">1. 网络层概述</h2><h3 id="第三层的责任">1.1. 第三层的责任</h3><ul><li>通过网络传递数据</li><li>使用分层的寻址方案（不同于水平的MAC寻址）</li><li>网段与数据流控制</li><li>减少拥堵</li><li>与其他网络连通</li></ul><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210240653203.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005760.png"alt="pic6" /></a></p><h3 id="面向连接的网络服务">1.2. 面向连接的网络服务</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210240653826.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005779.png"alt="pic7" /></a></p><p>pic7</p><ul><li>在传输任何数据之前，在发送方和接收方之间建立连接</li></ul><h3 id="电路交换">1.3. 电路交换</h3><ul><li><em>面向连接</em> 和 <em>电路交换</em> 这两个术语并不相同</li><li>面向连接：首先与接受者建立连接，然后开始数据传输。所有的数据依次通过同一个通道，或者更常见的是，通过同一个虚拟电路</li></ul><h3 id="无连接网络服务">1.4. 无连接网络服务</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241025533.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005797.png"alt="pic8" /></a></p><p>在无连接网络服务中，每一个包会被分别对待（IP就是一个无连接系统）</p><h3 id="包交换">1.5. 包交换</h3><ul><li><em>无连接网络</em> 和 <em>包交换</em> 这两个术语不相同</li><li>当数据包从源传递到目标时，它们可以：<ul><li>切换到不同的路径</li><li>不正常到达</li></ul></li><li>设备根据各种标准确定每个包的路径，有些函数可能因数据包而异</li></ul><h3 id="第三层设备-路由器">1.6. 第三层设备-路由器</h3><p>互连网段或者网络</p><p>根据IP地址做出逻辑决策</p><p>确定最佳路径</p><p>将数据包从传入端口切换到传出端口</p><h2 id="ip-地址和子网">2. IP 地址和子网</h2><h3 id="ip">2.1. IP</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241026590.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005829.png"alt="pic9" /></a></p><ul><li>版本：占4bit，指的是IP协议的版本目前的IP协议版本号为4（即IPv4）</li><li>首部长度：占4bit，可表示的最大数值是15个单位（一个单位为4字节），因此IP的首部长度的最大值是60字节，最小值是20字节</li><li>服务类型：占8bit，用来获得更好的服务，这个字段之前一直没有被人们使用</li><li>总长度：占16bit，指的是首部和数据之和的长度，单位为字节，因此数据报的最大长度为65536字节，总长度必须不超过最大传送单元MTU（<strong>指一种通信协议的某一层上面所能通过的最大数据报大小)</strong></li><li>标识(identification)：占16bit，它是一个计数器，用来产生数据报的标识</li><li>标志：占3bit，最高位为0，MF为0表示最后一个分片</li><li>片位移：占13bit，指出：较长的分组在分片之后，某片在原分组中的相对位置，片位移以8个字节为偏移单位</li><li>生存时间：占8bit记为TTL(Time To Live)数据报在网络中可通过的路由器数的最大值。</li><li>协议：占8bit 指出此数据报携带的数据使用何种协议 以便目的主机的 IP层将数据部分上交给哪个处理过程</li><li>首部检验和：16bit 只检验数据报的首部，不包括数据部分，这里不采用 CRC检验码而采用简单的计算方法</li><li>源地址和目标地址：占8位</li></ul><h3 id="网络层地址">2.2. 网络层地址</h3><p>IP地址是32bits</p><p>格式：四个点分的十进制 133.14.17.0</p><p>IP地址由两部分组成：</p><p>①网络ID</p><p>由ARIN分配(American Registry for Internet Numbers, <ahref="http://www.arin.net/">www.arin.net</a>)</p><p>标志设备连接到的网络</p><p>可以由前三个八位中的一个，两个，或者三个识别出</p><p>②主机ID</p><p>由网络管理员分配</p><p>标志了该网络中的被连接的设备</p><p>可以由后三个八位中的一个，两个，或者三个识别出</p><h3 id="ip地址">2.3. IP地址</h3><table><thead><tr class="header"><th style="text-align: center;">A类</th><th>N</th><th>H</th><th>H</th><th>H</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">B类</td><td>N</td><td>N</td><td>H</td><td>H</td></tr><tr class="even"><td style="text-align: center;">C类</td><td>N</td><td>N</td><td>N</td><td>H</td></tr></tbody></table><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241027983.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005858.png"alt="pic13" /></a></p><h4 id="主机数量">2.3.1. 主机数量</h4><ul><li>不同类别的主机最大数量是不同的</li><li>A类网络中n最多有 16,777,214 个主机 (224–2224–2)</li><li>B类网络中最多有 65,534 个主机 (216–2216–2)</li><li>C类网络中最多有 254 个主机 (28–228–2)</li><li>每个网络中的第一个地址（即主机号全为0）是预留的网络地址，表示本机所连接的网络地址</li><li>最后一个地址（即主机号全为1）预留的，用于表示所有主机</li></ul><h4 id="预留地址">2.3.2. 预留地址</h4><p><strong>网络地址</strong></p><p>主机号部分地址全为0</p><p>A类网络地址实例: <code>113.0.0.0</code></p><p>网络中的主机只能在网络号相同的时候，与其它主机直接通讯</p><p><strong>广播地址</strong></p><p>用于给该网络中所有设备发送数据</p><p>广播IP地址是主机号全为1的地址</p><p>B类地址示例: <code>176.10.255.255</code></p><p>受限网络地址：<code>255.255.255.255</code></p><h4 id="ip寻址">2.3.3. IP寻址</h4><p><strong>A</strong>类</p><p><code>99.0.0.0</code>: 预留的网络地址</p><p><code>99.255.255.255</code>: 广播数量</p><p><strong>B</strong>类</p><p><code>156.1.0.0</code>: 预留的网络地址</p><p><code>156.1.255.255</code>: 广播数量</p><p><strong>C</strong>类</p><p><code>203.1.17.0</code>: 预留的网络地址</p><p><code>203.1.17.255</code>: 广播数量</p><p><strong>私有地址空间</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.0.0.0</span> - <span class="hljs-number">10</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span><br><span class="hljs-number">172.16.0.0</span> - <span class="hljs-number">172</span>.<span class="hljs-number">31</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span><br><span class="hljs-number">192.168.0.0</span> - <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><p>有一些IP地址范围预留给私有IP地址空间</p><p>IP 地址损耗 和它的解决办法 :</p><p>NAT（网络地址转换Network Address Translation）</p><p>CIDR（无类别域间路由，Classless Inter-Domain Routing）</p><p>IPv6（Internet Protocol Version 6互联网协议）</p><p><strong>子网</strong></p><p>网络管理员有时候需要把网络划分成更小的网络，即子网，来提供额外的灵活性</p><p>从主机号的地址域借了几位用于表示子网地址域</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262315207.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005963.png"alt="pic14" /></a></p><p><strong>子网基础</strong></p><p>子网是网络的小划分</p><p>提供寻址的灵活性</p><p>子网地址通常由网管分配</p><p>子网减少了广播域</p><p><strong>能借多少位</strong></p><p>至少要借两位</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">主机域大小</th><th style="text-align: center;">最多借位</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Class A</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr class="even"><td style="text-align: center;">Class B</td><td style="text-align: center;">16</td><td style="text-align: center;">14</td></tr><tr class="odd"><td style="text-align: center;">Class C</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td></tr></tbody></table><p>为什么至少取两位？取一位的话无法区分subNetID和masterNetID，如果你只借了一位来构造子网，那么你只有一个网络号0，以及广播号1</p><p><strong>副产品：浪费的地址</strong></p><p>我们必须在需要的子网数量，可接受的每个子网中主机的数量，和导致的地址浪费中，保持平衡。</p><table><thead><tr class="header"><th style="text-align: center;"><strong>借的位数</strong></th><th style="text-align: center;"><strong>构造的子网数量</strong></th><thstyle="text-align: center;"><strong>每个子网中主机的个数</strong></th><th style="text-align: center;"><strong>主机的总个数</strong></th><th style="text-align: center;"><strong>利用率</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">62</td><td style="text-align: center;">124</td><td style="text-align: center;">49%</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">30</td><td style="text-align: center;">180</td><td style="text-align: center;">71%</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">14</td><td style="text-align: center;">14</td><td style="text-align: center;">196</td><td style="text-align: center;">77%</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">30</td><td style="text-align: center;">6</td><td style="text-align: center;">180</td><td style="text-align: center;">71%</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">62</td><td style="text-align: center;">2</td><td style="text-align: center;">124</td><td style="text-align: center;">49%</td></tr></tbody></table><p>构造子网的数量 =2借的位数−2=2借的位数−2</p><p>不能使用第一个子网和最后一个子网，因为一个是广播地址，另一个是网络地址</p><p><strong>子网掩码</strong></p><p>别名：扩展网络前缀</p><p>决定了我们用多少位来构建网络，以及多少位描述主机地址</p><p>A类 255.0.0.0</p><p>B类 255.255.0.0</p><p>C类 255.255.255.0</p><p><strong>子网划分</strong></p><p>我们将下面的IP地址划分子网:223.14.17.0</p><p>需要:</p><p>13 个子网</p><p>每个子网10个主机</p><p>详细计算步骤参见PPT网络层</p><p><strong>计算子网地址</strong></p><p>步骤 1: 把IP地址转化为二进制</p><p>步骤 2: 把子网掩码转化为二进制</p><p>步骤 3: 用 Boolean 运算符 “and” 计算它们两个</p><p>步骤 4: 把网络地址的二进制转化为带点的十进制</p><h2 id="第三层设备">3. 第三层设备</h2><h3 id="路径选择">3.1. 路径选择</h3><p>路由器基于链路带宽、距离、延迟，来选择传递数据包到目的地的下一个路径上的跳跃</p><h3 id="ip地址-1">3.2. IP地址</h3><p>IP 地址在软件中实施，用于指出设备所在的网络</p><p>路由器连接到网络，每一个网络必须有一个独特的网络号使得路由能成功地连接</p><p>独特的网络号包含于IP地址中，被分配给每一个连接到该网络的设备</p><h3 id="路由接口">3.3. 路由接口</h3><h3 id="路由功能">3.4. 路由功能</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241028790.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005036.png"alt="img" /></a></p><p>①剥离框架中的数据链路报头（数据链路报头包括来源目的MAC地址和目的MAC地址）</p><p>②检查网络层地址来决定目的地网络</p><p>③查询它的路由表来决定使用哪一个接口来发送数据，使得数据可以到达目的地网络</p><p>④通过B1接口发送数据，路由器会将数据封装在合适的数据链路框架(帧)中</p><h3 id="路由接口示例">3.5. 路由接口示例</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241028143.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005068.png"alt="pic17" /></a></p><p>一个路由器通过接口连接到网络，接口也可能指IP路由中的一个端口</p><p>每一个接口都有一个单独的、独特的网络地址</p><h3 id="ip地址分配">3.6. IP地址分配</h3><p>静态地址分配</p><p>给每一个设备配置一个IP地址</p><p>你应该保留非常细致的记录，因为一旦你是用的重复的IP地址，问题就来了</p><p>动态地址分配</p><p>这里有一些可以动态分配地址的不同方法：</p><p>–RARP: Reverse Address Resolution Protocol.逆向地址解析协议</p><p>–BOOTP: BOOTstrap Protocol.自举协议</p><p>–DHCP: Dynamic Host ConfigurationProtocol.动态主机配置协议(我们一般使用这种方式)</p><h2 id="arp协议">4.ARP协议</h2><h3 id="地址解析协议">4.1. 地址解析协议</h3><p>为了让设备通讯，发送方的设备必须有目的设备的IP地址和MAC地址，<em>缺一不可</em></p><p>ARP 使得一台电脑可以获取与一个IP地址相关的MAC地址</p><h3 id="arp操作">4.2. ARP操作</h3><p>①广播询问MAC地址(请求)</p><p>②IP地址匹配(检查)</p><p>③对应主机回复自己的MAC地址(应答)</p><p>④根据ARP缓存表发送数据帧(ARP缓存表中每个条目具有一定的生命周期)(缓存)</p><h3 id="互联网通讯">4.3. 互联网通讯</h3><p>怎么与不在一个物理网段的设备通讯？</p><p>默认网关</p><p>代理 ARP</p><h3 id="默认网关">4.4. 默认网关</h3><p>为了让一个设备可以和别的网络中的设备通讯，你必须给它提供一个默认网关</p><p>默认网关是连接来源主机所处的网段的路由接口的IP地址</p><p>为了让一个设备可以给其它网段上的设备发送数据，来源设备将数据发送到默认网关</p><h3 id="代理arp">4.5.代理ARP</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241029680.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005153.png"alt="pic18" /></a></p><p>代理ARP是ARP的一种变化形式</p><p>这种情况下，来源主机没有配置默认网关</p><h3 id="arp流程">4.6. ARP流程</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241030740.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005269.png"alt="pic19" /></a></p><h2 id="网络层服务">5. 网络层服务</h2><h3 id="面向连接的网络服务-1">5.1. 面向连接的网络服务</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241030352.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005420.png"alt="pic20" /></a></p><p>传输数据前会在发送者和接受者之间建立连接</p><h2 id="routed-and-routing-protocols">6. Routed and RoutingProtocols</h2><h3 id="网络协议操作">6.1. 网络协议操作</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241031069.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005511.png"alt="pic21" /></a></p><p>pic21</p><h3 id="被动路由协议">6.2. 被动路由协议</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241031592.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005547.png"alt="pic22" /></a></p><p>给网络层提供帮助的协议被称为被动（routed）路由协议或可路由（routable）协议</p><p>IP是一个网络层协议，因此，它可以被互联网发送</p><h3 id="不可路由协议">6.3. 不可路由协议</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241031640.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005558.png"alt="pic23" /></a></p><p>不可路由协议不支持第三层</p><p>其中最常见的不可路由协议是NetBEUI（网络BIOS扩充用户接口）</p><p>NetBEUI 是一个小、快、高效的协议，但只能在一个网段上运行</p><h3 id="访问可路由协议">6.4. 访问可路由协议</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241030763.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005604.png"alt="pic24" /></a></p><h3 id="路由协议">6.5. 路由协议</h3><p>路由（routing）协议决定了被动路由（routed）协议前往目的地的路径</p><p>用于路由器之间的协议，以便它们可以动态地获知路由信息，并将它们添加到路由表中。</p><h3 id="分类">6.6. 分类</h3><h4 id="静态和动态">6.6.1. 静态和动态</h4><ul><li>静态路由:<ul><li>网关手动将路由信息输入路由器</li></ul></li><li>动态路由:<ul><li>路由器可以联机（on the fly）交换彼此信息</li><li>使用路由（routing）协议来更新路由信息</li><li>RIP, IGRP, EIGRP, OSPF …</li></ul></li></ul><p><strong>静态路由VS动态路由</strong></p><ul><li>静态路由:<ul><li>隐藏了部分互联网</li><li>测试网络中某个特定的链接</li><li>当只有一条路径到达目的网络时，便于维持路由表</li></ul></li><li>动态路由:<ul><li>维持路由表</li><li>定时更新路由信息</li><li>基于路由（routing）协议，共享路由信息</li><li>路由器可以适应变化的网络条件</li></ul></li></ul><h4 id="igp和egp">6.6.2. IGP和EGP</h4><p>动态路由</p><p><strong>I</strong>nterior <strong>G</strong>ateway<strong>P</strong>rotocols (RIP, IGRP, EIGRP, OSPF)内部网关协议:</p><p>用于自治系统，管理局域网中的路由器，如：校园网，公司内网……</p><p><strong>E</strong>xterior <strong>G</strong>ateway<strong>P</strong>rotocols (EGP, BGP)外部网关协议:</p><p>用于自治系统之间传送包</p><p><strong>IGP vs EGP</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241030194.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005617.png"alt="pic25" /></a></p><p>pic25</p><h4 id="dvp和lsp">6.6.3. DVP和LSP</h4><ul><li><strong>D</strong>istance-<strong>V</strong>ector<strong>P</strong>rotocols (RIP, IGRP)距离矢量协议:<ul><li>从相邻的视角看网络拓扑</li><li>路由器之间添加距离矢量</li><li>周期性频繁的更新</li><li>复制一份路由表，传给相邻路由器</li></ul></li><li><strong>L</strong>ink <strong>S</strong>tate<strong>P</strong>rotocols (OSPF)链路状态协议:<ul><li>了解整个网络拓扑</li><li>计算去其它路由的最短路径</li><li>由事件触发更新</li><li>把链路状态路由的更新信息发给其它路由</li></ul></li></ul><h3 id="发送距离矢量">6.7. 发送距离矢量</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241033027.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005654.png"alt="pic26" /></a></p><h3 id="发送链路状态">6.8. 发送链路状态</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241033877.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005749.png"alt="pic27" /></a></p><h3 id="riproute-information-protocol路由信息协议">6.9. RIP(RouteInformation Protocol)路由信息协议</h3><p><strong>一定会考！！</strong></p><p>最受欢迎</p><p>属于内部网关协议、距离矢量协议</p><p>跳数hop是唯一的度量标准</p><p>最大跳数为15</p><p>每30秒更新一次</p><p>不总是选择最快路径</p><p>产生很多网络拥塞</p><p>RIP v2 是 RIP v1的一个很重要的改进版本</p><h3 id="igrp内部网关路由选择协议eigrp增强网关路由选择协议">6.10.IGRP(内部网关路由选择协议)&amp;EIGRP(增强网关路由选择协议)</h3><p>思科专利</p><p>属于内部网关协议、距离矢量协议</p><p>综合以延迟，带宽，负载，可靠性为度量标准</p><p>最大跳数为255</p><p>每90秒更新一次</p><p>EIGRP 是 IGRP的进阶版, 混合了路由（routing）协议</p><h3 id="ospfopen-shortest-path-first开放最短路径优先">6.11. OSPF(OpenShortest Path First)开放最短路径优先</h3><p>属于内部网关协议、链路状态协议</p><p>综合以代价，速度，可靠性，安全性为衡量</p><p>由事件触发更新</p><h2 id="vlsm">7. VLSM</h2><h3 id="有类路由vlsm可变长子网掩码">7.1.有类路由&amp;VLSM可变长子网掩码</h3><h4 id="有类路由">有类路由</h4><p>有类路由协议要求一个网络只能有一个子网掩码</p><p>示例：网络192.168.187.0必须只使用一个子网掩码如255.255.255.0</p><h4 id="vlsm-可变长子网掩码">VLSM-可变长子网掩码</h4><p>VLSM的优点是允许一个自治系统有不同的子网掩码</p><h3 id="vlsm-1">7.2. VLSM</h3><p>有了VLSM，网管可以在少量主机的网络上使用长子网掩码，大量主机的网络上使用短子网掩码</p><p>如果路由协议允许VLSM：</p><p>在网络连接上使用一个30位的子网掩码，255.255.255.252</p><p>给用户网络一个24位的掩码，255.255.255.0</p><p>或者，甚至一个22位的掩码，255.255.252.0，给有着近1000用户的网络</p><p>优点:</p><p>更有效的使用IP地址</p><p>使用路由汇总的能力更强</p><p>支持 VLSM 的路由协议:</p><p>OSPF开放最短路径优先</p><p>Integrated Intermediate System to Intermediate System (IntegratedIS-IS)</p><p>EIGRP增强内部网关路由选择协议</p><p>RIP v2</p><p>静态路由</p><p>空间浪费：</p><p>过去建议不要使用第一个和最后一个子网，但是我们可以在Cisco IOSver12.0中使用子网</p><p>在 IOS ver12.0 中, 思科路由器默认使用子网0</p><p>命令：router(config)#no ip subnet-zero</p><h3 id="为什么使用vlsm">7.3. 为什么使用VLSM</h3><p>VLSM 允许一个组织在一个网络地址空间，使用不只一个子网掩码</p><p>使用 VLSM通常被理解为“给子网划分子网”，可以用来使得寻址效率最大化</p><p>VLSM 是帮助缩小IPv4和IPv6之间差距的修正之一</p><h3 id="怎么使用vlsm">7.4. 怎么使用VLSM</h3><p>示例：</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241034156.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005783.png"alt="pic28" /></a></p><p>一个C类地址192.168.10.0/24 (表示前24位为网络号)已经被分配</p><p>珀斯，悉尼，新加坡有一个连接到KL的广域网</p><p>珀斯需要60个主机</p><p>KL 需要28个主机.</p><p>悉尼和新加坡各需要12个主机</p><p>为了计算VLSM子网和各自的主机数，在地址范围中先分配最大的需求。需求水平应该按照从大到小的顺序排列。</p><p><strong>步骤一</strong></p><p>珀斯需要60个主机</p><p>用6位，因为这样有2^6-2=62个可用主机地址，因此第4个八位中的2位将表示/26的扩展网络前缀，剩余的6位用来表示主机地址</p><p>将VLSM用在地址192.168.10.0/24上，有：</p><p>192.168.10.00 hhhhhh/26</p><p>255.255.255.192(1100 0000)</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241034473.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005812.png"alt="pic29" /></a></p><p><strong>步骤二</strong></p><p>KL需要28个主机。在192.168.10.63/26后，下一个可用的地址是192.168.10.64/26</p><p>因为需要28个主机，所以需要5位表示主机地址，这样有2^5-2=30个可用的主机</p><p>因此需要5位来表示主机，3位用于/27的扩展网络前缀</p><p>将VLSM使用在192.168.10.64/26上，有：</p><p>192.168.10.<strong>010</strong> hhhhh/27</p><p>255.255.255.224(1110 0000)</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241034636.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005902.png"alt="pic30" /></a></p><p><strong>步骤三</strong></p><p>现在悉尼和新加坡各需要12个主机，下一个可用地址从192.168.10.96/27开始</p><p>因为需要12个主机，所以需要4位表示主机地址，有2^4-2=14个可用地址</p><p>因此4位代表主机，4位用于/28的扩展网络前缀</p><p>将VLSM用在192.168.10.96/27上，有：</p><p>192.168.10.<strong>0110</strong> hhhh/28</p><p>255.255.255.240(1111 0000)</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035305.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005210.png"alt="pic31" /></a></p><p><strong>步骤四</strong></p><p>现在给广域网分配链接地址，记住，每个广域网链接需要2个IP地址，下个可获取的子网是192.168.10.128/28</p><p>因为每个广域网链接需要2个网络地址，所以2位用于表示主机，有2^2-2=2个可用地址</p><p>因此需要2位表示链接，6位表示/30的扩展网络前缀</p><p>将VLSM用在192.168.10.128/28上，有：</p><p>192.168.10.<strong>100000</strong> hh/30</p><p>255.255.255.250(1111 1100)</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035266.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005471.png"alt="pic32" /></a></p><p><strong>result</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035283.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005565.png"alt="pic33" /></a></p><p>只有没有被使用的子网可以被进一步划分子网</p><p>如果一个子网的任何地址被使用了，那么这个子网不能再被划分</p><h3 id="路由聚合">7.5. 路由聚合</h3><p>无类别域间路由和VLSM的使用，不仅防止了地址浪费，还促进路由聚合</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035358.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005575.png"alt="pic34" /></a></p><p>pic34</p><p><strong>示例</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035986.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005655.png"alt="pic35" /></a></p><p>计算</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241035591.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005742.png"alt="pic36" /></a></p><p><strong>优点</strong></p><p>减少路由表条目数</p><p>用于隔离拓扑的变化</p><p>为了让聚合正确工作，要仔细地在层次结构中分配地址，使得汇总的地址分享同样的高位比特</p><p>VLSM允许路由聚合，通过将聚合完全基于左边共享的高位，来增加灵活性，即使网络是不连续的。</p><h2 id="icmp">8. ICMP</h2><h3 id="一些概念">8.1. 一些概念</h3><p>ICMP (Internet Control Message Protocol)：为了提高 IP数据报交付成功的机会</p><p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</p><p>ICMP 只是 IP 层的协议</p><p>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP数据报发送出去</p><h3 id="icmp报文的格式">8.2. ICMP报文的格式</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241036001.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005795.png"alt="pic37" /></a></p><h3 id="两种icmp报文">8.3. 两种ICMP报文</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241036590.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005858.png"alt="pic38" /></a></p><h3 id="目的站不可到达">8.4. 目的站不可到达</h3><p><strong>网络不可到达</strong>(net unreachable)</p><p><strong>主机不可到达</strong>(host unreachable)</p><p><strong>协议不可到达（</strong>protocol unreachable）</p><p><strong>端口不可到达（</strong>port unreachable）</p><p><strong>源路由选择不能完成（</strong>source route failed）</p><p><strong>目的网络不可知（</strong>unknown destination network）</p><p><strong>目的主机不可知</strong>（unknown destination host）</p><h3 id="icmp差错报告报文的数据字段的内容">8.5.ICMP差错报告报文的数据字段的内容</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241036447.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005892.png"alt="pic39" /></a></p><h3 id="不应发送icmp差错报告报文的几种情况">8.6.不应发送ICMP差错报告报文的几种情况</h3><p>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</p><p>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP差错报告报文</p><p>对具有多播地址的数据报都不发送 ICMP 差错报告报文</p><p>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送 ICMP差错报告报文</p><h3 id="pingpacket-internet-groper">8.7. PING(Packet InterNetGroper)</h3><p>PING 是用ICMP的"Echo request"和"Echo reply"消息来实现的</p><p>PING 用来测试两个主机之间的连通性</p><p>PING 使用了 ICMP 回送请求与回送回答报文</p><p>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的TCP或UDP</p><h2 id="移动ip">9. 移动IP</h2><h3 id="基本概念">9.1. 基本概念</h3><p>移动 IP让电脑可以在从一个因特网接入点换到另一个接入点的时候，保持网络连接</p><p>移动 IP 和 nomadic(不定) IP 是不同的:</p><p>移动 IP 可以无视接入点的变化，自动保持电脑的网络</p><p>不定 IP 在接入点变化时，必须先停止连接，然后初始化新的电脑连接</p><h3 id="移动ip的运作">9.2. 移动IP的运作</h3><p><strong>本地网络</strong>：移动节点被分配给名为本地网络(homenetwork)的特定网络,在该网络里名为本地地址的IP地址是静态的.</p><p><strong>外部网络</strong>：移动节点移至另一个网络，该网络被认为是此主机的外部网络。</p><p><strong>外部代理</strong>：移动节点通过网络节点(路由器)注册，如果路由器在外部网络，名为外部代理。</p><p>移动节点与用户本地网络的、名为本地代理的类似代理通信,将移动节点的<strong>转交地址</strong>(care-ofaddress)给予<strong>本地代理</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241036352.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005928.png"alt="pic40" /></a></p><h3 id="转交地址">9.3. 转交地址</h3><p>移动 IP 提供两种获取转交地址的模式</p><p><strong>外地代理转交地址</strong></p><p>该地址通常是发送通告的外地代理的 IP 地址</p><p>通过代理通告消息被通告给移动节点</p><p>外地代理是隧道的端点</p><p>外地代理通过隧道接收数据报时，会对收到的数据报解除封装。然后，外地代理会将内部数据报传送到移动节点</p><p>许多移动节点可以共用同一转交地址</p><p><strong>协同定位转交地址</strong></p><p>由移动节点通过一些方法（如DHCP）获取，作为自身临时IP</p><p>移动节点充当隧道的端点</p><p>移动节点对通过隧道传来的数据报解除封装</p><p>协同定位转交地址可使移动节点在没有外地代理的情况下正常工作</p><p>如果某个移动节点正在使用协同定位的转交地址，则该移动节点必须与该转交地址处于同一网段。否则，发往该转交地址的数据报将无法传送</p><h3 id="基本功能">9.4. 基本功能</h3><p><strong>发现</strong> –移动节点使用发现程序来标识期望的本地代理和外部代理</p><p>使用ICMP协议</p><p>移动节点可能在IP层不知道的情况下，由于某些切换机制的作用，从一个网络移到另一个网络。</p><p>代理发现进程的目的是使代理能检测到这样的移动</p><p>作为代理的路由器或其他网络节点，周期性发布带广播扩展的路由器广播ICMP报文。报文包括路由器的IP地址</p><p>移动节点监听这些广播报文。将路由器的网络部分与自身本地地址的网络部分比较，如果不匹配就说明移动节点在外部网络</p><p>如果移动节点未能接收到代理信息，允许其发布一个ICMP路由器请求报文来寻求路由器响应</p><p><strong>注册</strong> –移动节点使用认证注册程序将它的转交地址告知它的本地代理</p><p>用UDP协议</p><p>注册程序的不安全性</p><p>移动IP被设计成能抵挡两类攻击</p><p>一个节点可能伪装成外部代理,并向本地代理发送注册请求,以求将目的为移动节点的通信转到自己.</p><p>恶意代理可能重发旧的注册报文,有效地将移动节点由网络中除去</p><p>为达到报文认证,每个注册请求和回应包含认证扩充</p><p><strong>隧道</strong></p><p>用于将IP数据报由本地地址发至转交地址</p><p>使用IP协议。将原来整个数据报封装入一个首部带有转交地址的新IP数据报中。</p><p>隧道将原有的IP报文作为载荷，在外面包上一层新的IP包头，转换成为一个新的IP报文</p><p>在一定程度上提高了安全性</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241036689.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291005976.png"alt="pic41" /></a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Data Link Layer</title>
    <link href="/2022/10/26/Computer%20Networking/OSI%20Model/OSI%20Data%20Link%20Layer/"/>
    <url>/2022/10/26/Computer%20Networking/OSI%20Model/OSI%20Data%20Link%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次数据链路层">OSI层次：数据链路层</h1><blockquote><p>关键词：帧、介质访问控制</p><p>通过物理链路提供可靠的数据传输</p><p>关心物理寻址、网络拓扑、网络访问、错误识别、有序发送帧、流控制</p></blockquote><h2 id="数据链路层概述">1. 数据链路层概述</h2><h3 id="概述">1.1. 概述</h3><p>1.是一种逻辑概念</p><p>2.第2层协议定义了：链路上数据交换的格式 和 链路上两个节点的行为</p><p>3.数据链路层的传输只存在于相邻的链路上</p><h3 id="lans和数据链路层">1.2. LANS和数据链路层</h3><h4 id="主要任务">1.主要任务：</h4><ul><li>错误通知</li><li>网络拓扑</li><li>数据流控制</li></ul><h4id="第一层和第二层之间的不同之处">2.第一层和第二层之间的不同之处</h4><ul><li>第一层不能和更高层沟通，第二层通过 <strong><ahref="https://baike.baidu.com/item/LLC协议/9441993">LLC</a></strong>(Logic Link Control, 逻辑链路控制) 与上层沟通</li><li>第一层根据传输介质发送信号，第二层通过 <strong><ahref="https://baike.baidu.com/item/介质访问控制/10081534">MAC</a></strong>(Media Access Control，介质访问控制) 发送信号</li><li>第一层不能命名或定义主机，第二层有命名过程</li><li>第一层只能描述比特流，第二层用帧 (frame) 组织比特</li></ul><h3 id="第二层提供的服务">1.3. 第二层提供的服务</h3><p>三个由 LLC 提供给网络层的服务:</p><ul><li>无应答的无连接服务（不需要对方同意）用于：可靠的链路(上层来保证数据正确性)、实时任务、绝大部分用于LANs</li><li>有应答的无连接服务，用于：不可靠的链路，如无线网络<ul><li>确认会降速（降低50%）</li></ul></li><li>有应答的连接服务，比如：蓝牙</li></ul><h3 id="在普通-lan-中的-mac">1.4. 在普通 LAN 中的 MAC</h3><p>注意这里的 <strong>以太网</strong>，<strong>令牌环</strong> 和<strong>FDDI</strong> 指的都是 <strong>LAN</strong> 的类型</p><p>以太网 (IEEE802.3)：逻辑总线拓扑 (信息流在线性总线上)和物理星型或扩展星型 (布线是星型)</p><p>令牌环 (IEEE802.5)：逻辑环形拓扑 (信息流在环中) 和一个物理星型(布线是星型)</p><p>FDDI (Fiber DistributedData Interface Network)：逻辑环形拓扑(信息流在环中) 和物理双环拓扑 (布线是双环形)</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241020402.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002465.png"alt="pic75" /></a></p><p>pic75</p><h3 id="mac-的访问方式">1.5. MAC 的访问方式</h3><ol type="1"><li>两个宽泛的种类：</li></ol><ul><li>决定性-<strong>轮流</strong>：令牌环 和 FDDI</li><li>非决定性 (概率性)-<strong>先来先服务</strong>：以太网 /IEEE802.3</li></ul><ol type="1"><li>决定性MAC协议：</li></ol><ul><li>一个特殊的数据令牌在环中循环</li><li>当主机收到令牌，它可以传输数据而不是令牌，这叫抓住令牌</li><li>当被传输的帧，传了一圈回到发射机处，站点会发射一个新令牌，原来的帧会从环上被抛弃</li></ul><ol type="1"><li>非决定性MAC协议：</li></ol><ul><li>这个MAC协议被称为，带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)<strong><em>Carrier</em></strong> <strong><em>Sense Multiple Access withCollision Detection (CSMA/CD</em></strong>)（考点！！！！！！）</li></ul><p>为了使用这个分享介质的技术，以太网允许网络设备仲裁传输的权利</p><h3 id="lan传输方式">1.6. LAN传输方式</h3><p><strong>单播</strong> (发送方只有一个人):—收到的帧的MAC地址与本站硬件地址相同</p><p><strong>多播</strong>: 发送给本局域网上部分站点的帧</p><p><strong>广播</strong>: 发送给本局域网上所有站点的帧</p><h2 id="以太网-和-csmacd">2. 以太网 和 CSMA/CD</h2><h3 id="lan标准">2.1. LAN标准</h3><ol type="1"><li>定义了<strong>物理介质</strong>和用于将设备连接到介质的连接器</li><li>定义了设备在数据链路层通讯的方式</li><li>数据链路层定义了数据怎样通过物理介质传输</li><li>数据链路层也定义了，在通信使用同一个通道去上层时，却用了不同的上层协议的情况下，怎样封装使用了特定协议的通信</li><li>数据链路层由 IEEE 分成了两个部分：<ul><li><strong>介质访问控制</strong> Media <strong>Access Control</strong><strong><em>(MAC)</em></strong> (向下层介质传输)</li><li><strong>逻辑链路控制</strong>* Logical <strong>Link Control</strong><strong><em>(LLC)</em></strong> (向上层网络传输)</li></ul></li></ol><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241021605.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002603.png"alt="pic76" /></a></p><p>pic76</p><h3 id="mac子层重要考点">2.2. MAC子层（重要考点！！）</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210241021530.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002629.png"alt="pic77" /></a></p><p>MAC 子层是帧中的域</p><ol type="1"><li>报头</li></ol><p>由0、1交替出现的开头，被称为报头 (10101011)以字节（byte）为单位（7+1）</p><p>报头（preamble）通知接收站，帧已经来了</p><ol type="1"><li>目的地址和源地址域</li></ol><p>源地址：通常是一个单播地址</p><p>目的地址：单播，多播，广播（48位）</p><p>目的地址在源地址之前：快速转发</p><ol type="1"><li>长度域暗示了这个域后面跟着的数据的字节，并先于帧校验序列域</li></ol><p><strong>由于数据长度可计算，改为type</strong></p><p><strong>小于0x0600表示length，大于0x0600表示type</strong>（0x0600=1536B）</p><ol type="1"><li>数据域包括你想要发送的信息</li></ol><p>数据域长度可变，最大是1500字节，最小是46字节</p><p>6+6+2+46+4=64<strong>确保发送一次数据占满100m双绞线，不会同时发送</strong></p><ol type="1"><li>FCS域（4字节）包括了一个循环冗余校验值cyclic redundancy check</li></ol><p>发送设备发送CRC</p><p>接受设备重新计算CRC来检查传输中帧可能受到的损失</p><h3 id="llc子层">2.3. LLC子层</h3><p>LLC子层管理通过一条链路上设备的通讯</p><p>LLC被定义在IEEE 802.2说明书中，支持无连接和面向连接的服务</p><p>LLC子层允许数据链路层的一部分，运作独立于已有技术</p><p>一个单独的LLC子层可以和不同的MAC子层相配</p><h3 id="mac地址的十六进制数字">2.4. MAC地址的十六进制数字</h3><p>MAC地址有48位，通常表示为12个十六进制</p><p>IEEE要求，前6个十六进制数（从左到右）指出制造商或供应商的身份，还包括了组织唯一标识符</p><p>剩下的6个十六进制数，由特定的供应商管理，包括接口编号</p><p><strong>对应MAC子层的目的地址</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262333792.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002694.png"alt="img" /></a></p><h3 id="以太网802.3广播">2.5. 以太网802.3广播</h3><p>一种特殊的MAC地址</p><p>广播（所有端口转发，做成总线的方式）</p><p>MAC目的地址: <strong>全是1(FFFF.FFFF.FFFF)</strong></p><p>广播可以通过不必要的打断，严重影响站点的表现</p><p>所以广播仅在一下情况应该被使用：</p><p>目的地的MAC地址未知</p><p>目的地是全体主机</p><h3 id="组帧framing">2.6. 组帧framing</h3><p>组帧是第二层封装的过程</p><p>帧是第二层的协议数据单元</p><p>帧的部分叫做域，每个域由字节构成</p><h3 id="以太网mac-csmacd历史">2.7. 以太网MAC-CSMA/CD：历史</h3><p>以太网传输数据时，所有的PC都会接收数据，再根据需求考虑是否丢弃数据</p><p>JAM SIGNAL：冲突信号，32位或者更多的1，所有的设备都会接收该信号</p><h4 id="csmacd传输流程">CSMA/CD传输流程</h4><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262334687.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002703.png"alt="pic79" /></a></p><h2 id="无线lan和csmacd">3. 无线LAN和CSMA/CD</h2><h3 id="无线lan标准">3.1. 无线LAN标准</h3><p><ahref="https://baike.baidu.com/item/海蒂·拉玛/10933854">一个小故事</a></p><ul><li>IEEE 802.11<ul><li>一个关键技术：直接序列扩频 Direct Sequence Spread Spectrum(DSSS)</li><li>DSSS 适用于操作在1到2 Mbps范围内的无线设备</li><li>DSSS 可能操作高达11 Mbps 但超过2Mbps的操作是不兼容的</li><li><strong>WIFI从此产生</strong></li></ul></li><li>IEEE 802.11b<ul><li>也叫 Wi-Fi™</li><li>它将传输能力提升至11 Mbps</li><li>所有802.11b系统都是向后兼容的，所以他们也支持802.11的 1~2Mbps数据传输率</li><li>通过使用802.11一个不同的编码技术获得更高的数据吞吐率</li><li>操作在2.4 GHz之内</li></ul></li><li>IEEE 802.11a<ul><li>覆盖使用 5 GHz传输带宽的WLAN设备</li><li>使用 5 GHz</li><li>802.11a 有能力提供 54 Mbps的数据吞吐率，若是使用叫做“双倍率”的专利技术可以到达</li><li>实际上，更标准的速率为 20-26 Mbps.</li></ul></li><li>IEEE 802.11g<ul><li>提供和802.11a (54Mbps)一样的吞吐率，但能向后兼容802.11b</li><li>使用正交频分多路复用技术(OFDM)技术</li></ul></li><li><strong>IEEE 802.11n：WLAN的下一代（目前主要使用的）</strong><ul><li>提供和802.11g相比两倍的带宽108Mbps，理论上可达500-600Mbps</li></ul></li></ul><h2 id="第二层设备">4. 第二层设备</h2><h3 id="网卡-nics">4.1. 网卡 NICs</h3><ul><li>NICs在第2层数据链路层扮演了重要的角色：<ul><li>LLC——在计算机中与上层通讯</li><li>MAC——提供对共享访问介质的结构化访问</li><li>命名——提供一个独特的MAC地址</li><li>组帧——封装过程的一部分，为了传输将比特打包</li><li>信号传递——通过使用内置的收发器来产生信号和介质接口</li><li>网卡解析01序列</li></ul></li></ul><h3 id="网桥">4.2. 网桥</h3><p>网桥将通信划分成段；基于MAC地址，而不是协议，过滤通信</p><p>网桥可以通过减少大的冲突域，来改进网络表现</p><p>当从网络中一个段到其它段的通信量比较低时，网桥工作的更好</p><p>当网段之间的通信量变得繁重，网桥会成为瓶颈，减慢通讯</p><p><strong>网桥可以识别帧了</strong></p><p><strong>透明网桥</strong></p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262334762.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002710.png"alt="pic11" /></a></p><figure><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291004430.png"alt="pic11" /><figcaption aria-hidden="true">pic11</figcaption></figure><p>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的</p><p>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D</p><p>目前以太网中使用得最多的网桥</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262334302.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002161.png"alt="pic10" /></a></p><p>pic10</p><p>问题：当网络上的设备想要发送数据的时候，但是它不知道目的地址</p><p>发送一个广播给网络上的所有设备</p><p>因为网络上每一个设备都要关注这种广播，网桥总是向前传输广播 ​太多广播可能会导致广播风暴这又会导致：</p><p>网络超时</p><p>通信减慢</p><p>无法接受的网络表现</p><p><strong>源路由网桥</strong></p><p>源路由(sourceroute)网桥在发送帧时将详细的路由信息放在帧的首部中,从而使每个经过的网桥都了解帧的路径</p><p>在令牌环网络中被广泛使用</p><p>透明网桥容易安装，但网络资源的利用不充分</p><p>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中</p><p>源站以广播方式向欲通信的目的站发送一个发现帧，每个发现帧都记录所经过的路由</p><p>发现帧到达目的站时就沿各自的路由返回源站</p><p>源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由</p><p>凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息</p><h3 id="交换机">4.3. 交换机</h3><p>有两个基本操作：</p><p>交换数据帧：帧被输入介质接收，然后被输出介质传输</p><p>交换操作保持：交换机建立和保持交换表，搜索循环。路由器建立和保持路由表和服务表</p><p>交换是一种。通过减少通信量，增加带宽，减轻EthernetLANs中的网络拥堵的技术</p><p>交换机创造专用网段，或点对点连接，然后将这些网段在交换机内的虚拟网络中连接起来</p><p>这叫虚拟回路，因为它仅在两个节点需要通讯时存在，并且是建立在交换机内的</p><p>你可以把每个交换机端口想象成一个微型网桥，这个过程叫微分段microsegmentation</p><p>每一个交换机端口给予每个主机全部的介质带宽</p><p>局域网交换机减小了冲突域的大小</p><p>然而，所有连接到交换机的主机仍然在同一个广播域中：</p><p>也就是说，从一个节点发出的广播仍然会被其他所有连接这个局域网交换机的主机接收</p><h3 id="冲突域">4.4. 冲突域</h3><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210262334639.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210291002214.png"alt="pic12" /></a></p><p>pic12</p><p>a.冲突域的桥分割</p><p>用网桥来分割局域网的以太网，给每个用户提供更多带宽，因为每个网段上用户更少</p><p>网桥不管第3层用什么协议，都会把数据帧继续传输下去</p><p>网桥增加了10%~30%的网络延迟，因为需要做决定</p><p>网桥被看做是存储转发设备，因为它必须接收全部帧，然后在转发之前，验证循环冗余校验CRC</p><p>b.冲突域的交换机分割</p><p>交换机更快，因为他们在硬件中交换，然而网桥在软件中交换</p><p>一个10 Mbps的以太局域网和一个100 Mbps以太局域网可以用交换机连接</p><p>在一个交换式以太网实现中，可用带宽可达100%</p><p>当因为CSMA/CD使得分享式以太网络只使用了全满容量的30%~40%时，网络表现最好</p><p>网桥仅仅支持存储转发，而有些交换机支持直通转发，这样减少了延迟</p><p>c.冲突域的路由器分割</p><p>路由器可以构造最高等级的分割：</p><p>构造更小的冲突域</p><p>构造更小的广播域：除非编写的程序要求，否则路由器不会继续向前传送广播</p><p>路由器通过检查数据包上的目的逻辑地址完成向前传输包，然后在它的路由表中查找向前的指令</p><p>因为路由器比网桥有更多的功能，所以操作时有着更大的延迟</p><p>路由器可以像网关一样工作：</p><p>用于连接不同的网络介质和不同的局域网技术</p>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataLink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ queue</title>
    <link href="/2022/10/26/C++%20Basic/STL%20Containers/C++%20queue/"/>
    <url>/2022/10/26/C++%20Basic/STL%20Containers/C++%20queue/</url>
    
    <content type="html"><![CDATA[<p>queue是一种容器转换器模板，调用<code>#include&lt; queue&gt;</code>即可使用队列类。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="queue-初始化">2. queue 初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;Type, Container&gt; <span class="hljs-comment">//(&lt;数据类型，容器类型&gt;）</span><br></code></pre></td></tr></table></figure><p>初始化时必须要有数据类型，容器可省略，省略时则默认为<ahref="https://so.csdn.net/so/search?q=deque&amp;spm=1001.2101.3001.7020">deque</a>类型</p><p><strong>注意：不能用vector容器初始化queue</strong></p><p>因为<code>queue</code>转换器要求容器支持<code>front(), back(), push_back()</code>及<code>pop_front()</code>，说明<code>queue</code>的数据从容器后端入栈而从前端出栈。所以可以使用<code>deque（double-ended queue，双端队列）</code>和<code>list</code>对<code>queue</code>初始化，而<code>vector</code>因其缺少<code>pop_front()</code>，不能用于<code>queue</code>。</p><p>常见的初始化实例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>queue&lt;<span class="hljs-type">double</span>&gt; q2;  <br>queue＜<span class="hljs-type">char</span>＞ q3；<br><span class="hljs-comment">//默认为用deque容器实现的queue；</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="queue-常用函数">3. queue 常用函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//在队尾插入一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//删除队列第一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中元素个数</span><br><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//如果队列空则返回true</span><br><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中的第一个元素</span><br><br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span> <span class="hljs-comment">//返回队列中最后一个元素</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="queue-使用实例">4. queue 使用实例</h4><ol type="1"><li><code>push()</code>在队尾插入一个元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>//输出 <span class="hljs-built_in">first</span><br><br>C++<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>pop()</code> 将队列中最靠前位置的元素删除，没有返回值</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>// 输出 <span class="hljs-built_in">second</span> <br>// 因为 <span class="hljs-built_in">first</span> 已经被<span class="hljs-built_in">pop</span>（）函数删掉了<br><br>C++<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>size()</code> 返回队列中元素个数</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">queue &lt;string&gt; q;<br>q.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.<span class="hljs-keyword">size</span>()&lt;&lt;endl;<br><br><span class="hljs-comment">//输出2，因为队列中有两个元素</span><br><br>C++<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>empty()</code> 如果队列空则返回<code>true</code></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">queue &lt;string&gt; q;<br>cout&lt;&lt;q.empty()&lt;&lt;endl;<br>q.push(<span class="hljs-string">&quot;first&quot;</span>);<br>q.push(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.empty()&lt;&lt;endl;<br><br><span class="hljs-regexp">//</span>分别输出<span class="hljs-number">1</span>和<span class="hljs-number">0</span><br><span class="hljs-regexp">//</span>最开始队列为空，返回值为<span class="hljs-number">1</span>（ture）；<br><span class="hljs-regexp">//</span>插入两个元素后，队列不为空，返回值为<span class="hljs-number">0</span>（false）；<br><br>C++<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>front()</code> 返回队列中的第一个元素</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">queue &lt;<span class="hljs-built_in">string</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br>q.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;q.front()&lt;&lt;endl;<br><br>// 第一行输出<span class="hljs-built_in">first</span>；<br>// 第二行输出<span class="hljs-built_in">second</span>，因为<span class="hljs-built_in">pop</span>（）已经将<span class="hljs-built_in">first</span>删除了<br><br>C++<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li><code>back()</code> 返回队列中最后一个元素</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">queue &lt;string&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;first&quot;</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;second&quot;</span>);<br>cout&lt;&lt;q.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br><br><span class="hljs-comment">//输出最后一个元素second</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="参考文章">5. 参考文章</h4><ol type="1"><li><ahref="https://blog.csdn.net/KEPROM/article/details/109744379">C++队列queue用法详解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请移步我的知乎</title>
    <link href="/2022/10/25/Discrete%20Math/%E8%AF%B7%E7%A7%BB%E6%AD%A5%E6%88%91%E7%9A%84%E7%9F%A5%E4%B9%8E/"/>
    <url>/2022/10/25/Discrete%20Math/%E8%AF%B7%E7%A7%BB%E6%AD%A5%E6%88%91%E7%9A%84%E7%9F%A5%E4%B9%8E/</url>
    
    <content type="html"><![CDATA[<p>我将 NJUSE大一下学期的离散数学（主要是简单的数据结构）进行了粗略的整理，发布在我的知乎上</p><blockquote><p><span class="citation"data-cites="怀明带你去夜生活">@怀明带你去夜生活</span></p><p>https://www.zhihu.com/column/c_1508391477789564928</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Discrete Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zhihu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ IO</title>
    <link href="/2022/10/25/C++%20Basic/%E8%80%83%E8%AF%95%E5%BF%85%E5%A4%87/C++%20IO/"/>
    <url>/2022/10/25/C++%20Basic/%E8%80%83%E8%AF%95%E5%BF%85%E5%A4%87/C++%20IO/</url>
    
    <content type="html"><![CDATA[<h3 id="控制台输入">1. 控制台输入</h3><h4 id="标准输入流-cin">1. 标准输入流 <code>cin</code></h4><p><code>cin</code> 输入原理简述：</p><p>程序的输入都建有一个缓冲区，即输入缓冲区。每次输入过程是这样的：当一次键盘输入结束时会将输入的数据存入输入缓冲区，而<code>cin</code>函数直接从输入缓冲区中取数据（<code>cin</code>读取数据是从第一个非空白字符开始到下一个空白字符结束）。正因为<code>cin</code>函数是直接从缓冲区取数据的，所以有时候当缓冲区中有<strong>残留数据</strong>时，<code>cin</code>函数会直接取得这些<strong>残留数据</strong>而不会请求键盘输入。</p><h5 id="头文件">1.1. 头文件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//&lt;iostream&gt; 中定义了 cin/cout/cerr/clog 等对象</span><br></code></pre></td></tr></table></figure><h5 id="cin">1.2. <code>cin &gt;&gt;</code></h5><p>根据 <code>cin &gt;&gt; sth</code> 中 <code>sth</code>的变量类型读取数据，这里变量类型可以为<code>int, float, char, char*, string</code>等诸多类型。这一输入操作，在遇到<strong>结束符</strong><code>（Space、Tab、Enter）</code>就结束，且<strong>结束符并不保存到变量中</strong>。</p><p><strong>注意：最后一个 <code>enter</code> 也在缓冲区</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_input</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">char</span> ch1[<span class="hljs-number">10</span>], ch2[<span class="hljs-number">10</span>];  <br>  <span class="hljs-comment">//这里的char[] 换成char* 或者是 string有相同的效果</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入两个字符串：&quot;</span> &lt;&lt; endl;  <br>    cin &gt;&gt; ch1;  <br>    cin &gt;&gt; ch2;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;两个字符串分别为：&quot;</span> &lt;&lt; endl;  <br>    cout &lt;&lt; ch1 &lt;&lt; endl;  <br>    cout &lt;&lt; ch2 &lt;&lt; endl;  <br>    cin.<span class="hljs-built_in">get</span>(ch);<br>    cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl; <span class="hljs-comment">//输出10，为最后一个enter输入</span><br>&#125;  <br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><ahref="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210251510171.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210290955796.png"alt="image-20221025151057071" /></a></p><h5 id="cin.get">1.3. <code>cin.get()</code></h5><p>其中结束符意味着遇到该符号结束字符串读取,默认为enter，读取的字符个数最多为（长度-1），因为最后一个为’\0’。要注意的是，cin.get(字符数组名，接收长度，结束符)操作遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。cin.get函数有如下几种声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>&amp; c)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, streamsize n, <span class="hljs-type">char</span> delim)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(streambuf&amp; sb)</span></span>;<br><br><span class="hljs-function">istream&amp; <span class="hljs-title">get</span><span class="hljs-params">(streambuf&amp; sb, <span class="hljs-type">char</span> delim)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="输入-int">1. 输入 <code>int</code></h4><ol type="1"><li>输入 10 个数字（以空格或者是换行符分割）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> nums[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    cin &gt;&gt; nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>输入未知个数的数字并求和</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>    sum += n;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输入-char">2. 输入 <code>char</code></h4><h5 id="输入一个字符包括空白符">2.1. 输入一个字符（包括空白符）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cin.<span class="hljs-built_in">get</span>(ch);<br><span class="hljs-comment">//就算ch是换行符/tab/空格都会被输入进去</span><br></code></pre></td></tr></table></figure><h5 id="输入一个非空白的字符">2.2. 输入一个非空白的字符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cin &gt;&gt; ch;<br><span class="hljs-comment">//直到输入非空白字符之前，程序都不会结束</span><br></code></pre></td></tr></table></figure><h5 id="输入未知个数的字符">2.3. 输入未知个数的字符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span>(cin.<span class="hljs-built_in">get</span>(<span class="hljs-type">char</span>))&#123;<br>  <span class="hljs-comment">//do something</span><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//这里连换行符或者是空格/tab都能输入，方便用来判断循环结束的条件</span><br></code></pre></td></tr></table></figure><p><code>get</code> 的返回值为 <code>istream</code> 对象，而<code>istream</code> 对象可以转换为<code>bool</code> 值，因而可以出现在<code>while</code> 的条件中；</p><p><code>&gt;&gt;</code> 实际上会转换成函数<code>operator&gt;&gt;</code> 的调用，函数的返回值也为<code>istream</code> 对象</p><h4 id="输入-stringchar">3. 输入 <code>string/char *</code></h4><h5 id="普通读入">3.1. 普通读入</h5><p>读入，以空白字符或 <code>EOF</code> 作为结束标志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br>cin &gt;&gt; s;<br></code></pre></td></tr></table></figure><h5 id="按需读入">3.2. 按需读入</h5><p>读入一行，以换行符（默认）或指定的字符（称为delimiter）作为结束标志，delimiter 会被读取但不会出现在 s 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-built_in">getline</span>(cin, a, <span class="hljs-string">&#x27;,&#x27;</span>);<br><br><span class="hljs-comment">//注意这里的 dlm 一定要是字符而不是字符串</span><br></code></pre></td></tr></table></figure><h5 id="section"></h5><h3 id="控制台输出">2. 控制台输出</h3><h3 id="文件输入">3. 文件输入</h3><blockquote><p>待补充</p></blockquote><h3 id="文件输出">4. 文件输出</h3><blockquote><p>待补充</p></blockquote><h3 id="参考文章">5. 参考文章</h3><ol type="1"><li><ahref="https://blog.csdn.net/a3192048/article/details/80303547">cin、cin.get()、cin.getline()、getline()的区别</a></li><li>https://en.cppreference.com/w/cpp/io/basic_ios/operator_bool</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>考试必备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proficiency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/24/Computer%20Networking/OSI%20Model/OSI%20Application%20Layer/"/>
    <url>/2022/10/24/Computer%20Networking/OSI%20Model/OSI%20Application%20Layer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/24/Computer%20Networking/OSI%20Model/OSI%20Transport%20Layer/"/>
    <url>/2022/10/24/Computer%20Networking/OSI%20Model/OSI%20Transport%20Layer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ string</title>
    <link href="/2022/10/23/C++%20Basic/STL%20Containers/C++%20string/"/>
    <url>/2022/10/23/C++%20Basic/STL%20Containers/C++%20string/</url>
    
    <content type="html"><![CDATA[<h3 id="头文件">1. 头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> <span class="hljs-comment">//这个可有可无</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br></code></pre></td></tr></table></figure><p><code>&lt;iostream&gt;</code>需要用到<code>std::ios_base</code>类型，<code>std::ios_base</code>有个成员函数的返回类型是<code>std::locale</code>，<code>std::locale</code>定义在<code>&lt;locale&gt;</code>头文件，<code>&lt;locale&gt;</code>中还有一个叫做<code>std::numpunct</code>的类模板，<code>std::numpunct</code>有一个成员函数的返回类型是<code>std::string</code>。</p><p>这就是为什么包含了<code>&lt;iostream&gt;</code>可以使用<code>std::string</code>。但可以看出这一串联系有多么间接和不可靠。</p><p><ahref="https://www.zhihu.com/question/270726509/answer/356155720">为什么可以不加#include</a></p><h3 id="声明一个c字符串">2. 声明一个C++字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s; <span class="hljs-comment">//调用 string 类的默认构造函数，不传入任何参数，生成一个空字符串 s </span><br><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str)</span> <span class="hljs-comment">//拷贝构造函数 生成str的复制品 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,stridx)</span> <span class="hljs-comment">//将字符串str内“始于位置stridx”的部分当 作字符串的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,stridx,strlen)</span> <span class="hljs-comment">//将字符串str内“始于stridx且长度 顶多strlen”的部分作为字符串的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(cstr)</span> <span class="hljs-comment">//将C字符串作为s的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(chars,chars_len)</span> <span class="hljs-comment">//将C字符串前chars_len个字符作为 字符串s的初值。 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(num,c)</span> <span class="hljs-comment">//生成一个字符串，包含num个c字符 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(beg,end)</span> <span class="hljs-comment">//以区间beg;end(不包含end)内的字符作 为字符串s的初值 </span></span><br><span class="hljs-function"></span><br><span class="hljs-function">s.~<span class="hljs-title">string</span><span class="hljs-params">()</span> <span class="hljs-comment">//销毁所有字符，释放内存</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><h3 id="相关函数">3. 相关函数</h3><h4 id="c字符串和c字符串的转换">3.1. C++字符串和C字符串的转换</h4><p>C++ 提供的由 C++ 字符串得到对应的<code>C_string的</code>方法是使用<code>data()、c_str()</code>和<code>copy()</code>，其中，<code>data()</code>以字符数组的形式返回字符串内容，但并不添加<code>'/0'</code>。<code>c_str()</code> 返回一个以<code>‘/0'</code> 结尾的字符数组， 而 <code>copy()</code>则把字符串的内容复制或写入既有的 <code>c_string</code> 或字符数组内。C++字符串并不以<code>'/0'</code>结尾。</p><h4 id="大小和容量函数">3.2. 大小和容量函数</h4><p>一个C++字符串存在三种大小：</p><ul><li>现有的字符数，函数是<code>size()</code>和<code>length()</code>，他们等效。<code>empty()</code>用来检查字符串是否为空。</li><li><code>max_size()</code>这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出<code>length_error</code>异常</li><li><code>capacity()</code>重新分配内存之前 <code>string</code>所能包含的最大字符数。这里另一个需要指出的是 <code>reserve()</code>函数，这个函数为 <code>string</code>重新分配内存。重新分配的大小由其参数决定， 默认参数为0，这时候会对<code>string</code>进行非强制性缩减。</li></ul><h4 id="元素存取">3.3. 元素存取</h4><p>我们可以使用下标操作符[]和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引<code>0~str.length()</code>），如果索引失效，会引起未定义的行为。而<code>at()</code>会检查，如果使用 <code>at()</code> 的时候索引无效，会抛出<code>out_of_range</code> 异常。</p><p>有一个例外不得不说，<code>const string a;</code> 的操作符[]对索引值是<code>a.length()</code>仍然有效，其返回值是<code>'/0'</code>，而<code>at()</code> 对索引值为<code>a.length()</code>仍然会抛出异常。其他的各种情况，<code>a.length()</code>索引都是无效的。举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> string <span class="hljs-title">Cstr</span><span class="hljs-params">(“<span class="hljs-type">const</span> string”)</span></span>; <br><br><span class="hljs-function">string <span class="hljs-title">Str</span><span class="hljs-params">(“string”)</span></span>; <br><br>Str[<span class="hljs-number">3</span>]; <span class="hljs-comment">//ok </span><br><br>Str.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//ok </span><br><br>Str[<span class="hljs-number">100</span>]; <span class="hljs-comment">//未定义的行为 </span><br><br>Str.<span class="hljs-built_in">at</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//throw out_of_range</span><br><br>Str[Str.<span class="hljs-built_in">length</span>()] <span class="hljs-comment">//未定义行为 </span><br>  <br>Cstr[Cstr.<span class="hljs-built_in">length</span>()] <span class="hljs-comment">//返回 ‘/0&#x27; </span><br>  <br>Str.<span class="hljs-built_in">at</span>(Str.<span class="hljs-built_in">length</span>());<span class="hljs-comment">//throw out_of_range </span><br><br>Cstr.<span class="hljs-built_in">at</span>(Cstr.<span class="hljs-built_in">length</span>()); <span class="hljs-comment">//throw out_of_range </span><br><br></code></pre></td></tr></table></figure><p>不赞成类似于下面的引用或指针赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>&amp; r=s[<span class="hljs-number">2</span>]; <br><span class="hljs-type">char</span>* p= &amp;s[<span class="hljs-number">3</span>];<br><br></code></pre></td></tr></table></figure><p>因为一旦发生重新分配，r,p立即失效。</p><p>避免的方法就是不使用。</p><h4 id="比较函数">3.4. 比较函数</h4><p>C ++字符串支持常见的比较操作符 (&gt;, &gt;=, &lt;, &lt;=, ==,!=)，甚至 支持<code>string</code>与<code>C_string</code>的比较(如<code>str &lt; "hello"</code>)。在使用 &gt;, &gt;=, &lt;, &lt;=这些操作符的时候是根据 “当前字符特性”将字符按字典顺序进行逐一比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，<code>string (“aaaa”)&lt;string(“aaaaaa”)</code>。</p><p>另一个功能强大的比较函数是成员函数<code>compare()</code>。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：</p><ul><li>0 - 相等</li><li>&gt; 0 - 大于</li><li>&lt; 0 - 小于</li></ul><p>举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(“abcd”)</span></span>; <br><br>s.<span class="hljs-built_in">compare</span>(“abcd”); <span class="hljs-comment">//返回0 </span><br><br>s.<span class="hljs-built_in">compare</span>(“dcba”); <span class="hljs-comment">//返回一个小于0的值 </span><br><br>s.<span class="hljs-built_in">compare</span>(“ab”); <span class="hljs-comment">//返回大于0的值 </span><br><br>s.<span class="hljs-built_in">compare</span>(s); <span class="hljs-comment">//相等</span><br><br>s.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,s,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//用”ab”和”cd”进行比较 小于零 </span><br><br>s.<span class="hljs-built_in">compare</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,”bcx”,<span class="hljs-number">2</span>); <span class="hljs-comment">//用”bc”和”bc”比较</span><br><br></code></pre></td></tr></table></figure><h4 id="更改内容">3.5. 更改内容</h4><h5 id="赋值">1. 赋值</h5><ul><li>第一个赋值方法当然是使用操作符<code>=</code>，新值可以是<code>string</code>(如：<code>s = ns</code>)、<code>c_string</code>(如：<code>s = ”gaint”</code>)甚至单一字符（如：`s = ‘j’ ）。</li><li>还可以使用成员函数<code>assign()</code>，这个成员函数可以使你更灵活的对字符串赋值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">assign</span>(str);<br><br>s.<span class="hljs-built_in">assign</span>(str,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//如果str是”iamangel” 就是把”ama”赋给字符串 </span><br><br>s.<span class="hljs-built_in">assign</span>(str,<span class="hljs-number">2</span>,string::npos);<span class="hljs-comment">//把字符串str从索引值2开始到结尾赋 给s </span><br><br>s.<span class="hljs-built_in">assign</span>(“gaint”); <span class="hljs-comment">//不说 </span><br><br>s.<span class="hljs-built_in">assign</span>(“nico”,<span class="hljs-number">5</span>);<span class="hljs-comment">//把&#x27;n&#x27; ‘I&#x27; ‘c&#x27; ‘o&#x27; ‘/0&#x27;赋给字符串 </span><br><br>s.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//把五个x赋给字符串</span><br><br></code></pre></td></tr></table></figure><ul><li><p>清空字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">s=””;<br>s.<span class="hljs-built_in">clear</span>();<br>s.<span class="hljs-built_in">erase</span>();<br><br></code></pre></td></tr></table></figure></li></ul><h5 id="增加">2. 增加</h5><ul><li>增加在末尾</li></ul><p>函数有 +=、 append()、push_back()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">s += str;<span class="hljs-comment">//加个字符串 </span><br><br>s += <span class="hljs-string">&quot;my name is jiayp&quot;</span>;<span class="hljs-comment">//加个C字符串 </span><br><br>s += <span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//加个字符 </span><br><br>s.<span class="hljs-built_in">append</span>(str); <br><br>s.<span class="hljs-built_in">append</span>(str, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//同前面的函数参数assign的解释 </span><br><br>s.<span class="hljs-built_in">append</span>(str, <span class="hljs-number">2</span>, string::npos);<br><br>s.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;my name is jiayp&quot;</span>); <br><br>s.<span class="hljs-built_in">append</span>(“nico”, <span class="hljs-number">5</span>); <br><br>s.<span class="hljs-built_in">append</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;x&#x27;</span>); <br><br>s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//这个函数只能增加单个字符对STL熟悉的理解起 来很简单</span><br></code></pre></td></tr></table></figure><ul><li>添加在中间的位置</li></ul><p>这时候可以用 <code>insert()</code>函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,”my name”); <br><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,str); <br></code></pre></td></tr></table></figure><p>这种形式的<code>insert()</code>函数不支持传入单个字符，这时的单个字符必须写成字符串形式。为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(size_type index,size_type num,chart c)<br><br><span class="hljs-built_in">insert</span>(iterator pos,size_type num, chart c)<br></code></pre></td></tr></table></figure><p>其中 <code>size_type</code> 是无符号整数，<code>iterator</code>是<code>char*</code>, 所以, 这么调用<code>insert</code>函数是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;j&#x27;</span>);<br></code></pre></td></tr></table></figure><p>必须这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">insert</span>((string::size_type)<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;j&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>string</code> 有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</p><h5 id="删除">3. 删除</h5><p>删除函数也有若干种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s=”il8n”; <br><br>s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,”nternationalizatio”);<span class="hljs-comment">//从索引1开始的2个替换成后面的C_string </span><br><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">13</span>);<span class="hljs-comment">//从索引13开始往后全删除 </span><br><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">7</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">//从索引7开始往后删5个</span><br></code></pre></td></tr></table></figure><h4 id="提取字串">3.6. 提取字串</h4><p>题取子串的函数是：<code>substr()</code>, 形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">substr</span>();<span class="hljs-comment">//返回s的全部内容 </span><br><br>s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">11</span>);<span class="hljs-comment">//从索引11往后的子串 </span><br><br>s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//从索引5开始6个字符</span><br></code></pre></td></tr></table></figure><p>值得注意的是，C++ 中的<code>substr()</code>第二个参数是长度，而 Java中 <code>substr()</code>的两个参数分别表示前闭后开区间的两个端点</p><h4 id="输入输出">3.7. 输入输出</h4><p>更具体的输入输出可以看<ahref="https://naturalifica.top/2022/10/23/C++%20Basic/考试必备/C++%20IO/">这篇文章</a></p><ul><li>&gt;&gt; 从输入流读取一个string。</li><li>&lt;&lt; 把一个string写入输出流。</li><li>getline(), 他从输入流读取一行内容，直到遇到分行符或到了文件尾。</li></ul><h4 id="搜索与查找">3.8. 搜索与查找</h4><p>查找函数很多，功能也很强大，包括了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">find</span>()<br>  <br><span class="hljs-built_in">rfind</span>()<span class="hljs-comment">//反过来找</span><br>  <br><span class="hljs-built_in">find_first_of</span>()<br>  <br><span class="hljs-built_in">find_last_of</span>()<br>  <br><span class="hljs-built_in">find_first_not_of</span>()<br>  <br><span class="hljs-built_in">find_last_not_of</span>()<br><br></code></pre></td></tr></table></figure><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回<code>npos</code>。所有的函数的参数<strong>说明如下：</strong></p><p>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数.</p><p>最后再说说<code>npos</code>的含义，<code>string::npos</code>的类型是<code>string::size_type</code>,所以，一旦需要把一个索引与<code>npos</code>相比，这个索引值必须是<code>string::size)type</code>类型的，更多的情况下，我们可以直接把函数和<code>npos</code>进行比较（如：<code>if(s.find(“jia”)== string::npos</code>)</p><h3 id="参考文章">参考文章</h3><ol type="1"><li><ahref="https://blog.csdn.net/samkieth/article/details/50876347">Cpp–string常用函数用法总结</a></li><li><ahref="https://www.zhihu.com/question/270726509/answer/356155720">C++使用字符串一定要 #include吗?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ map</title>
    <link href="/2022/10/23/C++%20Basic/STL%20Containers/C++%20map/"/>
    <url>/2022/10/23/C++%20Basic/STL%20Containers/C++%20map/</url>
    
    <content type="html"><![CDATA[<p>C++ 中的 <code>map</code> 刻画了键-值对这一 ADT。需要注意的是，使用map容器存储的各个键-值对，<strong>键的值既不能重复也不能被修改</strong>。换句话说，map容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const修饰，这意味着只要键值对被存储到 map容器中，其键的值将不能再做任何修改。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>C++<br></code></pre></td></tr></table></figure><h4 id="初始化">2. 初始化</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><br><span class="hljs-comment">//or</span><br><br>map&lt;string, <span class="hljs-type">int</span>&gt; myMap&#123;&#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-number">114514</span>&#125;, &#123;<span class="hljs-string">&quot;xzj&quot;</span>, <span class="hljs-number">114514</span>&#125;&#125;;<br><span class="hljs-comment">//注意这里初始化的时候不用写等号，和 Java 区别开来</span><br><br>C++<br></code></pre></td></tr></table></figure><h4 id="插入元素">3. 插入元素</h4><p><a href="http://c.biancheng.net/cplus/">C++</a> <ahref="http://c.biancheng.net/stl/">STL</a> map类模板中对<code>[ ]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[ ]</code>运算符可以实现不同的操作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>  <span class="hljs-comment">//map</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;string, string&gt; mymap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>,<span class="hljs-string">&quot;114&quot;</span>&#125; &#125;;<br>    <span class="hljs-comment">//获取已存储键值对中，指定键对应的值</span><br>    cout &lt;&lt; mymap[<span class="hljs-string">&quot;gqc&quot;</span>] &lt;&lt; endl;<br> <br>    <span class="hljs-comment">//向 map 容器添加新键值对</span><br>    mymap[<span class="hljs-string">&quot;ycy&quot;</span>] = <span class="hljs-string">&quot;514&quot;</span>;<br> <br>    <span class="hljs-comment">//修改 map 容器已存储键值对中，指定键对应的值</span><br>    mymap[<span class="hljs-string">&quot;gqc&quot;</span>] = <span class="hljs-string">&quot;064&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mymap.<span class="hljs-built_in">begin</span>(); iter != mymap.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//======================================</span><br><br><span class="hljs-comment">//输出为</span><br><span class="hljs-comment">//114</span><br><span class="hljs-comment">//ycy 514</span><br><span class="hljs-comment">//gqc 064</span><br><br>C++<br></code></pre></td></tr></table></figure><p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ]运算符才能成功获取该键对应的值；反之，若当前 map容器中没有包含该指定键的键值对，则此时使用 [ ]运算符将不再是访问容器中的元素，而变成了向该 map容器中增添一个键值对。其中，该键值对的键用 [ ]运算符中指定的键，其对应的值取决于 map容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是string 类型，其值为“”，即空字符串（即使用该类型的默认值作为键值对的值）。</p><p>同时，存储的键值对，其本质都是 pair 类模板创建的 pair对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">std::map&lt;std::string, <span class="hljs-type">int</span>&gt;myMap&#123;std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-number">114</span>),std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-number">514</span>)&#125;;<br><br>C++<br></code></pre></td></tr></table></figure><h4 id="获取元素">4. 获取元素</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      // map</span><br>using namespace std<span class="hljs-comment">;</span><br> <br><span class="hljs-built_in">int</span> main()&#123;<br>    //创建并初始化 map 容器<br>    std::map&lt;std::<span class="hljs-built_in">string</span>, std::<span class="hljs-built_in">string</span>&gt;myMap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-string">&quot;114&quot;</span>&#125;,<br>                                             &#123;<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-string">&quot;514&quot;&quot;&#125;,</span><br><span class="hljs-string">                                             &#123;&quot;</span>grl<span class="hljs-string">&quot;, &quot;</span><span class="hljs-number">1919</span><span class="hljs-string">&quot;&#125; &#125;;</span><br><span class="hljs-string">    string cValue = myMap[&quot;</span>gqc<span class="hljs-string">&quot;];</span><br><span class="hljs-string">    cout &lt;&lt; cValue &lt;&lt; endl;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">C++</span><br></code></pre></td></tr></table></figure><h4 id="迭代元素">5. 迭代元素</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      // pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>       // string</span><br>using namespace std<span class="hljs-comment">;</span><br> <br><span class="hljs-built_in">int</span> main() &#123;<br>    //创建并初始化 map 容器<br>    map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;myMap&#123; &#123;<span class="hljs-string">&quot;gqc&quot;</span>, <span class="hljs-string">&quot;114&quot;</span>&#125;,<br>                              &#123;<span class="hljs-string">&quot;ycy&quot;</span>, <span class="hljs-string">&quot;514&quot;&quot;&#125;,</span><br><span class="hljs-string">                              &#123;&quot;</span>grl<span class="hljs-string">&quot;, &quot;</span><span class="hljs-number">1919</span><span class="hljs-string">&quot;&#125;&#125;;</span><br><span class="hljs-string">    //调用 begin()/end() 组合，遍历 map 容器</span><br><span class="hljs-string">    for (map&lt;string, string&gt;::iterator iter = myMap.begin(); iter != myMap.end(); ++iter) &#123;</span><br><span class="hljs-string">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;</span> <span class="hljs-string">&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">C++</span><br></code></pre></td></tr></table></figure><h4 id="删除元素">6. 删除元素</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sas">删除键为bfff指向的元素<br>cmap.erase(<span class="hljs-string">&quot;bfff&quot;</span>);<br><br> <br>删除迭代器 <span class="hljs-keyword">key</span>所指向的元素<br>map&lt;string,int&gt;::iterator <span class="hljs-keyword">key</span> = cmap.find(<span class="hljs-string">&quot;mykey&quot;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">key</span>!=cmap.<span class="hljs-keyword">end</span>())<br>&#123;<br>    cmap.erase(<span class="hljs-keyword">key</span>);<br>&#125;<br> <br>删除所有元素<br>cmap.erase(cmap.begi<span class="hljs-meta">n</span>(), cmap.<span class="hljs-keyword">end</span>());<br><br>C++<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tree</title>
    <link href="/2022/10/20/Data%20Structure/Tree/"/>
    <url>/2022/10/20/Data%20Structure/Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="tree-的相关定义">1. Tree 的相关定义</h3><h4 id="tree-的定义">1.1. Tree 的定义</h4><p><strong>满足下列三个条件的</strong>数据结构叫做树</p><ol type="1"><li><p>A tree T is a collection of nodes(element).</p></li><li><p>The collection can be empty.</p></li><li><p>Otherwise, a tree consists of a distinguished node r , called theroot, and zero or more nonemppty (sub) trees <spanclass="math inline">\(T_1 , T_2 , ……, T_k\)</span>.</p></li></ol><h4 id="tree-的度叶枝层次和高度">1.2. Tree 的度，叶，枝，层次和高度</h4><ol type="1"><li><p>Degree of an elememts(nodes): the number of children ithas.</p></li><li><p>Degree of a tree: the maximum of its element degrees.</p></li><li><p>Leaf: element whose degree is 0.</p></li><li><p>Branch: element whose degree is not 0.</p></li><li><p>Level: the level of root is 0.</p><ul><li>the level of an element = the level of its parent + 1.</li></ul></li><li><p>Depth(Height) of a tree: the maximum level of itselements.</p></li></ol><h4 id="tree-的存储方法">1.3. Tree 的存储方法</h4><ol type="1"><li>广义表表示法</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>(<span class="hljs-selector-tag">b</span>(f,g),c,<span class="hljs-built_in">d</span>(h,<span class="hljs-selector-tag">i</span>,j),e)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>双亲表示法</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>左子女-右兄弟表示法</li></ol><h3 id="binary-tree">2. Binary Tree</h3><h4 id="binary-tree-的定义">2.1. Binary Tree 的定义</h4><p><strong>满足下列两个条件</strong>的叫做二叉树</p><ol type="1"><li><p>Definition: A binary tree t is a finite (possibly empty)collection of elements.</p></li><li><p>When the binary tree is not empty:</p><ul><li><p>It has a root element</p></li><li><p>The remaining elements(if any) are partitioned into two binarytrees, which are called the left and right subtrees of t.</p></li></ul></li></ol><h4 id="binary-tree-和一般意义的-tree-有什么区别">2.2. Binary Tree和一般意义的 Tree 有什么区别</h4><ul><li>Each element in a binary tree has exactly two subtrees(one or bothof these subtrees may be empty).<ul><li>Each element in a tree can have any number of subtrees.</li></ul></li><li>The subtrees of each element in a binary tree are ordered. That is,we distinguish between the left and the right subtrees.<ul><li>The subtrees in a tree are unordered.</li></ul></li></ul><h4 id="binary-tree-的性质">2.3. Binary Tree 的性质</h4><ul><li>The drawing of every binary tree with n elements (n&gt;0) hasexactly n-1 edges.<ul><li>因为二叉树是恰好连通的</li></ul></li><li>The number of elements at level <spanclass="math inline">\(i\)</span> is at most <spanclass="math inline">\(2^i \ (i \geq0)\)</span>.</li><li>A binary tree of height <span class="math inline">\(h,h\geq0\)</span> , has at least <span class="math inline">\(h+1\)</span>and at most <span class="math inline">\(2^{h+1}–1\)</span> elements init.</li></ul><p><span class="math display">\[\sum_{i = 0}^h2^i = 2^{h+1}-1\]</span></p><ul><li>If number of leaves is <span class="math inline">\(n_0\)</span> ,and the number of the 2 degree elements is <spanclass="math inline">\(n_2\)</span> , then <spanclass="math inline">\(n_0=n_2+1\)</span>.</li><li>The height of a binary tree that contains <spanclass="math inline">\(n (n \geq 0)\)</span> element is at most <spanclass="math inline">\(n-1\)</span> and at least <spanclass="math inline">\([log2 (n+1)]-1\)</span><ul><li>proof: Since there must be at least one element at each level, theheight cannot exceed <span class="math inline">\(n-1\)</span>.</li><li>From property 3,we know <span class="math inline">\(n \leq 2^h+1-1\)</span>, so, <span class="math inline">\(h \geq log2(n+1)-1\)</span>, since h is an integer,we get <spanclass="math inline">\(h=[log2 (n+1)]-1\)</span></li></ul></li><li>Let <span class="math inline">\(i, 0\leq i \leq n-1\)</span>, be thenumber assigned to an element of a complete binary tree. The followingare true.<ul><li>if <span class="math inline">\(i=0\)</span>, then this element isthe root of the binary tree. if <spanclass="math inline">\(i&gt;0\)</span>,then the parent of this elementhas been assigned the number <span class="math inline">\([\frac{i -1}{2}]\)</span></li><li>if <span class="math inline">\(2 \times i+1 \geq n\)</span>, thenthis element has no left child. Otherwise,its left child has beenassigned the number <span class="math inline">\(2\times i +1\)</span>.</li><li>if <span class="math inline">\(2 \times i+2\geq n\)</span>, thenthis element has no right child, Otherwise its right child has beenassigned the number <span class="math inline">\(2 \times i +2\)</span>.</li></ul></li></ul><h4 id="特殊类型的-binary-tree">2.4. 特殊类型的 Binary Tree</h4><h5 id="full-binary-tree">2.4.1 Full Binary Tree</h5><ul><li>A binary tree of height h that contains exactly <spanclass="math inline">\(2^h+1 -1\)</span> elements is called a full binarytree.</li></ul><h5 id="complete-binary-tree">2.4.2 Complete binary tree</h5><ul><li>Suppose we number the elements in a full binary tree of height husing the number 1 through <span class="math inline">\(2^{h+1} -1\)</span>. We began at level <span class="math inline">\(0\)</span> andgo down to level <span class="math inline">\(h\)</span>. Within levelsthe elements are numbered left to right. Suppose we delete the <spanclass="math inline">\(k\)</span> elements numbered <spanclass="math inline">\(2^{h+1} -i\)</span>, <span class="math inline">\(1\leq i \leq k\)</span>, the resulting binary tree is called a completebinary tree.</li><li>也就是说在广度优先的基础上要使这个二叉树尽可能的满</li></ul><h4 id="binary-tree-的物理层">2.5. Binary Tree 的物理层</h4><h5 id="array-实现">2.5.1 Array 实现</h5><ol type="1"><li>The binary tree to be represented is regarded as a complete binarytree with some missing elements.<ul><li>如图</li></ul></li></ol><pre><code class=" mermaid">graph TD0((0))--&gt;1((1))--&gt;3((3))--&gt;7((7))1((1))--&gt;4((4))0((0))--&gt;2((2))--&gt;5((5))2((2))--&gt;6((6))</code></pre><ol start="2" type="1"><li>这样表示的缺点<ul><li>如果这样的二叉树离完全二叉树很远，那么会很浪费空间</li></ul></li></ol><h5 id="linkedlist-实现">2.5.2 LinkedList 实现</h5><ol type="1"><li>每一个节点存储三个数据<ul><li>LeftTree （如果不存在的话就是 nullptr）</li><li>data</li><li>RightTree (如果不存在的话就是 nullptr)</li></ul></li></ol><ul><li><p>代码表示</p><ul><li>Java （更具体的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryNode</span>&#123;<br>  <br>  BinaryNode left;<br>  BinaryNode right;<br>  Object element;<br>  <br>  <br>  BinaryNode()&#123;<br>    letf = right = <span class="hljs-number">0</span>;<br>  &#125;<br>  BinaryNode(Object e)&#123;<br>    element = e;<br>    left = right = <span class="hljs-number">0</span>;<br>  &#125;<br>  BinaryNode(Object e, BinaryNode l, BinaryNode r)&#123;<br>    element = e;<br>    left = l;<br>    right = r;<br>  &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * • Create()</span><br><span class="hljs-comment">*• IsEmpty()</span><br><span class="hljs-comment">*• Root(x)</span><br><span class="hljs-comment">*• MakeTree(root, left, right)</span><br><span class="hljs-comment">*• BreakTree(root, left, right)</span><br><span class="hljs-comment">*• PreOrder</span><br><span class="hljs-comment">*• InOrder</span><br><span class="hljs-comment">*• PostOrder</span><br><span class="hljs-comment">*• LevelOrder</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* binaty.h</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123; <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BinaryTree</span>()&#123;root=<span class="hljs-number">0</span>;&#125;;<br>~<span class="hljs-built_in">BinaryTree</span>()&#123;&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> ((root)?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Root</span><span class="hljs-params">(T&amp; x)</span><span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeTree</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BreakTree</span><span class="hljs-params">(T&amp; data , BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span></span>&#123;<br>    <span class="hljs-built_in">PreOrder</span>(visit, root);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u))</span></span>&#123;<br>    <span class="hljs-built_in">InOrder</span>(visit, root);<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 这里的函数参数 void(*visit) 是函数指针</span><br><span class="hljs-comment">  * 这个指针指向一段代码，而不是一个数据</span><br><span class="hljs-comment">  * 这个指针的作用是执行指向指针的代码</span><br><span class="hljs-comment">  * @return nothing</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * The function visit is used as parameter to the traversal methods,so that different operations can be</span><br><span class="hljs-comment">* implemented easily</span><br><span class="hljs-comment">  */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span> <span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span></span>&#123;<br>    <span class="hljs-built_in">PostOrder</span>(visit, root);<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u))</span></span>;<br><span class="hljs-keyword">private</span>:<br>BinaryNode&lt;T&gt;* root;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit) (BinaryNode&lt;T&gt; *u), BinaryNode&lt;T&gt;*t)</span></span>;<br>&#125;;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 下面是一些成员函数的实现</span><br><span class="hljs-comment">*/</span><br><br>Template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> BinaryTree&lt;T&gt;::<span class="hljs-built_in">MakeTree</span>(<span class="hljs-type">const</span> T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)&#123; <br>  root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>&lt;T&gt;(data, leftch.root, rightch.root);<br>  leftch.root = rightch.root = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> BinaryTree&lt;T&gt;::<span class="hljs-built_in">BreakTree</span>(T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)&#123; <br>  <span class="hljs-keyword">if</span>(!root)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BadInput</span>();<br>  &#125;<span class="hljs-comment">//tree empty</span><br>data = root.element;<br>leftch.root = root.Left;<br>rightch.root = root.Right;<br><span class="hljs-keyword">delete</span> root;<br>root = <span class="hljs-number">0</span>;<br>&#125; <br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* main.cpp</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> “binary.h”</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>BinaryTree&lt;<span class="hljs-type">int</span>&gt; a, x, y, z;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 这是四个二叉树</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(BinaryTreeNode&lt;T&gt; *t)</span></span>&#123;<br>  count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; <br>  a.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  z.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  x.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">3</span>, a, z);<br>  y.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">4</span>, x, <span class="hljs-number">0</span>);<br>  y.<span class="hljs-built_in">PreOrder</span>(ct);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 在遍历所有节点的同时，调用一次 ct（ct只是一个计数器）</span><br><span class="hljs-comment">  */</span><br>  cout &lt;&lt; count &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="cursor-静态链表-实现">2.5.3 Cursor (静态链表) 实现</h5><h4 id="binary-tree-的遍历">2.6. Binary Tree 的遍历</h4><p>Each element is visited exactly once</p><ul><li><p>V：表示访问一个结点</p></li><li><p>L：表示访问V的左子树</p></li><li><p>R：表示访问V的右子树</p></li></ul><p>那么有六种情况：VLR LVR LRV VRL RVL RLV</p><p>一般地，我们都只考虑 L 在 R之前的情况，否则可以将这个二叉树的每一个节点的子节点都左右交换，形成它的反二叉树</p><p>因此树的遍历包括这四种情况</p><ul><li>Preorder （VLR）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><ul><li>Inorder （LVR）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非递归的写法，但是脑袋里要一直有递归的过程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Inorder</span><span class="hljs-params">(BinaryNode &lt;T&gt; * t)</span></span>&#123; <br>  stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="hljs-built_in">s</span>(<span class="hljs-number">10</span>);<br>BinaryNode&lt;T&gt; * p = t;<br><span class="hljs-keyword">for</span> (;;)&#123;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123; <br>      s.<span class="hljs-built_in">push</span>(p); <br>      p = p-&gt;Left; <br>    &#125;<br><span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">IsEmpty</span>())&#123; <br>    p = s.<span class="hljs-built_in">pop</span>();<br>cout &lt;&lt; p-&gt;element;<br>p = p-&gt;Right;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Postorder （LRV）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//和中序遍历的区别在于，要明确左右子树都要已经访问过了，再把当前节点弹出</span><br><span class="hljs-comment">//tag 的作用就在于此</span><br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StkNode</span>&#123; <br>  BinaryNode &lt;T&gt; * ptr;<br><span class="hljs-type">int</span> tag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Postorder</span><span class="hljs-params">(BinaryNode &lt;T&gt; * t)</span></span>&#123; <br>  stack &lt;StkNode&lt;T&gt;&gt;<span class="hljs-built_in">s</span>(<span class="hljs-number">10</span>);<br>StkNode&lt;T&gt; Cnode;<br>BinaryNode&lt;T&gt; * p = t;<br><span class="hljs-keyword">for</span>(;;)&#123; <br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)&#123; <br>      Cnode.ptr = p; <br>      Cnode.tag = <span class="hljs-number">0</span>; <br>      s.<span class="hljs-built_in">push</span>(Cnode);<br>p = p-&gt;Left;<br>&#125;<br>    Cnode = s.<span class="hljs-built_in">pop</span>(); <br>    p = Cnode.ptr;<br>     <span class="hljs-comment">//从右子树回来</span><br><span class="hljs-keyword">while</span> ( Cnode.tag = = <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; p-&gt;element;<br><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">IsEmpty</span>())&#123; <br>        Cnode = s.<span class="hljs-built_in">pop</span>(); <br>        p = Cnode.ptr; <br>      &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br>   Cnode.tag = <span class="hljs-number">1</span>; <br>    s.<span class="hljs-built_in">push</span>(Cnode); <br>    p = p-&gt;Right; <span class="hljs-comment">//从左子树回来</span><br>&#125;<span class="hljs-comment">//for</span><br>&#125; <br></code></pre></td></tr></table></figure><ul><li>Level order（一层一层地遍历）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BinaryNode&lt;T&gt;* t)</span></span>&#123; <br>  LinkedQueue&lt;BinaryNode&lt;T&gt;*&gt; Q;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-built_in">visit</span>(t); <span class="hljs-comment">//visit t</span><br>  <span class="hljs-keyword">if</span>(t-&gt;Left) Q.<span class="hljs-built_in">Add</span>(t-&gt;Left);<br>  <span class="hljs-keyword">if</span>(t-&gt;Right) Q.<span class="hljs-built_in">Add</span>(t-&gt;Right);<br>  <span class="hljs-keyword">try</span>&#123;Q.<span class="hljs-built_in">Delete</span>(t);&#125;<br><span class="hljs-built_in">catch</span>(OutOfBounds)&#123;<span class="hljs-keyword">return</span>;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bianry-tree-的实现方式">2.7. Bianry Tree 的实现方式</h4><h5 id="利用maketree函数">1. 利用MakeTree函数</h5><h5 id="利用先序中序唯一的构造一棵二叉树">2.利用先序、中序唯一的构造一棵二叉树</h5><ul><li><h5 id="先序abdcegfhi">先序：ABDCEGFHI</h5></li><li><h5 id="中序dbaegchfi-a-b-c-d-e-f-g-h-i">中序：DBAEGCHFI A B C D E FG H I</h5></li></ul><h5id="利用二叉树的广义表表示来构造一棵二叉树-abd-ce-g-fhi-a-b-c-d-e-f-g-h-i">3.利用二叉树的广义表表示来构造一棵二叉树 A(B(D), C(E( ,G), F(H,I))) A B CD E F G H I</h5><h5 id="利用二叉树的后缀表示来构造一棵二叉树-abc-abc-c-a-b">4.利用二叉树的后缀表示来构造一棵二叉树 (a+b)<em>c ab+c</em> * + c a b</h5>]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dat Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI Physics Layer</title>
    <link href="/2022/10/20/Computer%20Networking/OSI%20Model/OSI%20Physics%20Layer/"/>
    <url>/2022/10/20/Computer%20Networking/OSI%20Model/OSI%20Physics%20Layer/</url>
    
    <content type="html"><![CDATA[<h1 id="osi层次物理层">OSI层次：物理层</h1><blockquote><p>关键词：信号和介质</p><p>定义了在系统之间为了链路所需的电气的、功能的特征 (包括介质)</p><p>定义了电压级别、电压变化时机、物理数据速率、最大传输距离、物理连接器，以及其他相似性质</p></blockquote><h2 id="网络连接类型">1. 网络连接类型</h2><ol type="1"><li><p>多路复用共享介质</p><ul><li>多个主机可以访问同一介质</li><li>这意味着它们都共享相同的介质 —— 即是"wire"</li><li>如下图：</li></ul><pre><code class=" mermaid">graph LRs[== == == == == == == == == ==]a((a))--&gt; sb((b)) --&gt; sc((c))--&gt;sd((d))--&gt;s</code></pre></li><li><p>点对点(Point To Point)网络</p><ul><li>一个设备通过链路连接到另一个设备</li><li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li><li>如下图</li></ul><pre><code class=" mermaid">graph LRa((a))--&gt;b((b))</code></pre></li></ol><h2 id="局域网介质">2. 局域网介质</h2><p><strong>什么是局域网</strong></p><p>局域网是一种网络种类，覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。局域网可以实现<ahref="https://baike.baidu.com/item/文件管理/1452357?fromModule=lemma_inlink">文件管理</a>、应用软件共享、<ahref="https://baike.baidu.com/item/打印机共享/1979511?fromModule=lemma_inlink">打印机共享</a>等功能，在使用过程当中，通过维护局域网网络安全，能够有效地保护资料安全，保证局域网网络能够正常稳定的运行。</p><h3 id="utp">2.1. UTP</h3><blockquote><p><strong>无屏蔽双绞线</strong> (Unshielded Twisted Pair)</p></blockquote><h4 id="utp-的分类">2.1.2. UTP 的分类</h4><p><strong>一类线</strong>：主要用于语音传输，不用于数据传输</p><p><strong>二类线</strong>：传输频率 1 MHz，用于语音和最高 4 Mbps的数据传输，常见于令牌网</p><p><strong>三类线</strong>：EIA / TIA568 标准指定电缆，传输频率 16 MHz，用于语音传输及最高传输速率为 10 Mbps 的数据传输，主要用于10BASE-T</p><p><strong>四类线</strong>：传输频率为 20 MHz，用于语音传输和最高传输速率 16 Mbps的数据传输，主要用于令牌网和10BASE-T/100BASE-T</p><p><strong>五类线</strong>：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆</p><p><strong>超五类线</strong>：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</p><p><strong>六类线</strong>：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</p><p><strong>七类线</strong>：带宽为600MHz，可能用于今后的10G比特以太网。</p><h3 id="coaxial-cable">2.2. Coaxial Cable</h3><blockquote><p><strong>同轴电缆</strong></p></blockquote><p><ahref="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec02/5.png"><imgsrc="https://naturalifica.oss-cn-nanjing.aliyuncs.com/~/Users/wuchentian/SoloLearning/Blog/source/imgs202210290929399.png"alt="img" /></a></p><ol type="1"><li>薄/厚</li><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，无论如何比双绞线传输更加远，成本也要高一点</li><li>内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。</li></ol><h2 id="section"></h2><h2 id="网线的分类">2.网线的分类</h2><p>a.直通线</p><p>在所有末端使用T568A或者T568B</p><p>用于连接<strong>PC和交换机</strong>以及连接<strong>交换机和路由器</strong></p><p>b.反转线（控制线）</p><p>用于把PC连接到交换机或者路由器</p><p>一端的插脚1连接另一端的插脚8；然后插脚2连接到插脚7、插脚3连接到插脚6，以此类推</p><p>c.交叉线</p><p>一端是T568A，另一端是T568B</p><p>可用于PC与路由器直连，也可用于连接两个或多个集线器或交换机</p><p>连接两个独立的工作站以创建迷你局域网</p><h1 id="数据通信基本知识">3.数据通信基本知识</h1><h2 id="基本术语">①基本术语</h2><p>信号：数据的电气或者电磁的表现</p><p>码元：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h2 id="信号处理">②信号处理</h2><p>模拟信号可以被分为简单信号和复合信号</p><p>简单信号（正弦波）不能被分解为更简单的模拟信号</p><p>复合信号可以被分解为多个<strong>正弦波</strong></p><p>复合模拟信号的分解：<strong>傅立叶分析</strong></p><p>任何一个周期为T的有理周期性函数 g(t)可分解为若干项（可能无限多项）正弦和余弦函数之和： <span class="math display">\[g(t) = \frac12c+\sum_{i = 1}^{\infty}a_n\sin(2\pi nft)+\sum_{i =1}^{\infty}b_n\cos(2\pi nft)\]</span> 数字信号一般是非周期性的，通常在传输介质上表现为方波</p><p>一个数字信号可以分解为无穷多个被称为谐波的简单正弦波，每个谐波都具有不同的频率与相位</p><p>在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号畸变</p><p>由于介质本身的限制，信号畸变是难以完全避免的</p><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p><p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重</p><h2 id="理论基础">③理论基础</h2><p>a.波特率和比特率</p><p>波特率（调制速率）：信号每秒钟变化的次数</p><p>比特率：每秒钟传送的二进制位数。</p><p>b.波特率与比特率的关系取决于信号值与比特位的关系</p><p>例：每个信号值表示为３位，则比特率是波特率的３倍；每个信号值表示为１位，则比特率和波特率相同</p><p>对于比特率为a bps的信道，发送８位所需的时间为8/a秒，若８位为一个周期Ｔ，则一次谐波的频率是： f = a/8 Hz</p><h2 id="数据通信技术编码方式">④数据通信技术：编码方式)</h2>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
      <category>OSI Model</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存分配——从类的初始化开始</title>
    <link href="/2022/10/19/C++%20Basic/Object%20Oriented/C++%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E4%BB%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%20/"/>
    <url>/2022/10/19/C++%20Basic/Object%20Oriented/C++%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E2%80%94%E2%80%94%E4%BB%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BC%80%E5%A7%8B%20/</url>
    
    <content type="html"><![CDATA[<h4 id="起因">1. 起因</h4><p>事情是这样：在最近的一次C++作业中，我需要用<strong>链表</strong>实现一个<strong>双向队列</strong>。</p><p>我对链表节点的实现如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span><span class="hljs-title">&#123;</span><br><span class="hljs-title">    Node</span> *next;<br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">*prev</span>;<br>    int val;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> val, <span class="hljs-keyword">Node</span> <span class="hljs-title">*prev</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>)；<br>&#125;;<br><br>CRMSH<br></code></pre></td></tr></table></figure><p>我对双向队列的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Deque</span>&#123;<br>    <span class="hljs-type">int</span> size;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * front 和 rear 分别为虚拟头指针和尾指针</span><br><span class="hljs-comment">  */</span><br>    Node *front;<br>    Node *rear;<br>    <span class="hljs-built_in">Deque</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br>    <span class="hljs-type">void</span> pop_front;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ~<span class="hljs-built_in">Deque</span>() = deafult;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>当我试图利用 <code>Deque::push_back(int value)</code>函数向队列中添加元素时，我起初的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @param value 新节点的值</span><br><span class="hljs-comment">  * @param prev 新节点的前一个节点</span><br><span class="hljs-comment">  * @param next 新节点的下一个节点</span><br><span class="hljs-comment">  * @return 一个船新节点</span><br><span class="hljs-comment">  */</span><br>    Node node = *<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = &amp;node;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是程序每次运行到这里都会中断，debug 显示无论我 new 多少个新的node，它们的地址都是一样的，因此所有新节点都连着它本身，于是爆栈了。但是如果我把写法改成如下这样，程序就恢复了正常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @param value 新节点的值</span><br><span class="hljs-comment">  * @param prev 新节点的前一个节点</span><br><span class="hljs-comment">  * @param next 新节点的下一个节点</span><br><span class="hljs-comment">  * @return 一个船新节点</span><br><span class="hljs-comment">  */</span><br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = node;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="一个合理的解释">2. 一个合理的解释</h4><p>首先我们需要了解 C++ 的内存分配</p><table><thead><tr class="header"><th>名称</th><th>特性</th></tr></thead><tbody><tr class="odd"><td><strong>栈</strong></td><td>由编译器在需要时自动分配，不需要时自动清除的变量存储区。通常存放局部变量、函数参数等。</td></tr><tr class="even"><td><strong>堆</strong></td><td>由 new 分配的内存块，由程序员释放（编译器不管），一般一个 new 与一个delete 对应，一个 new[] 与一个 delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。</td></tr><tr class="odd"><td><strong>自由存储区</strong></td><td>由 malloc等分配的内存块，和堆十分相似，用free来释放。（实际上和堆是同一块区域）</td></tr><tr class="even"><td><strong>全局/静态存储区</strong></td><td>全局变量和静态变量被分配到同一块内存中（在 C语言中，全局变量又分为初始化的和未初始化的，C++ 中没有这一区分）。</td></tr><tr class="odd"><td><strong>常量存储区</strong></td><td>这是一块特殊存储区，里边存放常量，不允许修改。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br></code></pre></td></tr></table></figure><p>我们知道，由 <code>new</code>建立的变量存储在堆中。因此上述代码在堆区新建一个对象，并且返回该对象的地址，由<code>Node</code> 类型指针 <code>node</code> 存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node node = *<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br></code></pre></td></tr></table></figure><p>上述代码同样新建一个 <code>Node</code> 对象，并将这个 Node对象的值存储到一个 <code>Node</code> 类型的变量 <code>node</code>中，相当于如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node *np = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>Node node = *np;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* node 只是值传递</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>因此，在下一步的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">rear-&gt;prev-&gt;next = &amp;node;<br></code></pre></td></tr></table></figure><p>中，<code>&amp;node</code> 根本就不是那个指向新节点的指针<code>np</code>，而是一个临时栈变量 <code>node</code> 的地址。这里相当于<code>np-&gt;prev-&gt;next = &amp;node</code>。</p><pre><code class=" mermaid">graph LRrear_prev---&gt;rear---&gt;rear_prevnp---&gt;new_Node&amp;node---&gt;somewhere</code></pre><p>转变成了</p><pre><code class=" mermaid">graph LRnp--&gt;rearnp--&gt;rear_prev--&gt;&amp;node--&gt;rear_prev&amp;node--&gt;rear</code></pre><p>再经过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">rear-&gt;prev = &amp;node<br></code></pre></td></tr></table></figure><p>这一步后，转变为</p><pre><code class=" mermaid">graph LRnp--&gt;rearnp--&gt;&amp;node--&gt;rear&amp;node--&gt;&amp;node--&gt;&amp;node</code></pre><p>在 <code>node</code>这里出现了死循环，导致内存爆了</p><h3 id="源码">3. 源码</h3><p>在这里贴上我所有成员函数的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node::<span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> val, Node *prev, Node *next)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;val = val;<br>    <span class="hljs-keyword">this</span>-&gt;next = next;<br>    <span class="hljs-keyword">this</span>-&gt;prev = prev;<br>&#125;<br><br><br>Deque::<span class="hljs-built_in">Deque</span>()&#123;<br>    <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>    front = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, front, <span class="hljs-literal">nullptr</span>);<br>    front-&gt;next = rear;<br>    front-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>    rear-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    rear-&gt;prev = front;<br>&#125;<br><br>Deque::<span class="hljs-built_in">push_front</span>(<span class="hljs-type">int</span> value)&#123;<br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, front, front-&gt;next);<br>    node-&gt;next-&gt;prev = node;<br>    front-&gt;next = node;<br>    <span class="hljs-keyword">this</span>-&gt;size++;<br>&#125;<br><br>Deque::<span class="hljs-built_in">push_back</span>(<span class="hljs-type">int</span> value)&#123;<br>    Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value, rear-&gt;prev, rear);<br>    rear-&gt;prev-&gt;next = node;<br>    rear-&gt;prev = node;<br>    <span class="hljs-keyword">this</span>-&gt;size++;<br>&#125;<br><br>Deque::<span class="hljs-built_in">get_size</span>() <span class="hljs-type">const</span>&#123;<br>    cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;size &lt;&lt; endl;<br>&#125;<br><br>Deque::<span class="hljs-built_in">pop_front</span>()&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;size &lt;= <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; (*(front-&gt;next)).val &lt;&lt; endl;<br>        front-&gt;next = front-&gt;next-&gt;next;<br>        front-&gt;next-&gt;prev = front;<br>        <span class="hljs-keyword">this</span>-&gt;size--;<br>    &#125;<br>&#125;<br><br>Deque::<span class="hljs-built_in">pop_back</span>()&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;size &lt;= <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; (*(rear-&gt;prev)).val &lt;&lt; endl;<br>        rear-&gt;prev = rear-&gt;prev-&gt;prev;<br>        rear-&gt;prev-&gt;next = rear;<br>        <span class="hljs-keyword">this</span>-&gt;size--;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="参考文章">4. 参考文章</h4><ol type="1"><li>http://t.csdn.cn/5QbW0</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>Object Oriented</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Object Oriented</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2022/10/16/Java%20Basic/Java%20IO/"/>
    <url>/2022/10/16/Java%20Basic/Java%20IO/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Java Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中的字符串处理</title>
    <link href="/2022/10/16/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/16/Java%20Basic/Java%20%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串拼接concat">1. 字符串拼接<code>(concat())</code></h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nim">/**<br>* java.lang.<span class="hljs-type">String</span><br>*/<br>public <span class="hljs-type">String</span> concat(<span class="hljs-type">String</span> str)<span class="hljs-meta">&#123;...&#125;</span><br><br>/**<br>* example<br>*/<br><br>private <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> getBCDString_4(<span class="hljs-type">int</span> val) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++, val = val / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (val % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;1&quot;</span>.concat(<span class="hljs-built_in">result</span>);<br>        &#125;    <br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">result</span> = <span class="hljs-string">&quot;0&quot;</span>.concat(<span class="hljs-built_in">result</span>);<br>        &#125;<br>                <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br><br><span class="hljs-type">JAVA</span><br></code></pre></td></tr></table></figure><h4 id="字符串转任意不同进制的整数parseint">2.字符串转任意不同进制的整数<code>(parseInt())</code></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* java.lang.Integer</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> throws NumberFormatException </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(s,<span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">int</span> radix)</span> throws NumberFormatException </span>&#123;...&#125;<br><span class="hljs-comment">//其中radix表示进制</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* example</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">NBCDTrueValue</span><span class="hljs-params">(<span class="hljs-type">String</span> operand)</span> </span>&#123;<br>    StringBuilder ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>    <span class="hljs-keyword">if</span> (operand.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;1101&quot;</span>)) &#123;<br>        ans.<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    operand = operand.<span class="hljs-built_in">substring</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; operand.<span class="hljs-built_in">length</span>() &amp;&amp; i &lt; <span class="hljs-number">28</span>; i += <span class="hljs-number">4</span>) &#123;<br>        ans.<span class="hljs-built_in">append</span>(Integer.<span class="hljs-built_in">valueOf</span>(operand.<span class="hljs-built_in">substring</span>(i, i + <span class="hljs-number">4</span>), <span class="hljs-number">2</span>));        <br>    &#125;<br>    <span class="hljs-keyword">return</span> Integer.<span class="hljs-built_in">parseInt</span>(ans.<span class="hljs-built_in">toString</span>());<br>&#125;<br><br>JAVA<br></code></pre></td></tr></table></figure><h4 id="和上一点类似的还有long.parselong-double.parsedouble">3.和上一点类似的，还有<code>Long.parseLong()</code>,<code>Double.parseDouble()</code></h4><h4 id="整数转字符串">4. 整数转字符串</h4><ol type="1"><li></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java Basic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ stack</title>
    <link href="/2022/10/10/C++%20Basic/%E8%80%83%E8%AF%95%E5%BF%85%E5%A4%87/C++%20%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/"/>
    <url>/2022/10/10/C++%20Basic/%E8%80%83%E8%AF%95%E5%BF%85%E5%A4%87/C++%20%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="大数加法">1. 大数加法</h4><h5 id="string不方便">1.1. <code>string</code>(不方便)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//需要用到其中的 reverse(T&amp; begin, )</span></span><br><span class="hljs-function">string <span class="hljs-title">addStr</span><span class="hljs-params">(string src, string dest)</span></span>&#123;<br>  string ans;<br>  <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; src.<span class="hljs-built_in">size</span>() || i &lt; dest.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <br>  &#125;<br>  <br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="vector方便">1.2. <code>vector</code>（方便）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">addVec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v1, vector&lt;<span class="hljs-type">int</span>&gt; v2)</span></span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 注意这里的vector将原有的大数倒序存储</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(max(v1.size(), v2.size()), <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()); i++)&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; v1.<span class="hljs-built_in">size</span>())&#123;<br>      ans[i] += v1[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &lt; v2.<span class="hljs-built_in">size</span>())&#123;<br>      ans[i] += v2[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">while</span>(ans[i] &gt;= <span class="hljs-number">10</span>)&#123;<br>      ans[i] -= <span class="hljs-number">10</span>;<br>      ans[i + <span class="hljs-number">1</span>]++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">10</span>)&#123;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span>(ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] &gt;= <span class="hljs-number">10</span>)&#123;<br>    ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>] -= <span class="hljs-number">10</span>;<br>    ans[ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]++;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h5 id="string-vector方便">1.3<code>string &amp; vector</code>(方便)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string s1, string s2)</span></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; vec1, vec2, ansVec;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    vec1.<span class="hljs-built_in">push_back</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    vec2.<span class="hljs-built_in">push_back</span>(s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  ansVec = <span class="hljs-built_in">addVec</span>(vec1, vec2);<br>  <span class="hljs-built_in">reverse</span>(ansVec.<span class="hljs-built_in">begin</span>(), ansVec.<span class="hljs-built_in">end</span>());<br>  string ansStr;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ansVec.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    ansStr += (ansVec[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ansStr;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="连续输入模版">2. 连续输入模版</h4><h5 id="允许使用-containers">2.1. 允许使用 Containers</h5><h4 id="字符串分割">3. 字符串分割</h4><h5 id="用-vector">3.1. 用 <code>vector</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str, <span class="hljs-type">char</span> sep)</span> </span>&#123;<br>  <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>  vector&lt;string&gt; res;<br>  string temp;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, temp, sep)) &#123;<br>    res.<span class="hljs-built_in">push_back</span>(temp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>C++<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>考试必备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proficiency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ stack</title>
    <link href="/2022/10/10/C++%20Basic/STL%20Containers/C++%20stack/"/>
    <url>/2022/10/10/C++%20Basic/STL%20Containers/C++%20stack/</url>
    
    <content type="html"><![CDATA[<p><code>stack</code> 容器有广泛的应用。例如，编辑器中的<code>undo</code>(撤销)机制就是用堆栈来记录连续的变化。撤销操作可以取消最后一个操作，这也是发生在堆栈顶部的操作。编译器使用堆栈来解析算术表达式，当然也可以用堆栈来记录 C++ 代码的函数调用。</p><h4 id="头文件">1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="初始化">2. 初始化</h4><p>下面展示了如何定义一个用来存放字符串对象的 stack 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;std::string&gt; words;<br></code></pre></td></tr></table></figure><p>stack容器适配器的模板有两个参数。第一个参数是存储对象的类型，第二个参数是底层容器的类型。<code>stack&lt;T&gt;</code>的底层容器默认是 <code>deque&lt;T&gt;</code>容器，因此模板类型其实是<code>stack&lt;typename T, typename Container=deque&lt;T&gt;&gt;</code>。通过指定第二个模板类型参数，可以使用任意类型的底层容器，只要它们支持<code>back()、push_back()、pop_back()、empty()、size()</code>这些操作。</p><p>下面展示了如何定义一个使用 <code>list&lt;T&gt;</code> 的堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;std::string,std::list&lt;std::string&gt;&gt; fruit;<br></code></pre></td></tr></table></figure><p><code>stack&lt;T&gt;</code>模板定义了拷贝构造函数，因而可以复制现有的 <code>stack</code> 容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">double</span>,std::list&lt;<span class="hljs-type">double</span>&gt;&gt;copy_stack &#123;my_stack&#125;<br></code></pre></td></tr></table></figure><p><code>copy_stack</code> 是 <code>my_stack</code>的副本。在使用拷贝构造函数时，既可以用初始化列表，也可以用圆括号。</p><h4 id="常用函数和操作">3. 常用函数和操作</h4><ol type="1"><li>和其他序列容器相比，<code>stack</code>是一类存储机制简单、所提供操作较少的容器。下面是 <code>stack</code>容器可以提供的一套完整操作：</li></ol><ul><li><code>top()</code>：返回一个栈顶元素的引用，类型为<code>T&amp;</code>。如果栈为空，返回值未定义。</li><li><code>push(const T&amp; obj)</code>：可以将对象副本压入栈顶。这是通过调用底层容器的<code>push_back()</code> 函数完成的。</li><li><code>push(T&amp;&amp; obj)</code>：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的push_back() 函数完成的。</li><li><code>pop()</code>：弹出栈顶元素。</li><li><code>size()</code>：返回栈中元素的个数。</li><li><code>empty()</code>：在栈中没有元素的情况下返回<code>true</code>。</li><li><code>emplace()</code>：用传入的参数调用构造函数，在栈顶生成对象。</li><li><code>swap(stack&lt;T&gt; &amp; other_stack)</code>：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于stack 对象有一个特例化的全局函数 swap() 可以使用</li></ul><ol type="1"><li><code>stack&lt;T&gt;</code> 模板也定义了复制和移动版的<code>operator=()</code> 函数，因此可以将一个 <code>stack</code>对象赋值给另一个 <code>stack</code> 对象。<code>stack</code>对象有一整套比较运算符。比较运算通过字典的方式来比较底层容器中相应的元素。字典比较是一种用来对字典中的单词进行排序的方式。依次比较对应元素的值，直到遇到两个不相等的元素。第一个不匹配的元素会作为字典比较的结果。如果一个<code>stack</code> 的元素比另一个 <code>stack</code>的多，但是所匹配的元素都相等，那么元素多的那个 <code>stack</code>容器大于元素少的 <code>stack</code> 容器。</li><li>下面用 <code>stack</code> 实现一个表达式求值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A simple calculator using stack containers</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>                                          <span class="hljs-comment">// For pow() function</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                       <span class="hljs-comment">// For standard streams</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span>                                          <span class="hljs-comment">// For stack&lt;T&gt; container</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>                                      <span class="hljs-comment">// For remove()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>                                      <span class="hljs-comment">// For runtime_error exception</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                                         <span class="hljs-comment">// For string class</span></span><br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// Returns value for operator precedence</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> <span class="hljs-title">precedence</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> op)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;^&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">throw</span> std::runtime_error &#123;string &#123;<span class="hljs-string">&quot;invalid operator in precedence() function: &quot;</span>&#125; + op&#125;;<br>&#125;<br><br><span class="hljs-comment">// Execute an operation</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">execute</span><span class="hljs-params">(std::stack&lt;<span class="hljs-type">char</span>&gt;&amp; ops, std::stack&lt;<span class="hljs-type">double</span>&gt;&amp; operands)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> result &#123;&#125;;<br>    <span class="hljs-type">double</span> rhs &#123;operands.<span class="hljs-built_in">top</span>()&#125;;                            <span class="hljs-comment">// Get rhs...</span><br>    operands.<span class="hljs-built_in">pop</span>();                                         <span class="hljs-comment">// ...and delete from stack</span><br>    <span class="hljs-type">double</span> lhs &#123;operands.<span class="hljs-built_in">top</span>()&#125;;                            <span class="hljs-comment">// Get lhs...</span><br>    operands.<span class="hljs-built_in">pop</span>();                                         <span class="hljs-comment">// ...and delete from stack</span><br><br>    <span class="hljs-keyword">switch</span> (ops.<span class="hljs-built_in">top</span>())                                      <span class="hljs-comment">// Execute current op</span><br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            result = lhs + rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            result = lhs - rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            result = lhs * rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            result = lhs / rhs;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>            result = std::<span class="hljs-built_in">pow</span>(lhs, rhs);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> std::runtime_error &#123;string&#123;<span class="hljs-string">&quot;invalid operator: &quot;</span>&#125; + ops.<span class="hljs-built_in">top</span>()&#125;;<br>    &#125;<br>    ops.<span class="hljs-built_in">pop</span>();                                              <span class="hljs-comment">// Delete op just executed</span><br>    operands.<span class="hljs-built_in">push</span>(result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::stack&lt;<span class="hljs-type">double</span>&gt; operands;                            <span class="hljs-comment">// Push-down stack of operands</span><br>    std::stack&lt;<span class="hljs-type">char</span>&gt; operators;                             <span class="hljs-comment">// Push-down stack of operators</span><br>    string exp;                                             <span class="hljs-comment">// Expression to be evaluated</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;An arithmetic expression can include the operators +, -, *, /, and ^ for exponentiation.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Enter an arithmetic expression and press Enter - enter an empty line to end:&quot;</span> &lt;&lt; std::endl;<br>            std::<span class="hljs-built_in">getline</span>(std::cin, exp, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (exp.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>          <br>            <span class="hljs-comment">// Remove spaces</span><br>            exp.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(std::<span class="hljs-built_in">begin</span>(exp), std::<span class="hljs-built_in">end</span>(exp), <span class="hljs-string">&#x27; &#x27;</span>), std::<span class="hljs-built_in">end</span>(exp));<br><br>            <span class="hljs-type">size_t</span> index &#123;&#125;;                                    <span class="hljs-comment">// Index to expression string</span><br><br>            <span class="hljs-comment">// Every expression must start with a numerical operand</span><br>            operands.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stod</span>(exp, &amp;index));              <span class="hljs-comment">// Push the first (lhs) operand on the stack</span><br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                operators.<span class="hljs-built_in">push</span>(exp[index++]);                     <span class="hljs-comment">// Push the operator on to the stack</span><br><br>                <span class="hljs-comment">// Get rhs operand</span><br>                <span class="hljs-type">size_t</span> i &#123;&#125;;                                      <span class="hljs-comment">// Index to substring</span><br>                operands.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stod</span>(exp.<span class="hljs-built_in">substr</span>(index), &amp;i));  <span class="hljs-comment">// Push rhs operand</span><br>                index += i;                                       <span class="hljs-comment">// Increment expression index</span><br><br>                <span class="hljs-keyword">if</span> (index == exp.<span class="hljs-built_in">length</span>())                        <span class="hljs-comment">// If we are at end of exp...</span><br>                &#123;<br>                    <span class="hljs-keyword">while</span> (!operators.<span class="hljs-built_in">empty</span>())                      <span class="hljs-comment">// ...execute outstanding ops</span><br>                        <span class="hljs-built_in">execute</span>(operators, operands);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// If we reach here, there&#x27;s another op...</span><br>                <span class="hljs-comment">// If there&#x27;s a previous op of equal or higher precedence execute it</span><br>                <span class="hljs-keyword">while</span> (!operators.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">precedence</span>(exp[index]) &lt;= <span class="hljs-built_in">precedence</span>(operators.<span class="hljs-built_in">top</span>()))<br>                    <span class="hljs-built_in">execute</span>(operators, operands);                   <span class="hljs-comment">//  Execute previous op.</span><br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;result = &quot;</span> &lt;&lt; operands.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e)<br>    &#123;<br>        std::cerr &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Calculator ending...&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>C++<br></code></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/180.html">while循环</a>包含在一个 try 代码块中，这样就可以捕获抛出的任何异常。在<code>catch</code> 代码块中，调用异常对象的成员函数 <code>what()</code>会将错误信息输出到标准错误流中。在一个死循环中执行输入操作，当输入一个空字符串时，循环结束。可以使用<code>remove()</code> 算法消除非空字符串中的空格。<code>remove()</code>不能移除元素，而只能通过移动元素的方式来覆盖要移除的元素。</p><p>为了移除 <code>exp</code>字符串中剩下的多余元素，可以用两个迭代器作为参数调用<code>erase()</code>。其中第一个迭代器由 <code>remove()</code>返回，指向字符串的最后一个有效元素的后面位置。第二个迭代器是字符串原始状态的结束迭代器。这两个迭代器指定范围的元素会被删除。</p><p>每个浮点操作数的值都是用定义在头文件 <code>string</code> 中的<code>stod()</code> 函数获取的。这会将第一个字符串参数中的字符序列转换为<code>double</code>值。函数会从第一个表示有效浮点数的字符串的第一个字符开始，获取最长字符序列。第二个参数是一个整型<ahref="http://c.biancheng.net/c/80/">指针</a>，保存的是字符串中非数字部分第一个字符的索引。<code>string</code>头文件中定义了 <code>stod()</code> 函数，它可以返回一个<code>float</code> 值。 <code>stod()</code>会返回一个<code>long double</code> 值。</p><p>因为所有的运算符都需要两个操作数，所以有效的输入字符串格式总是为<code>operand op operand op operand</code>，等等。序列的第一个和最后一个元素都是操作数，每对操作数之间有一个运算符。因为有效表达式总是以操作数开头，所以第一个操作数在分析表达式的嵌套循环之前被提取出来。在循环中，输入字符串的运算符会被压入<code>operators</code> 栈。在确认没有到达字符串末尾后，再从<code>exp</code> 提取第二个操作数。这时，<code>stod()</code>的第一个参数是从 <code>index</code> 开始的 <code>exp</code>字符串，它是被压入 <code>operators</code>栈的运算符后的字符。非数字字符串的第一个索引保存在 <code>i</code>中。因为 <code>i</code> 是相对于 <code>index</code>的，所以我们会将<code>index</code> 加上<code>i</code>的值，使它指向操作数后的一个运算符(如果是 <code>exp</code>中的最后一个操作数，它会指向字符串末尾的下一个位置)。</p><p>当 <code>index</code> 的值超过 <code>exp</code>的最后一个字符时，会执行<code>operators</code>容器中剩下的运算符。如果没有到达字符串末尾，<code>operators</code>容器也不为空，我们会比较 <code>operators</code> 栈顶运算符和<code>exp</code>中下一个运算符的优先级。如果栈顶运算符的优先级高于下一个运算符，就先执行栈顶的运算符。否则，就不执行栈顶运算符，在下一次循环开始时，将下一个运算符压入<code>operators</code>栈。通过这种方式，就可以正确计算出带优先级的表达式的值。</p><h4 id="参考文章-视频">4. 参考文章 &amp; 视频</h4><ol type="1"><li><a href="http://c.biancheng.net/view/478.html">C++ stack(STLstack)用法详解</a></li><li><ahref="https://b23.tv/hIdZ8ul">【数据结构】《编程实现》(栈的应用)（表达式的求值）-哔哩哔哩</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Basic</category>
      
      <category>STL Containers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList</title>
    <link href="/2022/10/10/Data%20Structure/LinkedList/"/>
    <url>/2022/10/10/Data%20Structure/LinkedList/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Data Structure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
